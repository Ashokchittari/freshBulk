{"ast":null,"code":"import { spanToJSON, logger, SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE } from '@sentry/core';\nimport { WINDOW } from '../helpers.js';\nimport '@sentry-internal/browser-utils';\nimport '../stack-parsers.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport '../integrations/breadcrumbs.js';\nimport '../integrations/browserapierrors.js';\nimport '../integrations/browsersession.js';\nimport '../integrations/globalhandlers.js';\nimport '../integrations/httpcontext.js';\nimport '../integrations/linkederrors.js';\n\n// 1h in seconds\nconst PREVIOUS_TRACE_MAX_DURATION = 3600;\n\n// session storage key\nconst PREVIOUS_TRACE_KEY = 'sentry_previous_trace';\nconst PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE = 'sentry.previous_trace';\n\n/**\n * Adds a previous_trace span link to the passed span if the passed\n * previousTraceInfo is still valid.\n *\n * @returns the updated previous trace info (based on the current span/trace) to\n * be used on the next call\n */\nfunction addPreviousTraceSpanLink(previousTraceInfo, span) {\n  const spanJson = spanToJSON(span);\n  if (!previousTraceInfo) {\n    return {\n      spanContext: span.spanContext(),\n      startTimestamp: spanJson.start_timestamp\n    };\n  }\n  const previousTraceSpanCtx = previousTraceInfo.spanContext;\n  if (previousTraceSpanCtx.traceId === spanJson.trace_id) {\n    // This means, we're still in the same trace so let's not update the previous trace info\n    // or add a link to the current span.\n    // Once we move away from the long-lived, route-based trace model, we can remove this cases\n    return previousTraceInfo;\n  }\n\n  // Only add the link if the startTimeStamp of the previous trace's root span is within\n  // PREVIOUS_TRACE_MAX_DURATION (1h) of the current root span's startTimestamp\n  // This is done to\n  // - avoid adding links to \"stale\" traces\n  // - enable more efficient querying for previous/next traces in Sentry\n  if (Date.now() / 1000 - previousTraceInfo.startTimestamp <= PREVIOUS_TRACE_MAX_DURATION) {\n    if (DEBUG_BUILD) {\n      logger.info(`Adding previous_trace ${previousTraceSpanCtx} link to span ${{\n        op: spanJson.op,\n        ...span.spanContext()\n      }}`);\n    }\n    span.addLink({\n      context: previousTraceSpanCtx,\n      attributes: {\n        [SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE]: 'previous_trace'\n      }\n    });\n\n    // TODO: Remove this once EAP can store span links. We currently only set this attribute so that we\n    // can obtain the previous trace information from the EAP store. Long-term, EAP will handle\n    // span links and then we should remove this again. Also throwing in a TODO(v10), to remind us\n    // to check this at v10 time :)\n    span.setAttribute(PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE, `${previousTraceSpanCtx.traceId}-${previousTraceSpanCtx.spanId}-${previousTraceSpanCtx.traceFlags === 0x1 ? 1 : 0}`);\n  }\n  return {\n    spanContext: span.spanContext(),\n    startTimestamp: spanToJSON(span).start_timestamp\n  };\n}\n\n/**\n * Stores @param previousTraceInfo in sessionStorage.\n */\nfunction storePreviousTraceInSessionStorage(previousTraceInfo) {\n  try {\n    WINDOW.sessionStorage.setItem(PREVIOUS_TRACE_KEY, JSON.stringify(previousTraceInfo));\n  } catch (e) {\n    // Ignore potential errors (e.g. if sessionStorage is not available)\n    DEBUG_BUILD && logger.warn('Could not store previous trace in sessionStorage', e);\n  }\n}\n\n/**\n * Retrieves the previous trace from sessionStorage if available.\n */\nfunction getPreviousTraceFromSessionStorage() {\n  try {\n    const previousTraceInfo = WINDOW.sessionStorage?.getItem(PREVIOUS_TRACE_KEY);\n    // @ts-expect-error - intentionally risking JSON.parse throwing when previousTraceInfo is null to save bundle size\n    return JSON.parse(previousTraceInfo);\n  } catch (e) {\n    return undefined;\n  }\n}\nexport { PREVIOUS_TRACE_KEY, PREVIOUS_TRACE_MAX_DURATION, PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE, addPreviousTraceSpanLink, getPreviousTraceFromSessionStorage, storePreviousTraceInSessionStorage };","map":{"version":3,"names":["PREVIOUS_TRACE_MAX_DURATION","PREVIOUS_TRACE_KEY","PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE","addPreviousTraceSpanLink","previousTraceInfo","span","spanJson","spanToJSON","spanContext","startTimestamp","start_timestamp","previousTraceSpanCtx","traceId","trace_id","Date","now","DEBUG_BUILD","logger","info","op","addLink","context","attributes","SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE","setAttribute","spanId","traceFlags","storePreviousTraceInSessionStorage","WINDOW","sessionStorage","setItem","JSON","stringify","e","warn","getPreviousTraceFromSessionStorage","getItem","parse","undefined"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry\\browser\\src\\tracing\\previousTrace.ts"],"sourcesContent":["import type { Span } from '@sentry/core';\nimport { logger, SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE, spanToJSON, type SpanContextData } from '@sentry/core';\nimport { WINDOW } from '../exports';\nimport { DEBUG_BUILD } from '../debug-build';\n\nexport interface PreviousTraceInfo {\n  /**\n   * Span context of the previous trace's local root span\n   */\n  spanContext: SpanContextData;\n\n  /**\n   * Timestamp in seconds when the previous trace was started\n   */\n  startTimestamp: number;\n}\n\n// 1h in seconds\nexport const PREVIOUS_TRACE_MAX_DURATION = 3600;\n\n// session storage key\nexport const PREVIOUS_TRACE_KEY = 'sentry_previous_trace';\n\nexport const PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE = 'sentry.previous_trace';\n\n/**\n * Adds a previous_trace span link to the passed span if the passed\n * previousTraceInfo is still valid.\n *\n * @returns the updated previous trace info (based on the current span/trace) to\n * be used on the next call\n */\nexport function addPreviousTraceSpanLink(\n  previousTraceInfo: PreviousTraceInfo | undefined,\n  span: Span,\n): PreviousTraceInfo {\n  const spanJson = spanToJSON(span);\n\n  if (!previousTraceInfo) {\n    return {\n      spanContext: span.spanContext(),\n      startTimestamp: spanJson.start_timestamp,\n    };\n  }\n\n  const previousTraceSpanCtx = previousTraceInfo.spanContext;\n  if (previousTraceSpanCtx.traceId === spanJson.trace_id) {\n    // This means, we're still in the same trace so let's not update the previous trace info\n    // or add a link to the current span.\n    // Once we move away from the long-lived, route-based trace model, we can remove this cases\n    return previousTraceInfo;\n  }\n\n  // Only add the link if the startTimeStamp of the previous trace's root span is within\n  // PREVIOUS_TRACE_MAX_DURATION (1h) of the current root span's startTimestamp\n  // This is done to\n  // - avoid adding links to \"stale\" traces\n  // - enable more efficient querying for previous/next traces in Sentry\n  if (Date.now() / 1000 - previousTraceInfo.startTimestamp <= PREVIOUS_TRACE_MAX_DURATION) {\n    if (DEBUG_BUILD) {\n      logger.info(\n        `Adding previous_trace ${previousTraceSpanCtx} link to span ${{\n          op: spanJson.op,\n          ...span.spanContext(),\n        }}`,\n      );\n    }\n\n    span.addLink({\n      context: previousTraceSpanCtx,\n      attributes: {\n        [SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE]: 'previous_trace',\n      },\n    });\n\n    // TODO: Remove this once EAP can store span links. We currently only set this attribute so that we\n    // can obtain the previous trace information from the EAP store. Long-term, EAP will handle\n    // span links and then we should remove this again. Also throwing in a TODO(v10), to remind us\n    // to check this at v10 time :)\n    span.setAttribute(\n      PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE,\n      `${previousTraceSpanCtx.traceId}-${previousTraceSpanCtx.spanId}-${\n        previousTraceSpanCtx.traceFlags === 0x1 ? 1 : 0\n      }`,\n    );\n  }\n\n  return {\n    spanContext: span.spanContext(),\n    startTimestamp: spanToJSON(span).start_timestamp,\n  };\n}\n\n/**\n * Stores @param previousTraceInfo in sessionStorage.\n */\nexport function storePreviousTraceInSessionStorage(previousTraceInfo: PreviousTraceInfo): void {\n  try {\n    WINDOW.sessionStorage.setItem(PREVIOUS_TRACE_KEY, JSON.stringify(previousTraceInfo));\n  } catch (e) {\n    // Ignore potential errors (e.g. if sessionStorage is not available)\n    DEBUG_BUILD && logger.warn('Could not store previous trace in sessionStorage', e);\n  }\n}\n\n/**\n * Retrieves the previous trace from sessionStorage if available.\n */\nexport function getPreviousTraceFromSessionStorage(): PreviousTraceInfo | undefined {\n  try {\n    const previousTraceInfo = WINDOW.sessionStorage?.getItem(PREVIOUS_TRACE_KEY);\n    // @ts-expect-error - intentionally risking JSON.parse throwing when previousTraceInfo is null to save bundle size\n    return JSON.parse(previousTraceInfo);\n  } catch (e) {\n    return undefined;\n  }\n}\n"],"mappings":";;;;;;;;;;;;AAiBA;AACO,MAAMA,2BAA4B,GAAE;;AAE3C;AACO,MAAMC,kBAAmB,GAAE;AAE3B,MAAMC,iCAAkC,GAAE;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,wBAAwBA,CACtCC,iBAAiB,EACjBC,IAAI,EACe;EACnB,MAAMC,QAAS,GAAEC,UAAU,CAACF,IAAI,CAAC;EAEjC,IAAI,CAACD,iBAAiB,EAAE;IACtB,OAAO;MACLI,WAAW,EAAEH,IAAI,CAACG,WAAW,EAAE;MAC/BC,cAAc,EAAEH,QAAQ,CAACI;IAC/B,CAAK;EACL;EAEE,MAAMC,oBAAA,GAAuBP,iBAAiB,CAACI,WAAW;EAC1D,IAAIG,oBAAoB,CAACC,OAAA,KAAYN,QAAQ,CAACO,QAAQ,EAAE;IAC1D;IACA;IACA;IACI,OAAOT,iBAAiB;EAC5B;;EAEA;EACA;EACA;EACA;EACA;EACE,IAAIU,IAAI,CAACC,GAAG,EAAC,GAAI,OAAOX,iBAAiB,CAACK,cAAe,IAAGT,2BAA2B,EAAE;IACvF,IAAIgB,WAAW,EAAE;MACfC,MAAM,CAACC,IAAI,CACT,yBAAyBP,oBAAoB,iBAAiB;QAC5DQ,EAAE,EAAEb,QAAQ,CAACa,EAAE;QACf,GAAGd,IAAI,CAACG,WAAW;MAC7B,CAAS,EACC;IACA;IAEAH,IAAA,CAAAe,OAAA;MACAC,OAAA,EAAAV,oBAAA;MACAW,UAAA;QACA,CAAAC,iCAAA;MACA;IACA;;IAEA;IACA;IACA;IACA;IACAlB,IAAA,CAAAmB,YAAA,CACAtB,iCAAA,EACA,GAAAS,oBAAA,CAAAC,OAAA,IAAAD,oBAAA,CAAAc,MAAA,IACAd,oBAAA,CAAAe,UAAA,kBAEA;EACA;EAEA;IACAlB,WAAA,EAAAH,IAAA,CAAAG,WAAA;IACAC,cAAA,EAAAF,UAAA,CAAAF,IAAA,EAAAK;EACA;AACA;;AAEA;AACA;AACA;AACA,SAAAiB,mCAAAvB,iBAAA;EACA;IACAwB,MAAA,CAAAC,cAAA,CAAAC,OAAA,CAAA7B,kBAAA,EAAA8B,IAAA,CAAAC,SAAA,CAAA5B,iBAAA;EACA,SAAA6B,CAAA;IACA;IACAjB,WAAA,IAAAC,MAAA,CAAAiB,IAAA,qDAAAD,CAAA;EACA;AACA;;AAEA;AACA;AACA;AACA,SAAAE,mCAAA;EACA;IACA,MAAA/B,iBAAA,GAAAwB,MAAA,CAAAC,cAAA,EAAAO,OAAA,CAAAnC,kBAAA;IACA;IACA,OAAA8B,IAAA,CAAAM,KAAA,CAAAjC,iBAAA;EACA,SAAA6B,CAAA;IACA,OAAAK,SAAA;EACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}