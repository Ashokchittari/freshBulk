{"ast":null,"code":"import { DEBUG_BUILD } from './debug-build.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP } from './semanticAttributes.js';\nimport './tracing/errors.js';\nimport './utils-hoist/debug-build.js';\nimport { logger } from './utils-hoist/logger.js';\nimport './utils-hoist/time.js';\nimport './utils-hoist/syncpromise.js';\nimport { startSpan } from './tracing/trace.js';\nconst wrappedMcpServerInstances = new WeakSet();\n\n/**\n * Wraps a MCP Server instance from the `@modelcontextprotocol/sdk` package with Sentry instrumentation.\n *\n * Compatible with versions `^1.9.0` of the `@modelcontextprotocol/sdk` package.\n */\n// We are exposing this API for non-node runtimes that cannot rely on auto-instrumentation.\nfunction wrapMcpServerWithSentry(mcpServerInstance) {\n  if (wrappedMcpServerInstances.has(mcpServerInstance)) {\n    return mcpServerInstance;\n  }\n  if (!isMcpServerInstance(mcpServerInstance)) {\n    DEBUG_BUILD && logger.warn('Did not patch MCP server. Interface is incompatible.');\n    return mcpServerInstance;\n  }\n  mcpServerInstance.resource = new Proxy(mcpServerInstance.resource, {\n    apply(target, thisArg, argArray) {\n      const resourceName = argArray[0];\n      const resourceHandler = argArray[argArray.length - 1];\n      if (typeof resourceName !== 'string' || typeof resourceHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n      return startSpan({\n        name: `mcp-server/resource:${resourceName}`,\n        forceTransaction: true,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n          'mcp_server.resource': resourceName\n        }\n      }, () => target.apply(thisArg, argArray));\n    }\n  });\n  mcpServerInstance.tool = new Proxy(mcpServerInstance.tool, {\n    apply(target, thisArg, argArray) {\n      const toolName = argArray[0];\n      const toolHandler = argArray[argArray.length - 1];\n      if (typeof toolName !== 'string' || typeof toolHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n      return startSpan({\n        name: `mcp-server/tool:${toolName}`,\n        forceTransaction: true,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n          'mcp_server.tool': toolName\n        }\n      }, () => target.apply(thisArg, argArray));\n    }\n  });\n  mcpServerInstance.prompt = new Proxy(mcpServerInstance.prompt, {\n    apply(target, thisArg, argArray) {\n      const promptName = argArray[0];\n      const promptHandler = argArray[argArray.length - 1];\n      if (typeof promptName !== 'string' || typeof promptHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n      return startSpan({\n        name: `mcp-server/resource:${promptName}`,\n        forceTransaction: true,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n          'mcp_server.prompt': promptName\n        }\n      }, () => target.apply(thisArg, argArray));\n    }\n  });\n  wrappedMcpServerInstances.add(mcpServerInstance);\n  return mcpServerInstance;\n}\nfunction isMcpServerInstance(mcpServerInstance) {\n  return typeof mcpServerInstance === 'object' && mcpServerInstance !== null && 'resource' in mcpServerInstance && typeof mcpServerInstance.resource === 'function' && 'tool' in mcpServerInstance && typeof mcpServerInstance.tool === 'function' && 'prompt' in mcpServerInstance && typeof mcpServerInstance.prompt === 'function';\n}\nexport { wrapMcpServerWithSentry };","map":{"version":3,"names":["wrappedMcpServerInstances","WeakSet","wrapMcpServerWithSentry","mcpServerInstance","has","isMcpServerInstance","DEBUG_BUILD","logger","warn","resource","Proxy","apply","target","thisArg","argArray","resourceName","resourceHandler","length","startSpan","name","forceTransaction","attributes","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","tool","toolName","toolHandler","prompt","promptName","promptHandler","add"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry\\core\\src\\mcp-server.ts"],"sourcesContent":["import { DEBUG_BUILD } from './debug-build';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n} from './semanticAttributes';\nimport { startSpan } from './tracing';\nimport { logger } from './utils-hoist';\n\ninterface MCPServerInstance {\n  // The first arg is always a name, the last arg should always be a callback function (ie a handler).\n  // TODO: We could also make use of the resource uri argument somehow.\n  resource: (name: string, ...args: unknown[]) => void;\n  // The first arg is always a name, the last arg should always be a callback function (ie a handler).\n  tool: (name: string, ...args: unknown[]) => void;\n  // The first arg is always a name, the last arg should always be a callback function (ie a handler).\n  prompt: (name: string, ...args: unknown[]) => void;\n}\n\nconst wrappedMcpServerInstances = new WeakSet();\n\n/**\n * Wraps a MCP Server instance from the `@modelcontextprotocol/sdk` package with Sentry instrumentation.\n *\n * Compatible with versions `^1.9.0` of the `@modelcontextprotocol/sdk` package.\n */\n// We are exposing this API for non-node runtimes that cannot rely on auto-instrumentation.\nexport function wrapMcpServerWithSentry<S extends object>(mcpServerInstance: S): S {\n  if (wrappedMcpServerInstances.has(mcpServerInstance)) {\n    return mcpServerInstance;\n  }\n\n  if (!isMcpServerInstance(mcpServerInstance)) {\n    DEBUG_BUILD && logger.warn('Did not patch MCP server. Interface is incompatible.');\n    return mcpServerInstance;\n  }\n\n  mcpServerInstance.resource = new Proxy(mcpServerInstance.resource, {\n    apply(target, thisArg, argArray) {\n      const resourceName: unknown = argArray[0];\n      const resourceHandler: unknown = argArray[argArray.length - 1];\n\n      if (typeof resourceName !== 'string' || typeof resourceHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n\n      return startSpan(\n        {\n          name: `mcp-server/resource:${resourceName}`,\n          forceTransaction: true,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n            'mcp_server.resource': resourceName,\n          },\n        },\n        () => target.apply(thisArg, argArray),\n      );\n    },\n  });\n\n  mcpServerInstance.tool = new Proxy(mcpServerInstance.tool, {\n    apply(target, thisArg, argArray) {\n      const toolName: unknown = argArray[0];\n      const toolHandler: unknown = argArray[argArray.length - 1];\n\n      if (typeof toolName !== 'string' || typeof toolHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n\n      return startSpan(\n        {\n          name: `mcp-server/tool:${toolName}`,\n          forceTransaction: true,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n            'mcp_server.tool': toolName,\n          },\n        },\n        () => target.apply(thisArg, argArray),\n      );\n    },\n  });\n\n  mcpServerInstance.prompt = new Proxy(mcpServerInstance.prompt, {\n    apply(target, thisArg, argArray) {\n      const promptName: unknown = argArray[0];\n      const promptHandler: unknown = argArray[argArray.length - 1];\n\n      if (typeof promptName !== 'string' || typeof promptHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n\n      return startSpan(\n        {\n          name: `mcp-server/resource:${promptName}`,\n          forceTransaction: true,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n            'mcp_server.prompt': promptName,\n          },\n        },\n        () => target.apply(thisArg, argArray),\n      );\n    },\n  });\n\n  wrappedMcpServerInstances.add(mcpServerInstance);\n\n  return mcpServerInstance as S;\n}\n\nfunction isMcpServerInstance(mcpServerInstance: unknown): mcpServerInstance is MCPServerInstance {\n  return (\n    typeof mcpServerInstance === 'object' &&\n    mcpServerInstance !== null &&\n    'resource' in mcpServerInstance &&\n    typeof mcpServerInstance.resource === 'function' &&\n    'tool' in mcpServerInstance &&\n    typeof mcpServerInstance.tool === 'function' &&\n    'prompt' in mcpServerInstance &&\n    typeof mcpServerInstance.prompt === 'function'\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}