{"ast":null,"code":"import { getClient } from './currentScopes.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from './semanticAttributes.js';\nimport './tracing/errors.js';\nimport { isRequest, isInstanceOf } from './utils-hoist/is.js';\nimport './utils-hoist/debug-build.js';\nimport './utils-hoist/logger.js';\nimport './debug-build.js';\nimport './utils-hoist/time.js';\nimport { hasSpansEnabled } from './utils/hasSpansEnabled.js';\nimport { getActiveSpan } from './utils/spanUtils.js';\nimport { SENTRY_BAGGAGE_KEY_PREFIX } from './utils-hoist/baggage.js';\nimport { SentryNonRecordingSpan } from './tracing/sentryNonRecordingSpan.js';\nimport { setHttpStatus, SPAN_STATUS_ERROR } from './tracing/spanstatus.js';\nimport { startInactiveSpan } from './tracing/trace.js';\nimport { parseStringToURLObject, getSanitizedUrlStringFromUrlObject, isURLObjectRelative } from './utils-hoist/url.js';\nimport { getTraceData } from './utils/traceData.js';\n\n/**\n * Create and track fetch request spans for usage in combination with `addFetchInstrumentationHandler`.\n *\n * @returns Span if a span was created, otherwise void.\n */\nfunction instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeaders, spans, spanOrigin = 'auto.http.browser') {\n  if (!handlerData.fetchData) {\n    return undefined;\n  }\n  const {\n    method,\n    url\n  } = handlerData.fetchData;\n  const shouldCreateSpanResult = hasSpansEnabled() && shouldCreateSpan(url);\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n    const span = spans[spanId];\n    if (span) {\n      endSpan(span, handlerData);\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n  const hasParent = !!getActiveSpan();\n  const span = shouldCreateSpanResult && hasParent ? startInactiveSpan(getSpanStartOptions(url, method, spanOrigin)) : new SentryNonRecordingSpan();\n  handlerData.fetchData.__span = span.spanContext().spanId;\n  spans[span.spanContext().spanId] = span;\n  if (shouldAttachHeaders(handlerData.fetchData.url)) {\n    const request = handlerData.args[0];\n    const options = handlerData.args[1] || {};\n    const headers = _addTracingHeadersToFetchRequest(request, options,\n    // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n    // we do not want to use the span as base for the trace headers,\n    // which means that the headers will be generated from the scope and the sampling decision is deferred\n    hasSpansEnabled() && hasParent ? span : undefined);\n    if (headers) {\n      // Ensure this is actually set, if no options have been passed previously\n      handlerData.args[1] = options;\n      options.headers = headers;\n    }\n  }\n  const client = getClient();\n  if (client) {\n    const fetchHint = {\n      input: handlerData.args,\n      response: handlerData.response,\n      startTimestamp: handlerData.startTimestamp,\n      endTimestamp: handlerData.endTimestamp\n    };\n    client.emit('beforeOutgoingRequestSpan', span, fetchHint);\n  }\n  return span;\n}\n\n/**\n * Adds sentry-trace and baggage headers to the various forms of fetch headers.\n */\nfunction _addTracingHeadersToFetchRequest(request, fetchOptionsObj, span) {\n  const traceHeaders = getTraceData({\n    span\n  });\n  const sentryTrace = traceHeaders['sentry-trace'];\n  const baggage = traceHeaders.baggage;\n\n  // Nothing to do, when we return undefined here, the original headers will be used\n  if (!sentryTrace) {\n    return undefined;\n  }\n  const headers = fetchOptionsObj.headers || (isRequest(request) ? request.headers : undefined);\n  if (!headers) {\n    return {\n      ...traceHeaders\n    };\n  } else if (isHeaders(headers)) {\n    const newHeaders = new Headers(headers);\n    newHeaders.set('sentry-trace', sentryTrace);\n    if (baggage) {\n      const prevBaggageHeader = newHeaders.get('baggage');\n      if (prevBaggageHeader) {\n        const prevHeaderStrippedFromSentryBaggage = stripBaggageHeaderOfSentryBaggageValues(prevBaggageHeader);\n        newHeaders.set('baggage',\n        // If there are non-sentry entries (i.e. if the stripped string is non-empty/truthy) combine the stripped header and sentry baggage header\n        // otherwise just set the sentry baggage header\n        prevHeaderStrippedFromSentryBaggage ? `${prevHeaderStrippedFromSentryBaggage},${baggage}` : baggage);\n      } else {\n        newHeaders.set('baggage', baggage);\n      }\n    }\n    return newHeaders;\n  } else if (Array.isArray(headers)) {\n    const newHeaders = [...headers\n    // Remove any existing sentry-trace headers\n    .filter(header => {\n      return !(Array.isArray(header) && header[0] === 'sentry-trace');\n    })\n    // Get rid of previous sentry baggage values in baggage header\n    .map(header => {\n      if (Array.isArray(header) && header[0] === 'baggage' && typeof header[1] === 'string') {\n        const [headerName, headerValue, ...rest] = header;\n        return [headerName, stripBaggageHeaderOfSentryBaggageValues(headerValue), ...rest];\n      } else {\n        return header;\n      }\n    }),\n    // Attach the new sentry-trace header\n    ['sentry-trace', sentryTrace]];\n    if (baggage) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push(['baggage', baggage]);\n    }\n    return newHeaders;\n  } else {\n    const existingBaggageHeader = 'baggage' in headers ? headers.baggage : undefined;\n    let newBaggageHeaders = [];\n    if (Array.isArray(existingBaggageHeader)) {\n      newBaggageHeaders = existingBaggageHeader.map(headerItem => typeof headerItem === 'string' ? stripBaggageHeaderOfSentryBaggageValues(headerItem) : headerItem).filter(headerItem => headerItem === '');\n    } else if (existingBaggageHeader) {\n      newBaggageHeaders.push(stripBaggageHeaderOfSentryBaggageValues(existingBaggageHeader));\n    }\n    if (baggage) {\n      newBaggageHeaders.push(baggage);\n    }\n    return {\n      ...headers,\n      'sentry-trace': sentryTrace,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined\n    };\n  }\n}\nfunction endSpan(span, handlerData) {\n  if (handlerData.response) {\n    setHttpStatus(span, handlerData.response.status);\n    const contentLength = handlerData.response?.headers && handlerData.response.headers.get('content-length');\n    if (contentLength) {\n      const contentLengthNum = parseInt(contentLength);\n      if (contentLengthNum > 0) {\n        span.setAttribute('http.response_content_length', contentLengthNum);\n      }\n    }\n  } else if (handlerData.error) {\n    span.setStatus({\n      code: SPAN_STATUS_ERROR,\n      message: 'internal_error'\n    });\n  }\n  span.end();\n}\nfunction stripBaggageHeaderOfSentryBaggageValues(baggageHeader) {\n  return baggageHeader.split(',')\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  .filter(baggageEntry => !baggageEntry.split('=')[0].startsWith(SENTRY_BAGGAGE_KEY_PREFIX)).join(',');\n}\nfunction isHeaders(headers) {\n  return typeof Headers !== 'undefined' && isInstanceOf(headers, Headers);\n}\nfunction getSpanStartOptions(url, method, spanOrigin) {\n  const parsedUrl = parseStringToURLObject(url);\n  return {\n    name: parsedUrl ? `${method} ${getSanitizedUrlStringFromUrlObject(parsedUrl)}` : method,\n    attributes: getFetchSpanAttributes(url, parsedUrl, method, spanOrigin)\n  };\n}\nfunction getFetchSpanAttributes(url, parsedUrl, method, spanOrigin) {\n  const attributes = {\n    url,\n    type: 'fetch',\n    'http.method': method,\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin,\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client'\n  };\n  if (parsedUrl) {\n    if (!isURLObjectRelative(parsedUrl)) {\n      attributes['http.url'] = parsedUrl.href;\n      attributes['server.address'] = parsedUrl.host;\n    }\n    if (parsedUrl.search) {\n      attributes['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      attributes['http.fragment'] = parsedUrl.hash;\n    }\n  }\n  return attributes;\n}\nexport { instrumentFetchRequest };","map":{"version":3,"names":["instrumentFetchRequest","handlerData","shouldCreateSpan","shouldAttachHeaders","spans","spanOrigin","fetchData","undefined","method","url","shouldCreateSpanResult","hasSpansEnabled","endTimestamp","spanId","__span","span","endSpan","hasParent","getActiveSpan","startInactiveSpan","getSpanStartOptions","SentryNonRecordingSpan","spanContext","request","args","options","headers","_addTracingHeadersToFetchRequest","client","getClient","fetchHint","input","response","startTimestamp","emit","fetchOptionsObj","traceHeaders","getTraceData","sentryTrace","baggage","isRequest","isHeaders","newHeaders","Headers","set","prevBaggageHeader","get","prevHeaderStrippedFromSentryBaggage","stripBaggageHeaderOfSentryBaggageValues","Array","isArray","filter","header","map","headerName","headerValue","rest","push","existingBaggageHeader","newBaggageHeaders","headerItem","length","join","setHttpStatus","status","contentLength","contentLengthNum","parseInt","setAttribute","error","setStatus","code","SPAN_STATUS_ERROR","message","end","baggageHeader","split","baggageEntry","startsWith","SENTRY_BAGGAGE_KEY_PREFIX","isInstanceOf","parsedUrl","parseStringToURLObject","name","getSanitizedUrlStringFromUrlObject","attributes","getFetchSpanAttributes","type","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","isURLObjectRelative","href","host","search","hash"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry\\core\\src\\fetch.ts"],"sourcesContent":["import { getClient } from './currentScopes';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from './semanticAttributes';\nimport { SPAN_STATUS_ERROR, setHttpStatus, startInactiveSpan } from './tracing';\nimport { SentryNonRecordingSpan } from './tracing/sentryNonRecordingSpan';\nimport type { FetchBreadcrumbHint, HandlerDataFetch, Span, SpanAttributes, SpanOrigin } from './types-hoist';\nimport { SENTRY_BAGGAGE_KEY_PREFIX } from './utils-hoist/baggage';\nimport { isInstanceOf, isRequest } from './utils-hoist/is';\nimport { getSanitizedUrlStringFromUrlObject, isURLObjectRelative, parseStringToURLObject } from './utils-hoist/url';\nimport { hasSpansEnabled } from './utils/hasSpansEnabled';\nimport { getActiveSpan } from './utils/spanUtils';\nimport { getTraceData } from './utils/traceData';\n\ntype PolymorphicRequestHeaders =\n  | Record<string, string | undefined>\n  | Array<[string, string]>\n  // the below is not precisely the Header type used in Request, but it'll pass duck-typing\n  | {\n      append: (key: string, value: string) => void;\n      get: (key: string) => string | null | undefined;\n    };\n\n/**\n * Create and track fetch request spans for usage in combination with `addFetchInstrumentationHandler`.\n *\n * @returns Span if a span was created, otherwise void.\n */\nexport function instrumentFetchRequest(\n  handlerData: HandlerDataFetch,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n  spanOrigin: SpanOrigin = 'auto.http.browser',\n): Span | undefined {\n  if (!handlerData.fetchData) {\n    return undefined;\n  }\n\n  const { method, url } = handlerData.fetchData;\n\n  const shouldCreateSpanResult = hasSpansEnabled() && shouldCreateSpan(url);\n\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      endSpan(span, handlerData);\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n\n  const hasParent = !!getActiveSpan();\n\n  const span =\n    shouldCreateSpanResult && hasParent\n      ? startInactiveSpan(getSpanStartOptions(url, method, spanOrigin))\n      : new SentryNonRecordingSpan();\n\n  handlerData.fetchData.__span = span.spanContext().spanId;\n  spans[span.spanContext().spanId] = span;\n\n  if (shouldAttachHeaders(handlerData.fetchData.url)) {\n    const request: string | Request = handlerData.args[0];\n\n    const options: { [key: string]: unknown } = handlerData.args[1] || {};\n\n    const headers = _addTracingHeadersToFetchRequest(\n      request,\n      options,\n      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n      // we do not want to use the span as base for the trace headers,\n      // which means that the headers will be generated from the scope and the sampling decision is deferred\n      hasSpansEnabled() && hasParent ? span : undefined,\n    );\n    if (headers) {\n      // Ensure this is actually set, if no options have been passed previously\n      handlerData.args[1] = options;\n      options.headers = headers;\n    }\n  }\n\n  const client = getClient();\n\n  if (client) {\n    const fetchHint = {\n      input: handlerData.args,\n      response: handlerData.response,\n      startTimestamp: handlerData.startTimestamp,\n      endTimestamp: handlerData.endTimestamp,\n    } satisfies FetchBreadcrumbHint;\n\n    client.emit('beforeOutgoingRequestSpan', span, fetchHint);\n  }\n\n  return span;\n}\n\n/**\n * Adds sentry-trace and baggage headers to the various forms of fetch headers.\n */\nfunction _addTracingHeadersToFetchRequest(\n  request: string | Request,\n  fetchOptionsObj: {\n    headers?:\n      | {\n          [key: string]: string[] | string | undefined;\n        }\n      | PolymorphicRequestHeaders;\n  },\n  span?: Span,\n): PolymorphicRequestHeaders | undefined {\n  const traceHeaders = getTraceData({ span });\n  const sentryTrace = traceHeaders['sentry-trace'];\n  const baggage = traceHeaders.baggage;\n\n  // Nothing to do, when we return undefined here, the original headers will be used\n  if (!sentryTrace) {\n    return undefined;\n  }\n\n  const headers = fetchOptionsObj.headers || (isRequest(request) ? request.headers : undefined);\n\n  if (!headers) {\n    return { ...traceHeaders };\n  } else if (isHeaders(headers)) {\n    const newHeaders = new Headers(headers);\n    newHeaders.set('sentry-trace', sentryTrace);\n\n    if (baggage) {\n      const prevBaggageHeader = newHeaders.get('baggage');\n      if (prevBaggageHeader) {\n        const prevHeaderStrippedFromSentryBaggage = stripBaggageHeaderOfSentryBaggageValues(prevBaggageHeader);\n        newHeaders.set(\n          'baggage',\n          // If there are non-sentry entries (i.e. if the stripped string is non-empty/truthy) combine the stripped header and sentry baggage header\n          // otherwise just set the sentry baggage header\n          prevHeaderStrippedFromSentryBaggage ? `${prevHeaderStrippedFromSentryBaggage},${baggage}` : baggage,\n        );\n      } else {\n        newHeaders.set('baggage', baggage);\n      }\n    }\n\n    return newHeaders;\n  } else if (Array.isArray(headers)) {\n    const newHeaders = [\n      ...headers\n        // Remove any existing sentry-trace headers\n        .filter(header => {\n          return !(Array.isArray(header) && header[0] === 'sentry-trace');\n        })\n        // Get rid of previous sentry baggage values in baggage header\n        .map(header => {\n          if (Array.isArray(header) && header[0] === 'baggage' && typeof header[1] === 'string') {\n            const [headerName, headerValue, ...rest] = header;\n            return [headerName, stripBaggageHeaderOfSentryBaggageValues(headerValue), ...rest];\n          } else {\n            return header;\n          }\n        }),\n      // Attach the new sentry-trace header\n      ['sentry-trace', sentryTrace],\n    ];\n\n    if (baggage) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push(['baggage', baggage]);\n    }\n\n    return newHeaders as PolymorphicRequestHeaders;\n  } else {\n    const existingBaggageHeader = 'baggage' in headers ? headers.baggage : undefined;\n    let newBaggageHeaders: string[] = [];\n\n    if (Array.isArray(existingBaggageHeader)) {\n      newBaggageHeaders = existingBaggageHeader\n        .map(headerItem =>\n          typeof headerItem === 'string' ? stripBaggageHeaderOfSentryBaggageValues(headerItem) : headerItem,\n        )\n        .filter(headerItem => headerItem === '');\n    } else if (existingBaggageHeader) {\n      newBaggageHeaders.push(stripBaggageHeaderOfSentryBaggageValues(existingBaggageHeader));\n    }\n\n    if (baggage) {\n      newBaggageHeaders.push(baggage);\n    }\n\n    return {\n      ...(headers as Exclude<typeof headers, Headers>),\n      'sentry-trace': sentryTrace,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined,\n    };\n  }\n}\n\nfunction endSpan(span: Span, handlerData: HandlerDataFetch): void {\n  if (handlerData.response) {\n    setHttpStatus(span, handlerData.response.status);\n\n    const contentLength = handlerData.response?.headers && handlerData.response.headers.get('content-length');\n\n    if (contentLength) {\n      const contentLengthNum = parseInt(contentLength);\n      if (contentLengthNum > 0) {\n        span.setAttribute('http.response_content_length', contentLengthNum);\n      }\n    }\n  } else if (handlerData.error) {\n    span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n  }\n  span.end();\n}\n\nfunction stripBaggageHeaderOfSentryBaggageValues(baggageHeader: string): string {\n  return (\n    baggageHeader\n      .split(',')\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      .filter(baggageEntry => !baggageEntry.split('=')[0]!.startsWith(SENTRY_BAGGAGE_KEY_PREFIX))\n      .join(',')\n  );\n}\n\nfunction isHeaders(headers: unknown): headers is Headers {\n  return typeof Headers !== 'undefined' && isInstanceOf(headers, Headers);\n}\n\nfunction getSpanStartOptions(\n  url: string,\n  method: string,\n  spanOrigin: SpanOrigin,\n): Parameters<typeof startInactiveSpan>[0] {\n  const parsedUrl = parseStringToURLObject(url);\n  return {\n    name: parsedUrl ? `${method} ${getSanitizedUrlStringFromUrlObject(parsedUrl)}` : method,\n    attributes: getFetchSpanAttributes(url, parsedUrl, method, spanOrigin),\n  };\n}\n\nfunction getFetchSpanAttributes(\n  url: string,\n  parsedUrl: ReturnType<typeof parseStringToURLObject>,\n  method: string,\n  spanOrigin: SpanOrigin,\n): SpanAttributes {\n  const attributes: SpanAttributes = {\n    url,\n    type: 'fetch',\n    'http.method': method,\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin,\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',\n  };\n  if (parsedUrl) {\n    if (!isURLObjectRelative(parsedUrl)) {\n      attributes['http.url'] = parsedUrl.href;\n      attributes['server.address'] = parsedUrl.host;\n    }\n    if (parsedUrl.search) {\n      attributes['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      attributes['http.fragment'] = parsedUrl.hash;\n    }\n  }\n  return attributes;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}