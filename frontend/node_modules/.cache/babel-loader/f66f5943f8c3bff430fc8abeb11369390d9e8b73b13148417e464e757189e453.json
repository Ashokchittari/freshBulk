{"ast":null,"code":"import { addXhrInstrumentationHandler, addPerformanceInstrumentationHandler, SENTRY_XHR_DATA_KEY, extractNetworkProtocol } from '@sentry-internal/browser-utils';\nimport { addFetchEndInstrumentationHandler, addFetchInstrumentationHandler, instrumentFetchRequest, parseUrl, getLocationHref, stringMatchesSomePattern, spanToJSON, hasSpansEnabled, setHttpStatus, stripUrlQueryAndFragment, getActiveSpan, startInactiveSpan, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SentryNonRecordingSpan, getClient, browserPerformanceTimeOrigin, getTraceData } from '@sentry/core';\nimport { WINDOW } from '../helpers.js';\n\n/** Options for Request Instrumentation */\n\nconst responseToSpanId = new WeakMap();\nconst spanIdToEndTimestamp = new Map();\nconst defaultRequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  enableHTTPTimings: true,\n  trackFetchStreamPerformance: false\n};\n\n/** Registers span creators for xhr and fetch requests  */\nfunction instrumentOutgoingRequests(client, _options) {\n  const {\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    tracePropagationTargets,\n    onRequestSpanStart\n  } = {\n    ...defaultRequestInstrumentationOptions,\n    ..._options\n  };\n  const shouldCreateSpan = typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : _ => true;\n  const shouldAttachHeadersWithTargets = url => shouldAttachHeaders(url, tracePropagationTargets);\n  const spans = {};\n  if (traceFetch) {\n    // Keeping track of http requests, whose body payloads resolved later than the initial resolved request\n    // e.g. streaming using server sent events (SSE)\n    client.addEventProcessor(event => {\n      if (event.type === 'transaction' && event.spans) {\n        event.spans.forEach(span => {\n          if (span.op === 'http.client') {\n            const updatedTimestamp = spanIdToEndTimestamp.get(span.span_id);\n            if (updatedTimestamp) {\n              span.timestamp = updatedTimestamp / 1000;\n              spanIdToEndTimestamp.delete(span.span_id);\n            }\n          }\n        });\n      }\n      return event;\n    });\n    if (trackFetchStreamPerformance) {\n      addFetchEndInstrumentationHandler(handlerData => {\n        if (handlerData.response) {\n          const span = responseToSpanId.get(handlerData.response);\n          if (span && handlerData.endTimestamp) {\n            spanIdToEndTimestamp.set(span, handlerData.endTimestamp);\n          }\n        }\n      });\n    }\n    addFetchInstrumentationHandler(handlerData => {\n      const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (handlerData.response && handlerData.fetchData.__span) {\n        responseToSpanId.set(handlerData.response, handlerData.fetchData.__span);\n      }\n\n      // We cannot use `window.location` in the generic fetch instrumentation,\n      // but we need it for reliable `server.address` attribute.\n      // so we extend this in here\n      if (createdSpan) {\n        const fullUrl = getFullURL(handlerData.fetchData.url);\n        const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n        createdSpan.setAttributes({\n          'http.url': fullUrl,\n          'server.address': host\n        });\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n        onRequestSpanStart?.(createdSpan, {\n          headers: handlerData.headers\n        });\n      }\n    });\n  }\n  if (traceXHR) {\n    addXhrInstrumentationHandler(handlerData => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (createdSpan) {\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n        let headers;\n        try {\n          headers = new Headers(handlerData.xhr.__sentry_xhr_v3__?.request_headers);\n        } catch {\n          // noop\n        }\n        onRequestSpanStart?.(createdSpan, {\n          headers\n        });\n      }\n    });\n  }\n}\nfunction isPerformanceResourceTiming(entry) {\n  return entry.entryType === 'resource' && 'initiatorType' in entry && typeof entry.nextHopProtocol === 'string' && (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest');\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span) {\n  const {\n    url\n  } = spanToJSON(span).data;\n  if (!url || typeof url !== 'string') {\n    return;\n  }\n  const cleanup = addPerformanceInstrumentationHandler('resource', ({\n    entries\n  }) => {\n    entries.forEach(entry => {\n      if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n        const spanData = resourceTimingEntryToSpanData(entry);\n        spanData.forEach(data => span.setAttribute(...data));\n        // In the next tick, clean this handler up\n        // We have to wait here because otherwise this cleans itself up before it is fully done\n        setTimeout(cleanup);\n      }\n    });\n  });\n}\nfunction getAbsoluteTime(time = 0) {\n  return ((browserPerformanceTimeOrigin() || performance.timeOrigin) + time) / 1000;\n}\nfunction resourceTimingEntryToSpanData(resourceTiming) {\n  const {\n    name,\n    version\n  } = extractNetworkProtocol(resourceTiming.nextHopProtocol);\n  const timingSpanData = [];\n  timingSpanData.push(['network.protocol.version', version], ['network.protocol.name', name]);\n  if (!browserPerformanceTimeOrigin()) {\n    return timingSpanData;\n  }\n  return [...timingSpanData, ['http.request.redirect_start', getAbsoluteTime(resourceTiming.redirectStart)], ['http.request.fetch_start', getAbsoluteTime(resourceTiming.fetchStart)], ['http.request.domain_lookup_start', getAbsoluteTime(resourceTiming.domainLookupStart)], ['http.request.domain_lookup_end', getAbsoluteTime(resourceTiming.domainLookupEnd)], ['http.request.connect_start', getAbsoluteTime(resourceTiming.connectStart)], ['http.request.secure_connection_start', getAbsoluteTime(resourceTiming.secureConnectionStart)], ['http.request.connection_end', getAbsoluteTime(resourceTiming.connectEnd)], ['http.request.request_start', getAbsoluteTime(resourceTiming.requestStart)], ['http.request.response_start', getAbsoluteTime(resourceTiming.responseStart)], ['http.request.response_end', getAbsoluteTime(resourceTiming.responseEnd)]];\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * We only export this function for testing purposes.\n */\nfunction shouldAttachHeaders(targetUrl, tracePropagationTargets) {\n  // window.location.href not being defined is an edge case in the browser but we need to handle it.\n  // Potentially dangerous situations where it may not be defined: Browser Extensions, Web Workers, patching of the location obj\n  const href = getLocationHref();\n  if (!href) {\n    // If there is no window.location.origin, we default to only attaching tracing headers to relative requests, i.e. ones that start with `/`\n    // BIG DISCLAIMER: Users can call URLs with a double slash (fetch(\"//example.com/api\")), this is a shorthand for \"send to the same protocol\",\n    // so we need a to exclude those requests, because they might be cross origin.\n    const isRelativeSameOriginRequest = !!targetUrl.match(/^\\/(?!\\/)/);\n    if (!tracePropagationTargets) {\n      return isRelativeSameOriginRequest;\n    } else {\n      return stringMatchesSomePattern(targetUrl, tracePropagationTargets);\n    }\n  } else {\n    let resolvedUrl;\n    let currentOrigin;\n\n    // URL parsing may fail, we default to not attaching trace headers in that case.\n    try {\n      resolvedUrl = new URL(targetUrl, href);\n      currentOrigin = new URL(href).origin;\n    } catch (e) {\n      return false;\n    }\n    const isSameOriginRequest = resolvedUrl.origin === currentOrigin;\n    if (!tracePropagationTargets) {\n      return isSameOriginRequest;\n    } else {\n      return stringMatchesSomePattern(resolvedUrl.toString(), tracePropagationTargets) || isSameOriginRequest && stringMatchesSomePattern(resolvedUrl.pathname, tracePropagationTargets);\n    }\n  }\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\nfunction xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeaders, spans) {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr?.[SENTRY_XHR_DATA_KEY];\n  if (!xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n    return undefined;\n  }\n  const {\n    url,\n    method\n  } = sentryXhrData;\n  const shouldCreateSpanResult = hasSpansEnabled() && shouldCreateSpan(url);\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n    const span = spans[spanId];\n    if (span && sentryXhrData.status_code !== undefined) {\n      setHttpStatus(span, sentryXhrData.status_code);\n      span.end();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n  const fullUrl = getFullURL(url);\n  const parsedUrl = fullUrl ? parseUrl(fullUrl) : parseUrl(url);\n  const urlForSpanName = stripUrlQueryAndFragment(url);\n  const hasParent = !!getActiveSpan();\n  const span = shouldCreateSpanResult && hasParent ? startInactiveSpan({\n    name: `${method} ${urlForSpanName}`,\n    attributes: {\n      url,\n      type: 'xhr',\n      'http.method': method,\n      'http.url': fullUrl,\n      'server.address': parsedUrl?.host,\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser',\n      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',\n      ...(parsedUrl?.search && {\n        'http.query': parsedUrl?.search\n      }),\n      ...(parsedUrl?.hash && {\n        'http.fragment': parsedUrl?.hash\n      })\n    }\n  }) : new SentryNonRecordingSpan();\n  xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n  spans[xhr.__sentry_xhr_span_id__] = span;\n  if (shouldAttachHeaders(url)) {\n    addTracingHeadersToXhrRequest(xhr,\n    // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n    // we do not want to use the span as base for the trace headers,\n    // which means that the headers will be generated from the scope and the sampling decision is deferred\n    hasSpansEnabled() && hasParent ? span : undefined);\n  }\n  const client = getClient();\n  if (client) {\n    client.emit('beforeOutgoingRequestSpan', span, handlerData);\n  }\n  return span;\n}\nfunction addTracingHeadersToXhrRequest(xhr, span) {\n  const {\n    'sentry-trace': sentryTrace,\n    baggage\n  } = getTraceData({\n    span\n  });\n  if (sentryTrace) {\n    setHeaderOnXhr(xhr, sentryTrace, baggage);\n  }\n}\nfunction setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    xhr.setRequestHeader('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n      // We can therefore simply set a baggage header without checking what was there before\n      // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      xhr.setRequestHeader('baggage', sentryBaggageHeader);\n    }\n  } catch (_) {\n    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n  }\n}\nfunction getFullURL(url) {\n  try {\n    // By adding a base URL to new URL(), this will also work for relative urls\n    // If `url` is a full URL, the base URL is ignored anyhow\n    const parsed = new URL(url, WINDOW.location.origin);\n    return parsed.href;\n  } catch {\n    return undefined;\n  }\n}\nexport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests, shouldAttachHeaders, xhrCallback };","map":{"version":3,"names":["responseToSpanId","WeakMap","spanIdToEndTimestamp","Map","defaultRequestInstrumentationOptions","traceFetch","traceXHR","enableHTTPTimings","trackFetchStreamPerformance","instrumentOutgoingRequests","client","_options","shouldCreateSpanForRequest","tracePropagationTargets","onRequestSpanStart","shouldCreateSpan","_","shouldAttachHeadersWithTargets","url","shouldAttachHeaders","spans","addEventProcessor","event","type","forEach","span","op","updatedTimestamp","get","span_id","timestamp","delete","addFetchEndInstrumentationHandler","handlerData","response","endTimestamp","set","addFetchInstrumentationHandler","createdSpan","instrumentFetchRequest","fetchData","__span","fullUrl","getFullURL","host","parseUrl","undefined","setAttributes","addHTTPTimings","headers","addXhrInstrumentationHandler","xhrCallback","Headers","xhr","__sentry_xhr_v3__","request_headers","isPerformanceResourceTiming","entry","entryType","nextHopProtocol","initiatorType","spanToJSON","data","cleanup","addPerformanceInstrumentationHandler","entries","name","endsWith","spanData","resourceTimingEntryToSpanData","setAttribute","setTimeout","getAbsoluteTime","time","browserPerformanceTimeOrigin","performance","timeOrigin","resourceTiming","version","extractNetworkProtocol","timingSpanData","push","redirectStart","fetchStart","domainLookupStart","domainLookupEnd","connectStart","secureConnectionStart","connectEnd","requestStart","responseStart","responseEnd","targetUrl","href","getLocationHref","isRelativeSameOriginRequest","match","stringMatchesSomePattern","resolvedUrl","currentOrigin","URL","origin","e","isSameOriginRequest","toString","pathname","sentryXhrData","SENTRY_XHR_DATA_KEY","__sentry_own_request__","method","shouldCreateSpanResult","hasSpansEnabled","spanId","__sentry_xhr_span_id__","status_code","setHttpStatus","end","parsedUrl","urlForSpanName","stripUrlQueryAndFragment","hasParent","getActiveSpan","startInactiveSpan","attributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","search","hash","SentryNonRecordingSpan","spanContext","addTracingHeadersToXhrRequest","getClient","emit","sentryTrace","baggage","getTraceData","setHeaderOnXhr","sentryTraceHeader","sentryBaggageHeader","setRequestHeader","parsed","WINDOW","location"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry\\browser\\src\\tracing\\request.ts"],"sourcesContent":["import {\n  SENTRY_XHR_DATA_KEY,\n  addPerformanceInstrumentationHandler,\n  addXhrInstrumentationHandler,\n  extractNetworkProtocol,\n} from '@sentry-internal/browser-utils';\nimport type { XhrHint } from '@sentry-internal/browser-utils';\nimport type { Client, HandlerDataXhr, SentryWrappedXMLHttpRequest, Span, WebFetchHeaders } from '@sentry/core';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SentryNonRecordingSpan,\n  addFetchEndInstrumentationHandler,\n  addFetchInstrumentationHandler,\n  browserPerformanceTimeOrigin,\n  getActiveSpan,\n  getClient,\n  getLocationHref,\n  getTraceData,\n  hasSpansEnabled,\n  instrumentFetchRequest,\n  parseUrl,\n  setHttpStatus,\n  spanToJSON,\n  startInactiveSpan,\n  stringMatchesSomePattern,\n  stripUrlQueryAndFragment,\n} from '@sentry/core';\nimport { WINDOW } from '../helpers';\n\n/** Options for Request Instrumentation */\nexport interface RequestInstrumentationOptions {\n  /**\n   * List of strings and/or Regular Expressions used to determine which outgoing requests will have `sentry-trace` and `baggage`\n   * headers attached.\n   *\n   * **Default:** If this option is not provided, tracing headers will be attached to all outgoing requests.\n   * If you are using a browser SDK, by default, tracing headers will only be attached to outgoing requests to the same origin.\n   *\n   * **Disclaimer:** Carelessly setting this option in browser environments may result into CORS errors!\n   * Only attach tracing headers to requests to the same origin, or to requests to services you can control CORS headers of.\n   * Cross-origin requests, meaning requests to a different domain, for example a request to `https://api.example.com/` while you're on `https://example.com/`, take special care.\n   * If you are attaching headers to cross-origin requests, make sure the backend handling the request returns a `\"Access-Control-Allow-Headers: sentry-trace, baggage\"` header to ensure your requests aren't blocked.\n   *\n   * If you provide a `tracePropagationTargets` array, the entries you provide will be matched against the entire URL of the outgoing request.\n   * If you are using a browser SDK, the entries will also be matched against the pathname of the outgoing requests.\n   * This is so you can have matchers for relative requests, for example, `/^\\/api/` if you want to trace requests to your `/api` routes on the same domain.\n   *\n   * If any of the two match any of the provided values, tracing headers will be attached to the outgoing request.\n   * Both, the string values, and the RegExes you provide in the array will match if they partially match the URL or pathname.\n   *\n   * Examples:\n   * - `tracePropagationTargets: [/^\\/api/]` and request to `https://same-origin.com/api/posts`:\n   *   - Tracing headers will be attached because the request is sent to the same origin and the regex matches the pathname \"/api/posts\".\n   * - `tracePropagationTargets: [/^\\/api/]` and request to `https://different-origin.com/api/posts`:\n   *   - Tracing headers will not be attached because the pathname will only be compared when the request target lives on the same origin.\n   * - `tracePropagationTargets: [/^\\/api/, 'https://external-api.com']` and request to `https://external-api.com/v1/data`:\n   *   - Tracing headers will be attached because the request URL matches the string `'https://external-api.com'`.\n   */\n  tracePropagationTargets?: Array<string | RegExp>;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * Flag to disable tracking of long-lived streams, like server-sent events (SSE) via fetch.\n   * Do not enable this in case you have live streams or very long running streams.\n   *\n   * Disabled by default since it can lead to issues with streams using the `cancel()` api\n   * (https://github.com/getsentry/sentry-javascript/issues/13950)\n   *\n   * Default: false\n   */\n  trackFetchStreamPerformance: boolean;\n\n  /**\n   * If true, Sentry will capture http timings and add them to the corresponding http spans.\n   *\n   * Default: true\n   */\n  enableHTTPTimings: boolean;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n\n  /**\n   * Is called when spans are started for outgoing requests.\n   */\n  onRequestSpanStart?(span: Span, requestInformation: { headers?: WebFetchHeaders }): void;\n}\n\nconst responseToSpanId = new WeakMap<object, string>();\nconst spanIdToEndTimestamp = new Map<string, number>();\n\nexport const defaultRequestInstrumentationOptions: RequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  enableHTTPTimings: true,\n  trackFetchStreamPerformance: false,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nexport function instrumentOutgoingRequests(client: Client, _options?: Partial<RequestInstrumentationOptions>): void {\n  const {\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    tracePropagationTargets,\n    onRequestSpanStart,\n  } = {\n    ...defaultRequestInstrumentationOptions,\n    ..._options,\n  };\n\n  const shouldCreateSpan =\n    typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : (_: string) => true;\n\n  const shouldAttachHeadersWithTargets = (url: string): boolean => shouldAttachHeaders(url, tracePropagationTargets);\n\n  const spans: Record<string, Span> = {};\n\n  if (traceFetch) {\n    // Keeping track of http requests, whose body payloads resolved later than the initial resolved request\n    // e.g. streaming using server sent events (SSE)\n    client.addEventProcessor(event => {\n      if (event.type === 'transaction' && event.spans) {\n        event.spans.forEach(span => {\n          if (span.op === 'http.client') {\n            const updatedTimestamp = spanIdToEndTimestamp.get(span.span_id);\n            if (updatedTimestamp) {\n              span.timestamp = updatedTimestamp / 1000;\n              spanIdToEndTimestamp.delete(span.span_id);\n            }\n          }\n        });\n      }\n      return event;\n    });\n\n    if (trackFetchStreamPerformance) {\n      addFetchEndInstrumentationHandler(handlerData => {\n        if (handlerData.response) {\n          const span = responseToSpanId.get(handlerData.response);\n          if (span && handlerData.endTimestamp) {\n            spanIdToEndTimestamp.set(span, handlerData.endTimestamp);\n          }\n        }\n      });\n    }\n\n    addFetchInstrumentationHandler(handlerData => {\n      const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n\n      if (handlerData.response && handlerData.fetchData.__span) {\n        responseToSpanId.set(handlerData.response, handlerData.fetchData.__span);\n      }\n\n      // We cannot use `window.location` in the generic fetch instrumentation,\n      // but we need it for reliable `server.address` attribute.\n      // so we extend this in here\n      if (createdSpan) {\n        const fullUrl = getFullURL(handlerData.fetchData.url);\n        const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n        createdSpan.setAttributes({\n          'http.url': fullUrl,\n          'server.address': host,\n        });\n\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n\n        onRequestSpanStart?.(createdSpan, { headers: handlerData.headers });\n      }\n    });\n  }\n\n  if (traceXHR) {\n    addXhrInstrumentationHandler(handlerData => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (createdSpan) {\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n\n        let headers;\n        try {\n          headers = new Headers(handlerData.xhr.__sentry_xhr_v3__?.request_headers);\n        } catch {\n          // noop\n        }\n        onRequestSpanStart?.(createdSpan, { headers });\n      }\n    });\n  }\n}\n\nfunction isPerformanceResourceTiming(entry: PerformanceEntry): entry is PerformanceResourceTiming {\n  return (\n    entry.entryType === 'resource' &&\n    'initiatorType' in entry &&\n    typeof (entry as PerformanceResourceTiming).nextHopProtocol === 'string' &&\n    (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest')\n  );\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span: Span): void {\n  const { url } = spanToJSON(span).data;\n\n  if (!url || typeof url !== 'string') {\n    return;\n  }\n\n  const cleanup = addPerformanceInstrumentationHandler('resource', ({ entries }) => {\n    entries.forEach(entry => {\n      if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n        const spanData = resourceTimingEntryToSpanData(entry);\n        spanData.forEach(data => span.setAttribute(...data));\n        // In the next tick, clean this handler up\n        // We have to wait here because otherwise this cleans itself up before it is fully done\n        setTimeout(cleanup);\n      }\n    });\n  });\n}\n\nfunction getAbsoluteTime(time: number = 0): number {\n  return ((browserPerformanceTimeOrigin() || performance.timeOrigin) + time) / 1000;\n}\n\nfunction resourceTimingEntryToSpanData(resourceTiming: PerformanceResourceTiming): [string, string | number][] {\n  const { name, version } = extractNetworkProtocol(resourceTiming.nextHopProtocol);\n\n  const timingSpanData: [string, string | number][] = [];\n\n  timingSpanData.push(['network.protocol.version', version], ['network.protocol.name', name]);\n\n  if (!browserPerformanceTimeOrigin()) {\n    return timingSpanData;\n  }\n  return [\n    ...timingSpanData,\n    ['http.request.redirect_start', getAbsoluteTime(resourceTiming.redirectStart)],\n    ['http.request.fetch_start', getAbsoluteTime(resourceTiming.fetchStart)],\n    ['http.request.domain_lookup_start', getAbsoluteTime(resourceTiming.domainLookupStart)],\n    ['http.request.domain_lookup_end', getAbsoluteTime(resourceTiming.domainLookupEnd)],\n    ['http.request.connect_start', getAbsoluteTime(resourceTiming.connectStart)],\n    ['http.request.secure_connection_start', getAbsoluteTime(resourceTiming.secureConnectionStart)],\n    ['http.request.connection_end', getAbsoluteTime(resourceTiming.connectEnd)],\n    ['http.request.request_start', getAbsoluteTime(resourceTiming.requestStart)],\n    ['http.request.response_start', getAbsoluteTime(resourceTiming.responseStart)],\n    ['http.request.response_end', getAbsoluteTime(resourceTiming.responseEnd)],\n  ];\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * We only export this function for testing purposes.\n */\nexport function shouldAttachHeaders(\n  targetUrl: string,\n  tracePropagationTargets: (string | RegExp)[] | undefined,\n): boolean {\n  // window.location.href not being defined is an edge case in the browser but we need to handle it.\n  // Potentially dangerous situations where it may not be defined: Browser Extensions, Web Workers, patching of the location obj\n  const href = getLocationHref();\n\n  if (!href) {\n    // If there is no window.location.origin, we default to only attaching tracing headers to relative requests, i.e. ones that start with `/`\n    // BIG DISCLAIMER: Users can call URLs with a double slash (fetch(\"//example.com/api\")), this is a shorthand for \"send to the same protocol\",\n    // so we need a to exclude those requests, because they might be cross origin.\n    const isRelativeSameOriginRequest = !!targetUrl.match(/^\\/(?!\\/)/);\n    if (!tracePropagationTargets) {\n      return isRelativeSameOriginRequest;\n    } else {\n      return stringMatchesSomePattern(targetUrl, tracePropagationTargets);\n    }\n  } else {\n    let resolvedUrl;\n    let currentOrigin;\n\n    // URL parsing may fail, we default to not attaching trace headers in that case.\n    try {\n      resolvedUrl = new URL(targetUrl, href);\n      currentOrigin = new URL(href).origin;\n    } catch (e) {\n      return false;\n    }\n\n    const isSameOriginRequest = resolvedUrl.origin === currentOrigin;\n    if (!tracePropagationTargets) {\n      return isSameOriginRequest;\n    } else {\n      return (\n        stringMatchesSomePattern(resolvedUrl.toString(), tracePropagationTargets) ||\n        (isSameOriginRequest && stringMatchesSomePattern(resolvedUrl.pathname, tracePropagationTargets))\n      );\n    }\n  }\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\nexport function xhrCallback(\n  handlerData: HandlerDataXhr,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): Span | undefined {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr?.[SENTRY_XHR_DATA_KEY];\n\n  if (!xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n    return undefined;\n  }\n\n  const { url, method } = sentryXhrData;\n\n  const shouldCreateSpanResult = hasSpansEnabled() && shouldCreateSpan(url);\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span && sentryXhrData.status_code !== undefined) {\n      setHttpStatus(span, sentryXhrData.status_code);\n      span.end();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n\n  const fullUrl = getFullURL(url);\n  const parsedUrl = fullUrl ? parseUrl(fullUrl) : parseUrl(url);\n\n  const urlForSpanName = stripUrlQueryAndFragment(url);\n\n  const hasParent = !!getActiveSpan();\n\n  const span =\n    shouldCreateSpanResult && hasParent\n      ? startInactiveSpan({\n          name: `${method} ${urlForSpanName}`,\n          attributes: {\n            url,\n            type: 'xhr',\n            'http.method': method,\n            'http.url': fullUrl,\n            'server.address': parsedUrl?.host,\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',\n            ...(parsedUrl?.search && { 'http.query': parsedUrl?.search }),\n            ...(parsedUrl?.hash && { 'http.fragment': parsedUrl?.hash }),\n          },\n        })\n      : new SentryNonRecordingSpan();\n\n  xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n  spans[xhr.__sentry_xhr_span_id__] = span;\n\n  if (shouldAttachHeaders(url)) {\n    addTracingHeadersToXhrRequest(\n      xhr,\n      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n      // we do not want to use the span as base for the trace headers,\n      // which means that the headers will be generated from the scope and the sampling decision is deferred\n      hasSpansEnabled() && hasParent ? span : undefined,\n    );\n  }\n\n  const client = getClient();\n  if (client) {\n    client.emit('beforeOutgoingRequestSpan', span, handlerData as XhrHint);\n  }\n\n  return span;\n}\n\nfunction addTracingHeadersToXhrRequest(xhr: SentryWrappedXMLHttpRequest, span?: Span): void {\n  const { 'sentry-trace': sentryTrace, baggage } = getTraceData({ span });\n\n  if (sentryTrace) {\n    setHeaderOnXhr(xhr, sentryTrace, baggage);\n  }\n}\n\nfunction setHeaderOnXhr(\n  xhr: SentryWrappedXMLHttpRequest,\n  sentryTraceHeader: string,\n  sentryBaggageHeader: string | undefined,\n): void {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    xhr.setRequestHeader!('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n      // We can therefore simply set a baggage header without checking what was there before\n      // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      xhr.setRequestHeader!('baggage', sentryBaggageHeader);\n    }\n  } catch (_) {\n    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n  }\n}\n\nfunction getFullURL(url: string): string | undefined {\n  try {\n    // By adding a base URL to new URL(), this will also work for relative urls\n    // If `url` is a full URL, the base URL is ignored anyhow\n    const parsed = new URL(url, WINDOW.location.origin);\n    return parsed.href;\n  } catch {\n    return undefined;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}