{"ast":null,"code":"/**\n * Transforms a `Headers` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into a simple key-value dict.\n * The header keys will be lower case: e.g. A \"Content-Type\" header will be stored as \"content-type\".\n */\nfunction winterCGHeadersToDict(winterCGHeaders) {\n  const headers = {};\n  try {\n    winterCGHeaders.forEach((value, key) => {\n      if (typeof value === 'string') {\n        // We check that value is a string even though it might be redundant to make sure prototype pollution is not possible.\n        headers[key] = value;\n      }\n    });\n  } catch {\n    // just return the empty headers\n  }\n  return headers;\n}\n\n/**\n * Convert common request headers to a simple dictionary.\n */\nfunction headersToDict(reqHeaders) {\n  const headers = Object.create(null);\n  try {\n    Object.entries(reqHeaders).forEach(([key, value]) => {\n      if (typeof value === 'string') {\n        headers[key] = value;\n      }\n    });\n  } catch {\n    // just return the empty headers\n  }\n  return headers;\n}\n\n/**\n * Converts a `Request` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into the format that the `RequestData` integration understands.\n */\nfunction winterCGRequestToRequestData(req) {\n  const headers = winterCGHeadersToDict(req.headers);\n  return {\n    method: req.method,\n    url: req.url,\n    query_string: extractQueryParamsFromUrl(req.url),\n    headers\n    // TODO: Can we extract body data from the request?\n  };\n}\n\n/**\n * Convert a HTTP request object to RequestEventData to be passed as normalizedRequest.\n * Instead of allowing `PolymorphicRequest` to be passed,\n * we want to be more specific and generally require a http.IncomingMessage-like object.\n */\nfunction httpRequestToRequestData(request) {\n  const headers = request.headers || {};\n  const host = typeof headers.host === 'string' ? headers.host : undefined;\n  const protocol = request.protocol || (request.socket?.encrypted ? 'https' : 'http');\n  const url = request.url || '';\n  const absoluteUrl = getAbsoluteUrl({\n    url,\n    host,\n    protocol\n  });\n\n  // This is non-standard, but may be sometimes set\n  // It may be overwritten later by our own body handling\n  const data = request.body || undefined;\n\n  // This is non-standard, but may be set on e.g. Next.js or Express requests\n  const cookies = request.cookies;\n  return {\n    url: absoluteUrl,\n    method: request.method,\n    query_string: extractQueryParamsFromUrl(url),\n    headers: headersToDict(headers),\n    cookies,\n    data\n  };\n}\nfunction getAbsoluteUrl({\n  url,\n  protocol,\n  host\n}) {\n  if (url?.startsWith('http')) {\n    return url;\n  }\n  if (url && host) {\n    return `${protocol}://${host}${url}`;\n  }\n  return undefined;\n}\n\n/** Extract the query params from an URL. */\nfunction extractQueryParamsFromUrl(url) {\n  // url is path and query string\n  if (!url) {\n    return;\n  }\n  try {\n    // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n    // hostname as the base. Since the point here is just to grab the query string, it doesn't matter what we use.\n    const queryParams = new URL(url, 'http://s.io').search.slice(1);\n    return queryParams.length ? queryParams : undefined;\n  } catch {\n    return undefined;\n  }\n}\nexport { extractQueryParamsFromUrl, headersToDict, httpRequestToRequestData, winterCGHeadersToDict, winterCGRequestToRequestData };","map":{"version":3,"names":["winterCGHeadersToDict","winterCGHeaders","headers","forEach","value","key","headersToDict","reqHeaders","Object","create","entries","winterCGRequestToRequestData","req","method","url","query_string","extractQueryParamsFromUrl","httpRequestToRequestData","request","host","undefined","protocol","socket","encrypted","absoluteUrl","getAbsoluteUrl","data","body","cookies","startsWith","queryParams","URL","search","slice","length"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry\\core\\src\\utils\\request.ts"],"sourcesContent":["import type { PolymorphicRequest, RequestEventData } from '../types-hoist';\nimport type { WebFetchHeaders, WebFetchRequest } from '../types-hoist/webfetchapi';\n\n/**\n * Transforms a `Headers` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into a simple key-value dict.\n * The header keys will be lower case: e.g. A \"Content-Type\" header will be stored as \"content-type\".\n */\nexport function winterCGHeadersToDict(winterCGHeaders: WebFetchHeaders): Record<string, string> {\n  const headers: Record<string, string> = {};\n  try {\n    winterCGHeaders.forEach((value, key) => {\n      if (typeof value === 'string') {\n        // We check that value is a string even though it might be redundant to make sure prototype pollution is not possible.\n        headers[key] = value;\n      }\n    });\n  } catch {\n    // just return the empty headers\n  }\n\n  return headers;\n}\n\n/**\n * Convert common request headers to a simple dictionary.\n */\nexport function headersToDict(reqHeaders: Record<string, string | string[] | undefined>): Record<string, string> {\n  const headers: Record<string, string> = Object.create(null);\n\n  try {\n    Object.entries(reqHeaders).forEach(([key, value]) => {\n      if (typeof value === 'string') {\n        headers[key] = value;\n      }\n    });\n  } catch {\n    // just return the empty headers\n  }\n\n  return headers;\n}\n\n/**\n * Converts a `Request` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into the format that the `RequestData` integration understands.\n */\nexport function winterCGRequestToRequestData(req: WebFetchRequest): RequestEventData {\n  const headers = winterCGHeadersToDict(req.headers);\n\n  return {\n    method: req.method,\n    url: req.url,\n    query_string: extractQueryParamsFromUrl(req.url),\n    headers,\n    // TODO: Can we extract body data from the request?\n  };\n}\n\n/**\n * Convert a HTTP request object to RequestEventData to be passed as normalizedRequest.\n * Instead of allowing `PolymorphicRequest` to be passed,\n * we want to be more specific and generally require a http.IncomingMessage-like object.\n */\nexport function httpRequestToRequestData(request: {\n  method?: string;\n  url?: string;\n  headers?: {\n    [key: string]: string | string[] | undefined;\n  };\n  protocol?: string;\n  socket?: {\n    encrypted?: boolean;\n    remoteAddress?: string;\n  };\n}): RequestEventData {\n  const headers = request.headers || {};\n  const host = typeof headers.host === 'string' ? headers.host : undefined;\n  const protocol = request.protocol || (request.socket?.encrypted ? 'https' : 'http');\n  const url = request.url || '';\n\n  const absoluteUrl = getAbsoluteUrl({\n    url,\n    host,\n    protocol,\n  });\n\n  // This is non-standard, but may be sometimes set\n  // It may be overwritten later by our own body handling\n  const data = (request as PolymorphicRequest).body || undefined;\n\n  // This is non-standard, but may be set on e.g. Next.js or Express requests\n  const cookies = (request as PolymorphicRequest).cookies;\n\n  return {\n    url: absoluteUrl,\n    method: request.method,\n    query_string: extractQueryParamsFromUrl(url),\n    headers: headersToDict(headers),\n    cookies,\n    data,\n  };\n}\n\nfunction getAbsoluteUrl({\n  url,\n  protocol,\n  host,\n}: {\n  url?: string;\n  protocol: string;\n  host?: string;\n}): string | undefined {\n  if (url?.startsWith('http')) {\n    return url;\n  }\n\n  if (url && host) {\n    return `${protocol}://${host}${url}`;\n  }\n\n  return undefined;\n}\n\n/** Extract the query params from an URL. */\nexport function extractQueryParamsFromUrl(url: string): string | undefined {\n  // url is path and query string\n  if (!url) {\n    return;\n  }\n\n  try {\n    // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n    // hostname as the base. Since the point here is just to grab the query string, it doesn't matter what we use.\n    const queryParams = new URL(url, 'http://s.io').search.slice(1);\n    return queryParams.length ? queryParams : undefined;\n  } catch {\n    return undefined;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}