{"ast":null,"code":"import { _getTraceInfoFromScope } from '../client.js';\nimport { getClient, getCurrentScope } from '../currentScopes.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { SEVERITY_TEXT_TO_SEVERITY_NUMBER } from './constants.js';\nimport { isParameterizedString } from '../utils-hoist/is.js';\nimport '../utils-hoist/debug-build.js';\nimport { logger } from '../utils-hoist/logger.js';\nimport '../utils-hoist/time.js';\nimport '../utils-hoist/syncpromise.js';\nimport { _getSpanForScope } from '../utils/spanOnScope.js';\nimport { createOtelLogEnvelope } from './envelope.js';\nconst MAX_LOG_BUFFER_SIZE = 100;\nconst CLIENT_TO_LOG_BUFFER_MAP = new WeakMap();\n\n/**\n * Converts a log attribute to a serialized log attribute.\n *\n * @param key - The key of the log attribute.\n * @param value - The value of the log attribute.\n * @returns The serialized log attribute.\n */\nfunction logAttributeToSerializedLogAttribute(key, value) {\n  switch (typeof value) {\n    case 'number':\n      return {\n        key,\n        value: {\n          doubleValue: value\n        }\n      };\n    case 'boolean':\n      return {\n        key,\n        value: {\n          boolValue: value\n        }\n      };\n    case 'string':\n      return {\n        key,\n        value: {\n          stringValue: value\n        }\n      };\n    default:\n      {\n        let stringValue = '';\n        try {\n          stringValue = JSON.stringify(value) ?? '';\n        } catch {\n          // Do nothing\n        }\n        return {\n          key,\n          value: {\n            stringValue\n          }\n        };\n      }\n  }\n}\n\n/**\n * Captures a log event and sends it to Sentry.\n *\n * @param log - The log event to capture.\n * @param scope - A scope. Uses the current scope if not provided.\n * @param client - A client. Uses the current client if not provided.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nfunction _INTERNAL_captureLog(beforeLog, client = getClient(), scope = getCurrentScope()) {\n  if (!client) {\n    DEBUG_BUILD && logger.warn('No client available to capture log.');\n    return;\n  }\n  const {\n    _experiments,\n    release,\n    environment\n  } = client.getOptions();\n  const {\n    enableLogs = false,\n    beforeSendLog\n  } = _experiments ?? {};\n  if (!enableLogs) {\n    DEBUG_BUILD && logger.warn('logging option not enabled, log will not be captured.');\n    return;\n  }\n  const [, traceContext] = _getTraceInfoFromScope(client, scope);\n  const processedLogAttributes = {\n    ...beforeLog.attributes\n  };\n  if (release) {\n    processedLogAttributes['sentry.release'] = release;\n  }\n  if (environment) {\n    processedLogAttributes['sentry.environment'] = environment;\n  }\n  const {\n    sdk\n  } = client.getSdkMetadata() ?? {};\n  if (sdk) {\n    processedLogAttributes['sentry.sdk.name'] = sdk.name;\n    processedLogAttributes['sentry.sdk.version'] = sdk.version;\n  }\n  const beforeLogMessage = beforeLog.message;\n  if (isParameterizedString(beforeLogMessage)) {\n    const {\n      __sentry_template_string__,\n      __sentry_template_values__ = []\n    } = beforeLogMessage;\n    processedLogAttributes['sentry.message.template'] = __sentry_template_string__;\n    __sentry_template_values__.forEach((param, index) => {\n      processedLogAttributes[`sentry.message.parameter.${index}`] = param;\n    });\n  }\n  const span = _getSpanForScope(scope);\n  if (span) {\n    // Add the parent span ID to the log attributes for trace context\n    processedLogAttributes['sentry.trace.parent_span_id'] = span.spanContext().spanId;\n  }\n  const processedLog = {\n    ...beforeLog,\n    attributes: processedLogAttributes\n  };\n  client.emit('beforeCaptureLog', processedLog);\n  const log = beforeSendLog ? beforeSendLog(processedLog) : processedLog;\n  if (!log) {\n    client.recordDroppedEvent('before_send', 'log_item', 1);\n    DEBUG_BUILD && logger.warn('beforeSendLog returned null, log will not be captured.');\n    return;\n  }\n  const {\n    level,\n    message,\n    attributes = {},\n    severityNumber\n  } = log;\n  const serializedLog = {\n    severityText: level,\n    body: {\n      stringValue: message\n    },\n    attributes: Object.entries(attributes).map(([key, value]) => logAttributeToSerializedLogAttribute(key, value)),\n    timeUnixNano: `${new Date().getTime().toString()}000000`,\n    traceId: traceContext?.trace_id,\n    severityNumber: severityNumber ?? SEVERITY_TEXT_TO_SEVERITY_NUMBER[level]\n  };\n  const logBuffer = CLIENT_TO_LOG_BUFFER_MAP.get(client);\n  if (logBuffer === undefined) {\n    CLIENT_TO_LOG_BUFFER_MAP.set(client, [serializedLog]);\n  } else {\n    logBuffer.push(serializedLog);\n    if (logBuffer.length > MAX_LOG_BUFFER_SIZE) {\n      _INTERNAL_flushLogsBuffer(client, logBuffer);\n    }\n  }\n  client.emit('afterCaptureLog', log);\n}\n\n/**\n * Flushes the logs buffer to Sentry.\n *\n * @param client - A client.\n * @param maybeLogBuffer - A log buffer. Uses the log buffer for the given client if not provided.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nfunction _INTERNAL_flushLogsBuffer(client, maybeLogBuffer) {\n  const logBuffer = maybeLogBuffer ?? CLIENT_TO_LOG_BUFFER_MAP.get(client) ?? [];\n  if (logBuffer.length === 0) {\n    return;\n  }\n  const clientOptions = client.getOptions();\n  const envelope = createOtelLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());\n\n  // Clear the log buffer after envelopes have been constructed.\n  logBuffer.length = 0;\n  client.emit('flushLogs');\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\nexport { _INTERNAL_captureLog, _INTERNAL_flushLogsBuffer, logAttributeToSerializedLogAttribute };","map":{"version":3,"names":["MAX_LOG_BUFFER_SIZE","CLIENT_TO_LOG_BUFFER_MAP","WeakMap","logAttributeToSerializedLogAttribute","key","value","doubleValue","boolValue","stringValue","JSON","stringify","_INTERNAL_captureLog","beforeLog","client","getClient","scope","getCurrentScope","DEBUG_BUILD","logger","warn","_experiments","release","environment","getOptions","enableLogs","beforeSendLog","traceContext","_getTraceInfoFromScope","processedLogAttributes","attributes","sdk","getSdkMetadata","name","version","beforeLogMessage","message","isParameterizedString","__sentry_template_string__","__sentry_template_values__","forEach","param","index","span","_getSpanForScope","spanContext","spanId","processedLog","emit","log","recordDroppedEvent","level","severityNumber","serializedLog","severityText","body","Object","entries","map","timeUnixNano","Date","getTime","toString","traceId","trace_id","SEVERITY_TEXT_TO_SEVERITY_NUMBER","logBuffer","get","undefined","set","push","length","_INTERNAL_flushLogsBuffer","maybeLogBuffer","clientOptions","envelope","createOtelLogEnvelope","_metadata","tunnel","getDsn","sendEnvelope"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry\\core\\src\\logs\\exports.ts"],"sourcesContent":["import type { Client } from '../client';\nimport { _getTraceInfoFromScope } from '../client';\nimport { getClient, getCurrentScope } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { SEVERITY_TEXT_TO_SEVERITY_NUMBER } from './constants';\nimport type { SerializedLogAttribute, SerializedOtelLog } from '../types-hoist';\nimport type { Log } from '../types-hoist/log';\nimport { isParameterizedString, logger } from '../utils-hoist';\nimport { _getSpanForScope } from '../utils/spanOnScope';\nimport { createOtelLogEnvelope } from './envelope';\n\nconst MAX_LOG_BUFFER_SIZE = 100;\n\nconst CLIENT_TO_LOG_BUFFER_MAP = new WeakMap<Client, Array<SerializedOtelLog>>();\n\n/**\n * Converts a log attribute to a serialized log attribute.\n *\n * @param key - The key of the log attribute.\n * @param value - The value of the log attribute.\n * @returns The serialized log attribute.\n */\nexport function logAttributeToSerializedLogAttribute(key: string, value: unknown): SerializedLogAttribute {\n  switch (typeof value) {\n    case 'number':\n      return {\n        key,\n        value: { doubleValue: value },\n      };\n    case 'boolean':\n      return {\n        key,\n        value: { boolValue: value },\n      };\n    case 'string':\n      return {\n        key,\n        value: { stringValue: value },\n      };\n    default: {\n      let stringValue = '';\n      try {\n        stringValue = JSON.stringify(value) ?? '';\n      } catch {\n        // Do nothing\n      }\n      return {\n        key,\n        value: { stringValue },\n      };\n    }\n  }\n}\n\n/**\n * Captures a log event and sends it to Sentry.\n *\n * @param log - The log event to capture.\n * @param scope - A scope. Uses the current scope if not provided.\n * @param client - A client. Uses the current client if not provided.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_captureLog(\n  beforeLog: Log,\n  client: Client | undefined = getClient(),\n  scope = getCurrentScope(),\n): void {\n  if (!client) {\n    DEBUG_BUILD && logger.warn('No client available to capture log.');\n    return;\n  }\n\n  const { _experiments, release, environment } = client.getOptions();\n  const { enableLogs = false, beforeSendLog } = _experiments ?? {};\n  if (!enableLogs) {\n    DEBUG_BUILD && logger.warn('logging option not enabled, log will not be captured.');\n    return;\n  }\n\n  const [, traceContext] = _getTraceInfoFromScope(client, scope);\n\n  const processedLogAttributes = {\n    ...beforeLog.attributes,\n  };\n\n  if (release) {\n    processedLogAttributes['sentry.release'] = release;\n  }\n\n  if (environment) {\n    processedLogAttributes['sentry.environment'] = environment;\n  }\n\n  const { sdk } = client.getSdkMetadata() ?? {};\n  if (sdk) {\n    processedLogAttributes['sentry.sdk.name'] = sdk.name;\n    processedLogAttributes['sentry.sdk.version'] = sdk.version;\n  }\n\n  const beforeLogMessage = beforeLog.message;\n  if (isParameterizedString(beforeLogMessage)) {\n    const { __sentry_template_string__, __sentry_template_values__ = [] } = beforeLogMessage;\n    processedLogAttributes['sentry.message.template'] = __sentry_template_string__;\n    __sentry_template_values__.forEach((param, index) => {\n      processedLogAttributes[`sentry.message.parameter.${index}`] = param;\n    });\n  }\n\n  const span = _getSpanForScope(scope);\n  if (span) {\n    // Add the parent span ID to the log attributes for trace context\n    processedLogAttributes['sentry.trace.parent_span_id'] = span.spanContext().spanId;\n  }\n\n  const processedLog = { ...beforeLog, attributes: processedLogAttributes };\n\n  client.emit('beforeCaptureLog', processedLog);\n\n  const log = beforeSendLog ? beforeSendLog(processedLog) : processedLog;\n  if (!log) {\n    client.recordDroppedEvent('before_send', 'log_item', 1);\n    DEBUG_BUILD && logger.warn('beforeSendLog returned null, log will not be captured.');\n    return;\n  }\n\n  const { level, message, attributes = {}, severityNumber } = log;\n\n  const serializedLog: SerializedOtelLog = {\n    severityText: level,\n    body: {\n      stringValue: message,\n    },\n    attributes: Object.entries(attributes).map(([key, value]) => logAttributeToSerializedLogAttribute(key, value)),\n    timeUnixNano: `${new Date().getTime().toString()}000000`,\n    traceId: traceContext?.trace_id,\n    severityNumber: severityNumber ?? SEVERITY_TEXT_TO_SEVERITY_NUMBER[level],\n  };\n\n  const logBuffer = CLIENT_TO_LOG_BUFFER_MAP.get(client);\n  if (logBuffer === undefined) {\n    CLIENT_TO_LOG_BUFFER_MAP.set(client, [serializedLog]);\n  } else {\n    logBuffer.push(serializedLog);\n    if (logBuffer.length > MAX_LOG_BUFFER_SIZE) {\n      _INTERNAL_flushLogsBuffer(client, logBuffer);\n    }\n  }\n\n  client.emit('afterCaptureLog', log);\n}\n\n/**\n * Flushes the logs buffer to Sentry.\n *\n * @param client - A client.\n * @param maybeLogBuffer - A log buffer. Uses the log buffer for the given client if not provided.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_flushLogsBuffer(client: Client, maybeLogBuffer?: Array<SerializedOtelLog>): void {\n  const logBuffer = maybeLogBuffer ?? CLIENT_TO_LOG_BUFFER_MAP.get(client) ?? [];\n  if (logBuffer.length === 0) {\n    return;\n  }\n\n  const clientOptions = client.getOptions();\n  const envelope = createOtelLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());\n\n  // Clear the log buffer after envelopes have been constructed.\n  logBuffer.length = 0;\n\n  client.emit('flushLogs');\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\n\n/**\n * Returns the log buffer for a given client.\n *\n * Exported for testing purposes.\n *\n * @param client - The client to get the log buffer for.\n * @returns The log buffer for the given client.\n */\nexport function _INTERNAL_getLogBuffer(client: Client): Array<SerializedOtelLog> | undefined {\n  return CLIENT_TO_LOG_BUFFER_MAP.get(client);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}