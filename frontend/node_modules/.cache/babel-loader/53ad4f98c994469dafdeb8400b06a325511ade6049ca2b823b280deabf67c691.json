{"ast":null,"code":"import { startTrackingWebVitals, startTrackingINP, startTrackingLongAnimationFrames, startTrackingLongTasks, startTrackingInteractions, addHistoryInstrumentationHandler, registerInpInteractionListener, addPerformanceEntries } from '@sentry-internal/browser-utils';\nimport { TRACING_DEFAULTS, registerSpanErrorInstrumentation, GLOBAL_OBJ, getLocationHref, getClient, getIsolationScope, generateTraceId, getCurrentScope, propagationContextFromHeaders, getRootSpan, browserPerformanceTimeOrigin, spanToJSON, logger, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, startIdleSpan, getDynamicSamplingContextFromSpan, spanIsSampled, addNonEnumerableProperty, consoleSandbox, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { WINDOW } from '../helpers.js';\nimport { registerBackgroundTabDetection } from './backgroundtab.js';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request.js';\nimport { addPreviousTraceSpanLink, getPreviousTraceFromSessionStorage, storePreviousTraceInSessionStorage } from './previousTrace.js';\n\n/* eslint-disable max-lines */\n\nconst BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\nconst DEFAULT_BROWSER_TRACING_OPTIONS = {\n  ...TRACING_DEFAULTS,\n  instrumentNavigation: true,\n  instrumentPageLoad: true,\n  markBackgroundSpan: true,\n  enableLongTask: true,\n  enableLongAnimationFrame: true,\n  enableInp: true,\n  linkPreviousTrace: 'in-memory',\n  _experiments: {},\n  ...defaultRequestInstrumentationOptions\n};\nlet _hasBeenInitialized = false;\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library.\n *\n * We explicitly export the proper type here, as this has to be extended in some cases.\n */\nconst browserTracingIntegration = (_options = {}) => {\n  if (_hasBeenInitialized) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('Multiple browserTracingIntegration instances are not supported.');\n    });\n  }\n  _hasBeenInitialized = true;\n\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document;\n  registerSpanErrorInstrumentation();\n  const {\n    enableInp,\n    enableLongTask,\n    enableLongAnimationFrame,\n    _experiments: {\n      enableInteractions,\n      enableStandaloneClsSpans\n    },\n    beforeStartSpan,\n    idleTimeout,\n    finalTimeout,\n    childSpanTimeout,\n    markBackgroundSpan,\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    instrumentPageLoad,\n    instrumentNavigation,\n    linkPreviousTrace,\n    onRequestSpanStart\n  } = {\n    ...DEFAULT_BROWSER_TRACING_OPTIONS,\n    ..._options\n  };\n  const _collectWebVitals = startTrackingWebVitals({\n    recordClsStandaloneSpans: enableStandaloneClsSpans || false\n  });\n  if (enableInp) {\n    startTrackingINP();\n  }\n  if (enableLongAnimationFrame && GLOBAL_OBJ.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes('long-animation-frame')) {\n    startTrackingLongAnimationFrames();\n  } else if (enableLongTask) {\n    startTrackingLongTasks();\n  }\n  if (enableInteractions) {\n    startTrackingInteractions();\n  }\n  const latestRoute = {\n    name: undefined,\n    source: undefined\n  };\n\n  /** Create routing idle transaction. */\n  function _createRouteSpan(client, startSpanOptions) {\n    const isPageloadTransaction = startSpanOptions.op === 'pageload';\n    const finalStartSpanOptions = beforeStartSpan ? beforeStartSpan(startSpanOptions) : startSpanOptions;\n    const attributes = finalStartSpanOptions.attributes || {};\n\n    // If `finalStartSpanOptions.name` is different than `startSpanOptions.name`\n    // it is because `beforeStartSpan` set a custom name. Therefore we set the source to 'custom'.\n    if (startSpanOptions.name !== finalStartSpanOptions.name) {\n      attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'custom';\n      finalStartSpanOptions.attributes = attributes;\n    }\n    latestRoute.name = finalStartSpanOptions.name;\n    latestRoute.source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n    const idleSpan = startIdleSpan(finalStartSpanOptions, {\n      idleTimeout,\n      finalTimeout,\n      childSpanTimeout,\n      // should wait for finish signal if it's a pageload transaction\n      disableAutoFinish: isPageloadTransaction,\n      beforeSpanEnd: span => {\n        _collectWebVitals();\n        addPerformanceEntries(span, {\n          recordClsOnPageloadSpan: !enableStandaloneClsSpans\n        });\n        setActiveIdleSpan(client, undefined);\n\n        // A trace should stay consistent over the entire timespan of one route - even after the pageload/navigation ended.\n        // Only when another navigation happens, we want to create a new trace.\n        // This way, e.g. errors that occur after the pageload span ended are still associated to the pageload trace.\n        const scope = getCurrentScope();\n        const oldPropagationContext = scope.getPropagationContext();\n        scope.setPropagationContext({\n          ...oldPropagationContext,\n          traceId: idleSpan.spanContext().traceId,\n          sampled: spanIsSampled(idleSpan),\n          dsc: getDynamicSamplingContextFromSpan(span)\n        });\n      }\n    });\n    setActiveIdleSpan(client, idleSpan);\n    function emitFinish() {\n      if (optionalWindowDocument && ['interactive', 'complete'].includes(optionalWindowDocument.readyState)) {\n        client.emit('idleSpanEnableAutoFinish', idleSpan);\n      }\n    }\n    if (isPageloadTransaction && optionalWindowDocument) {\n      optionalWindowDocument.addEventListener('readystatechange', () => {\n        emitFinish();\n      });\n      emitFinish();\n    }\n  }\n  return {\n    name: BROWSER_TRACING_INTEGRATION_ID,\n    afterAllSetup(client) {\n      let startingUrl = getLocationHref();\n      function maybeEndActiveSpan() {\n        const activeSpan = getActiveIdleSpan(client);\n        if (activeSpan && !spanToJSON(activeSpan).timestamp) {\n          DEBUG_BUILD && logger.log(`[Tracing] Finishing current active span with op: ${spanToJSON(activeSpan).op}`);\n          // If there's an open active span, we need to finish it before creating an new one.\n          activeSpan.end();\n        }\n      }\n      client.on('startNavigationSpan', startSpanOptions => {\n        if (getClient() !== client) {\n          return;\n        }\n        maybeEndActiveSpan();\n        getIsolationScope().setPropagationContext({\n          traceId: generateTraceId(),\n          sampleRand: Math.random()\n        });\n        getCurrentScope().setPropagationContext({\n          traceId: generateTraceId(),\n          sampleRand: Math.random()\n        });\n        _createRouteSpan(client, {\n          op: 'navigation',\n          ...startSpanOptions\n        });\n      });\n      client.on('startPageLoadSpan', (startSpanOptions, traceOptions = {}) => {\n        if (getClient() !== client) {\n          return;\n        }\n        maybeEndActiveSpan();\n        const sentryTrace = traceOptions.sentryTrace || getMetaContent('sentry-trace');\n        const baggage = traceOptions.baggage || getMetaContent('baggage');\n        const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n        getCurrentScope().setPropagationContext(propagationContext);\n        _createRouteSpan(client, {\n          op: 'pageload',\n          ...startSpanOptions\n        });\n      });\n      if (linkPreviousTrace !== 'off') {\n        let inMemoryPreviousTraceInfo = undefined;\n        client.on('spanStart', span => {\n          if (getRootSpan(span) !== span) {\n            return;\n          }\n          if (linkPreviousTrace === 'session-storage') {\n            const updatedPreviousTraceInfo = addPreviousTraceSpanLink(getPreviousTraceFromSessionStorage(), span);\n            storePreviousTraceInSessionStorage(updatedPreviousTraceInfo);\n          } else {\n            inMemoryPreviousTraceInfo = addPreviousTraceSpanLink(inMemoryPreviousTraceInfo, span);\n          }\n        });\n      }\n      if (WINDOW.location) {\n        if (instrumentPageLoad) {\n          const origin = browserPerformanceTimeOrigin();\n          startBrowserTracingPageLoadSpan(client, {\n            name: WINDOW.location.pathname,\n            // pageload should always start at timeOrigin (and needs to be in s, not ms)\n            startTime: origin ? origin / 1000 : undefined,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.browser'\n            }\n          });\n        }\n        if (instrumentNavigation) {\n          addHistoryInstrumentationHandler(({\n            to,\n            from\n          }) => {\n            /**\n             * This early return is there to account for some cases where a navigation transaction starts right after\n             * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n             * create an uneccessary navigation transaction.\n             *\n             * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n             * only be caused in certain development environments where the usage of a hot module reloader is causing\n             * errors.\n             */\n            if (from === undefined && startingUrl?.indexOf(to) !== -1) {\n              startingUrl = undefined;\n              return;\n            }\n            if (from !== to) {\n              startingUrl = undefined;\n              startBrowserTracingNavigationSpan(client, {\n                name: WINDOW.location.pathname,\n                attributes: {\n                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.browser'\n                }\n              });\n            }\n          });\n        }\n      }\n      if (markBackgroundSpan) {\n        registerBackgroundTabDetection();\n      }\n      if (enableInteractions) {\n        registerInteractionListener(client, idleTimeout, finalTimeout, childSpanTimeout, latestRoute);\n      }\n      if (enableInp) {\n        registerInpInteractionListener();\n      }\n      instrumentOutgoingRequests(client, {\n        traceFetch,\n        traceXHR,\n        trackFetchStreamPerformance,\n        tracePropagationTargets: client.getOptions().tracePropagationTargets,\n        shouldCreateSpanForRequest,\n        enableHTTPTimings,\n        onRequestSpanStart\n      });\n    }\n  };\n};\n\n/**\n * Manually start a page load span.\n * This will only do something if a browser tracing integration integration has been setup.\n *\n * If you provide a custom `traceOptions` object, it will be used to continue the trace\n * instead of the default behavior, which is to look it up on the <meta> tags.\n */\nfunction startBrowserTracingPageLoadSpan(client, spanOptions, traceOptions) {\n  client.emit('startPageLoadSpan', spanOptions, traceOptions);\n  getCurrentScope().setTransactionName(spanOptions.name);\n  return getActiveIdleSpan(client);\n}\n\n/**\n * Manually start a navigation span.\n * This will only do something if a browser tracing integration has been setup.\n */\nfunction startBrowserTracingNavigationSpan(client, spanOptions) {\n  client.emit('startNavigationSpan', spanOptions);\n  getCurrentScope().setTransactionName(spanOptions.name);\n  return getActiveIdleSpan(client);\n}\n\n/** Returns the value of a meta tag */\nfunction getMetaContent(metaName) {\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document;\n  const metaTag = optionalWindowDocument?.querySelector(`meta[name=${metaName}]`);\n  return metaTag?.getAttribute('content') || undefined;\n}\n\n/** Start listener for interaction transactions */\nfunction registerInteractionListener(client, idleTimeout, finalTimeout, childSpanTimeout, latestRoute) {\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document;\n  let inflightInteractionSpan;\n  const registerInteractionTransaction = () => {\n    const op = 'ui.action.click';\n    const activeIdleSpan = getActiveIdleSpan(client);\n    if (activeIdleSpan) {\n      const currentRootSpanOp = spanToJSON(activeIdleSpan).op;\n      if (['navigation', 'pageload'].includes(currentRootSpanOp)) {\n        DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} span because a pageload or navigation span is in progress.`);\n        return undefined;\n      }\n    }\n    if (inflightInteractionSpan) {\n      inflightInteractionSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, 'interactionInterrupted');\n      inflightInteractionSpan.end();\n      inflightInteractionSpan = undefined;\n    }\n    if (!latestRoute.name) {\n      DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n      return undefined;\n    }\n    inflightInteractionSpan = startIdleSpan({\n      name: latestRoute.name,\n      op,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: latestRoute.source || 'url'\n      }\n    }, {\n      idleTimeout,\n      finalTimeout,\n      childSpanTimeout\n    });\n  };\n  if (optionalWindowDocument) {\n    addEventListener('click', registerInteractionTransaction, {\n      once: false,\n      capture: true\n    });\n  }\n}\n\n// We store the active idle span on the client object, so we can access it from exported functions\nconst ACTIVE_IDLE_SPAN_PROPERTY = '_sentry_idleSpan';\nfunction getActiveIdleSpan(client) {\n  return client[ACTIVE_IDLE_SPAN_PROPERTY];\n}\nfunction setActiveIdleSpan(client, span) {\n  addNonEnumerableProperty(client, ACTIVE_IDLE_SPAN_PROPERTY, span);\n}\nexport { BROWSER_TRACING_INTEGRATION_ID, browserTracingIntegration, getMetaContent, startBrowserTracingNavigationSpan, startBrowserTracingPageLoadSpan };","map":{"version":3,"names":["BROWSER_TRACING_INTEGRATION_ID","DEFAULT_BROWSER_TRACING_OPTIONS","TRACING_DEFAULTS","instrumentNavigation","instrumentPageLoad","markBackgroundSpan","enableLongTask","enableLongAnimationFrame","enableInp","linkPreviousTrace","_experiments","defaultRequestInstrumentationOptions","_hasBeenInitialized","browserTracingIntegration","_options","consoleSandbox","console","warn","optionalWindowDocument","WINDOW","document","registerSpanErrorInstrumentation","enableInteractions","enableStandaloneClsSpans","beforeStartSpan","idleTimeout","finalTimeout","childSpanTimeout","traceFetch","traceXHR","trackFetchStreamPerformance","shouldCreateSpanForRequest","enableHTTPTimings","onRequestSpanStart","_collectWebVitals","startTrackingWebVitals","recordClsStandaloneSpans","startTrackingINP","GLOBAL_OBJ","PerformanceObserver","supportedEntryTypes","includes","startTrackingLongAnimationFrames","startTrackingLongTasks","startTrackingInteractions","latestRoute","name","undefined","source","_createRouteSpan","client","startSpanOptions","isPageloadTransaction","op","finalStartSpanOptions","attributes","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","idleSpan","startIdleSpan","disableAutoFinish","beforeSpanEnd","span","addPerformanceEntries","recordClsOnPageloadSpan","setActiveIdleSpan","scope","getCurrentScope","oldPropagationContext","getPropagationContext","setPropagationContext","traceId","spanContext","sampled","spanIsSampled","dsc","getDynamicSamplingContextFromSpan","emitFinish","readyState","emit","addEventListener","afterAllSetup","startingUrl","getLocationHref","maybeEndActiveSpan","activeSpan","getActiveIdleSpan","spanToJSON","timestamp","DEBUG_BUILD","logger","log","end","on","getClient","getIsolationScope","generateTraceId","sampleRand","Math","random","traceOptions","sentryTrace","getMetaContent","baggage","propagationContext","propagationContextFromHeaders","inMemoryPreviousTraceInfo","getRootSpan","updatedPreviousTraceInfo","addPreviousTraceSpanLink","getPreviousTraceFromSessionStorage","storePreviousTraceInSessionStorage","location","origin","browserPerformanceTimeOrigin","startBrowserTracingPageLoadSpan","pathname","startTime","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","addHistoryInstrumentationHandler","to","from","indexOf","startBrowserTracingNavigationSpan","registerBackgroundTabDetection","registerInteractionListener","registerInpInteractionListener","instrumentOutgoingRequests","tracePropagationTargets","getOptions","spanOptions","setTransactionName","metaName","metaTag","querySelector","getAttribute","inflightInteractionSpan","registerInteractionTransaction","activeIdleSpan","currentRootSpanOp","setAttribute","SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON","once","capture","ACTIVE_IDLE_SPAN_PROPERTY","addNonEnumerableProperty"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry\\browser\\src\\tracing\\browserTracingIntegration.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport {\n  addHistoryInstrumentationHandler,\n  addPerformanceEntries,\n  registerInpInteractionListener,\n  startTrackingINP,\n  startTrackingInteractions,\n  startTrackingLongAnimationFrames,\n  startTrackingLongTasks,\n  startTrackingWebVitals,\n} from '@sentry-internal/browser-utils';\nimport type { Client, IntegrationFn, Span, StartSpanOptions, TransactionSource, WebFetchHeaders } from '@sentry/core';\nimport { consoleSandbox } from '@sentry/core';\nimport {\n  GLOBAL_OBJ,\n  SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  TRACING_DEFAULTS,\n  addNonEnumerableProperty,\n  browserPerformanceTimeOrigin,\n  generateTraceId,\n  getClient,\n  getCurrentScope,\n  getDynamicSamplingContextFromSpan,\n  getIsolationScope,\n  getLocationHref,\n  getRootSpan,\n  logger,\n  propagationContextFromHeaders,\n  registerSpanErrorInstrumentation,\n  spanIsSampled,\n  spanToJSON,\n  startIdleSpan,\n} from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { WINDOW } from '../helpers';\nimport { registerBackgroundTabDetection } from './backgroundtab';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request';\nimport type { PreviousTraceInfo } from './previousTrace';\nimport {\n  addPreviousTraceSpanLink,\n  getPreviousTraceFromSessionStorage,\n  storePreviousTraceInSessionStorage,\n} from './previousTrace';\n\nexport const BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\ninterface RouteInfo {\n  name: string | undefined;\n  source: TransactionSource | undefined;\n}\n\n/** Options for Browser Tracing integration */\nexport interface BrowserTracingOptions {\n  /**\n   * The time that has to pass without any span being created.\n   * If this time is exceeded, the idle span will finish.\n   *\n   * Default: 1000 (ms)\n   */\n  idleTimeout: number;\n\n  /**\n   * The max. time an idle span may run.\n   * If this time is exceeded, the idle span will finish no matter what.\n   *\n   * Default: 30000 (ms)\n   */\n  finalTimeout: number;\n\n  /**\n   The max. time an idle span may run.\n   * If this time is exceeded, the idle span will finish no matter what.\n   *\n   * Default: 15000 (ms)\n   */\n  childSpanTimeout: number;\n\n  /**\n   * If a span should be created on page load.\n   * If this is set to `false`, this integration will not start the default page load span.\n   * Default: true\n   */\n  instrumentPageLoad: boolean;\n\n  /**\n   * If a span should be created on navigation (history change).\n   * If this is set to `false`, this integration will not start the default navigation spans.\n   * Default: true\n   */\n  instrumentNavigation: boolean;\n\n  /**\n   * Flag spans where tabs moved to background with \"cancelled\". Browser background tab timing is\n   * not suited towards doing precise measurements of operations. By default, we recommend that this option\n   * be enabled as background transactions can mess up your statistics in nondeterministic ways.\n   *\n   * Default: true\n   */\n  markBackgroundSpan: boolean;\n\n  /**\n   * If true, Sentry will capture long tasks and add them to the corresponding transaction.\n   *\n   * Default: true\n   */\n  enableLongTask: boolean;\n\n  /**\n   * If true, Sentry will capture long animation frames and add them to the corresponding transaction.\n   *\n   * Default: false\n   */\n  enableLongAnimationFrame: boolean;\n\n  /**\n   * If true, Sentry will capture first input delay and add it to the corresponding transaction.\n   *\n   * Default: true\n   */\n  enableInp: boolean;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * Flag to disable tracking of long-lived streams, like server-sent events (SSE) via fetch.\n   * Do not enable this in case you have live streams or very long running streams.\n   *\n   * Default: false\n   */\n  trackFetchStreamPerformance: boolean;\n\n  /**\n   * If true, Sentry will capture http timings and add them to the corresponding http spans.\n   *\n   * Default: true\n   */\n  enableHTTPTimings: boolean;\n\n  /**\n   * Link the currently started trace to a previous trace (e.g. a prior pageload, navigation or\n   * manually started span). When enabled, this option will allow you to navigate between traces\n   * in the Sentry UI.\n   *\n   * You can set this option to the following values:\n   *\n   * - `'in-memory'`: The previous trace data will be stored in memory.\n   *   This is useful for single-page applications and enabled by default.\n   *\n   * - `'session-storage'`: The previous trace data will be stored in the `sessionStorage`.\n   *   This is useful for multi-page applications or static sites but it means that the\n   *   Sentry SDK writes to the browser's `sessionStorage`.\n   *\n   * - `'off'`: The previous trace data will not be stored or linked.\n   *\n   * Note that your `tracesSampleRate` or `tracesSampler` config significantly influences\n   * how often traces will be linked.\n   *\n   * @default 'in-memory' - see explanation above\n   */\n  linkPreviousTrace: 'in-memory' | 'session-storage' | 'off';\n\n  /**\n   * _experiments allows the user to send options to define how this integration works.\n   *\n   * Default: undefined\n   */\n  _experiments: Partial<{\n    enableInteractions: boolean;\n    enableStandaloneClsSpans: boolean;\n  }>;\n\n  /**\n   * A callback which is called before a span for a pageload or navigation is started.\n   * It receives the options passed to `startSpan`, and expects to return an updated options object.\n   */\n  beforeStartSpan?: (options: StartSpanOptions) => StartSpanOptions;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n\n  /**\n   * This callback is invoked directly after a span is started for an outgoing fetch or XHR request.\n   * You can use it to annotate the span with additional data or attributes, for example by setting\n   * attributes based on the passed request headers.\n   */\n  onRequestSpanStart?(span: Span, requestInformation: { headers?: WebFetchHeaders }): void;\n}\n\nconst DEFAULT_BROWSER_TRACING_OPTIONS: BrowserTracingOptions = {\n  ...TRACING_DEFAULTS,\n  instrumentNavigation: true,\n  instrumentPageLoad: true,\n  markBackgroundSpan: true,\n  enableLongTask: true,\n  enableLongAnimationFrame: true,\n  enableInp: true,\n  linkPreviousTrace: 'in-memory',\n  _experiments: {},\n  ...defaultRequestInstrumentationOptions,\n};\n\nlet _hasBeenInitialized = false;\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library.\n *\n * We explicitly export the proper type here, as this has to be extended in some cases.\n */\nexport const browserTracingIntegration = ((_options: Partial<BrowserTracingOptions> = {}) => {\n  if (_hasBeenInitialized) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('Multiple browserTracingIntegration instances are not supported.');\n    });\n  }\n\n  _hasBeenInitialized = true;\n\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document as (typeof WINDOW)['document'] | undefined;\n\n  registerSpanErrorInstrumentation();\n\n  const {\n    enableInp,\n    enableLongTask,\n    enableLongAnimationFrame,\n    _experiments: { enableInteractions, enableStandaloneClsSpans },\n    beforeStartSpan,\n    idleTimeout,\n    finalTimeout,\n    childSpanTimeout,\n    markBackgroundSpan,\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    instrumentPageLoad,\n    instrumentNavigation,\n    linkPreviousTrace,\n    onRequestSpanStart,\n  } = {\n    ...DEFAULT_BROWSER_TRACING_OPTIONS,\n    ..._options,\n  };\n\n  const _collectWebVitals = startTrackingWebVitals({ recordClsStandaloneSpans: enableStandaloneClsSpans || false });\n\n  if (enableInp) {\n    startTrackingINP();\n  }\n\n  if (\n    enableLongAnimationFrame &&\n    GLOBAL_OBJ.PerformanceObserver &&\n    PerformanceObserver.supportedEntryTypes &&\n    PerformanceObserver.supportedEntryTypes.includes('long-animation-frame')\n  ) {\n    startTrackingLongAnimationFrames();\n  } else if (enableLongTask) {\n    startTrackingLongTasks();\n  }\n\n  if (enableInteractions) {\n    startTrackingInteractions();\n  }\n\n  const latestRoute: RouteInfo = {\n    name: undefined,\n    source: undefined,\n  };\n\n  /** Create routing idle transaction. */\n  function _createRouteSpan(client: Client, startSpanOptions: StartSpanOptions): void {\n    const isPageloadTransaction = startSpanOptions.op === 'pageload';\n\n    const finalStartSpanOptions: StartSpanOptions = beforeStartSpan\n      ? beforeStartSpan(startSpanOptions)\n      : startSpanOptions;\n\n    const attributes = finalStartSpanOptions.attributes || {};\n\n    // If `finalStartSpanOptions.name` is different than `startSpanOptions.name`\n    // it is because `beforeStartSpan` set a custom name. Therefore we set the source to 'custom'.\n    if (startSpanOptions.name !== finalStartSpanOptions.name) {\n      attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'custom';\n      finalStartSpanOptions.attributes = attributes;\n    }\n\n    latestRoute.name = finalStartSpanOptions.name;\n    latestRoute.source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    const idleSpan = startIdleSpan(finalStartSpanOptions, {\n      idleTimeout,\n      finalTimeout,\n      childSpanTimeout,\n      // should wait for finish signal if it's a pageload transaction\n      disableAutoFinish: isPageloadTransaction,\n      beforeSpanEnd: span => {\n        _collectWebVitals();\n        addPerformanceEntries(span, { recordClsOnPageloadSpan: !enableStandaloneClsSpans });\n        setActiveIdleSpan(client, undefined);\n\n        // A trace should stay consistent over the entire timespan of one route - even after the pageload/navigation ended.\n        // Only when another navigation happens, we want to create a new trace.\n        // This way, e.g. errors that occur after the pageload span ended are still associated to the pageload trace.\n        const scope = getCurrentScope();\n        const oldPropagationContext = scope.getPropagationContext();\n\n        scope.setPropagationContext({\n          ...oldPropagationContext,\n          traceId: idleSpan.spanContext().traceId,\n          sampled: spanIsSampled(idleSpan),\n          dsc: getDynamicSamplingContextFromSpan(span),\n        });\n      },\n    });\n    setActiveIdleSpan(client, idleSpan);\n\n    function emitFinish(): void {\n      if (optionalWindowDocument && ['interactive', 'complete'].includes(optionalWindowDocument.readyState)) {\n        client.emit('idleSpanEnableAutoFinish', idleSpan);\n      }\n    }\n\n    if (isPageloadTransaction && optionalWindowDocument) {\n      optionalWindowDocument.addEventListener('readystatechange', () => {\n        emitFinish();\n      });\n\n      emitFinish();\n    }\n  }\n\n  return {\n    name: BROWSER_TRACING_INTEGRATION_ID,\n    afterAllSetup(client) {\n      let startingUrl: string | undefined = getLocationHref();\n\n      function maybeEndActiveSpan(): void {\n        const activeSpan = getActiveIdleSpan(client);\n\n        if (activeSpan && !spanToJSON(activeSpan).timestamp) {\n          DEBUG_BUILD && logger.log(`[Tracing] Finishing current active span with op: ${spanToJSON(activeSpan).op}`);\n          // If there's an open active span, we need to finish it before creating an new one.\n          activeSpan.end();\n        }\n      }\n\n      client.on('startNavigationSpan', startSpanOptions => {\n        if (getClient() !== client) {\n          return;\n        }\n\n        maybeEndActiveSpan();\n\n        getIsolationScope().setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });\n        getCurrentScope().setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });\n\n        _createRouteSpan(client, {\n          op: 'navigation',\n          ...startSpanOptions,\n        });\n      });\n\n      client.on('startPageLoadSpan', (startSpanOptions, traceOptions = {}) => {\n        if (getClient() !== client) {\n          return;\n        }\n        maybeEndActiveSpan();\n\n        const sentryTrace = traceOptions.sentryTrace || getMetaContent('sentry-trace');\n        const baggage = traceOptions.baggage || getMetaContent('baggage');\n\n        const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n        getCurrentScope().setPropagationContext(propagationContext);\n\n        _createRouteSpan(client, {\n          op: 'pageload',\n          ...startSpanOptions,\n        });\n      });\n\n      if (linkPreviousTrace !== 'off') {\n        let inMemoryPreviousTraceInfo: PreviousTraceInfo | undefined = undefined;\n\n        client.on('spanStart', span => {\n          if (getRootSpan(span) !== span) {\n            return;\n          }\n\n          if (linkPreviousTrace === 'session-storage') {\n            const updatedPreviousTraceInfo = addPreviousTraceSpanLink(getPreviousTraceFromSessionStorage(), span);\n            storePreviousTraceInSessionStorage(updatedPreviousTraceInfo);\n          } else {\n            inMemoryPreviousTraceInfo = addPreviousTraceSpanLink(inMemoryPreviousTraceInfo, span);\n          }\n        });\n      }\n\n      if (WINDOW.location) {\n        if (instrumentPageLoad) {\n          const origin = browserPerformanceTimeOrigin();\n          startBrowserTracingPageLoadSpan(client, {\n            name: WINDOW.location.pathname,\n            // pageload should always start at timeOrigin (and needs to be in s, not ms)\n            startTime: origin ? origin / 1000 : undefined,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.browser',\n            },\n          });\n        }\n\n        if (instrumentNavigation) {\n          addHistoryInstrumentationHandler(({ to, from }) => {\n            /**\n             * This early return is there to account for some cases where a navigation transaction starts right after\n             * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n             * create an uneccessary navigation transaction.\n             *\n             * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n             * only be caused in certain development environments where the usage of a hot module reloader is causing\n             * errors.\n             */\n            if (from === undefined && startingUrl?.indexOf(to) !== -1) {\n              startingUrl = undefined;\n              return;\n            }\n\n            if (from !== to) {\n              startingUrl = undefined;\n              startBrowserTracingNavigationSpan(client, {\n                name: WINDOW.location.pathname,\n                attributes: {\n                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.browser',\n                },\n              });\n            }\n          });\n        }\n      }\n\n      if (markBackgroundSpan) {\n        registerBackgroundTabDetection();\n      }\n\n      if (enableInteractions) {\n        registerInteractionListener(client, idleTimeout, finalTimeout, childSpanTimeout, latestRoute);\n      }\n\n      if (enableInp) {\n        registerInpInteractionListener();\n      }\n\n      instrumentOutgoingRequests(client, {\n        traceFetch,\n        traceXHR,\n        trackFetchStreamPerformance,\n        tracePropagationTargets: client.getOptions().tracePropagationTargets,\n        shouldCreateSpanForRequest,\n        enableHTTPTimings,\n        onRequestSpanStart,\n      });\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Manually start a page load span.\n * This will only do something if a browser tracing integration integration has been setup.\n *\n * If you provide a custom `traceOptions` object, it will be used to continue the trace\n * instead of the default behavior, which is to look it up on the <meta> tags.\n */\nexport function startBrowserTracingPageLoadSpan(\n  client: Client,\n  spanOptions: StartSpanOptions,\n  traceOptions?: { sentryTrace?: string | undefined; baggage?: string | undefined },\n): Span | undefined {\n  client.emit('startPageLoadSpan', spanOptions, traceOptions);\n  getCurrentScope().setTransactionName(spanOptions.name);\n\n  return getActiveIdleSpan(client);\n}\n\n/**\n * Manually start a navigation span.\n * This will only do something if a browser tracing integration has been setup.\n */\nexport function startBrowserTracingNavigationSpan(client: Client, spanOptions: StartSpanOptions): Span | undefined {\n  client.emit('startNavigationSpan', spanOptions);\n\n  getCurrentScope().setTransactionName(spanOptions.name);\n\n  return getActiveIdleSpan(client);\n}\n\n/** Returns the value of a meta tag */\nexport function getMetaContent(metaName: string): string | undefined {\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document as (typeof WINDOW)['document'] | undefined;\n\n  const metaTag = optionalWindowDocument?.querySelector(`meta[name=${metaName}]`);\n  return metaTag?.getAttribute('content') || undefined;\n}\n\n/** Start listener for interaction transactions */\nfunction registerInteractionListener(\n  client: Client,\n  idleTimeout: BrowserTracingOptions['idleTimeout'],\n  finalTimeout: BrowserTracingOptions['finalTimeout'],\n  childSpanTimeout: BrowserTracingOptions['childSpanTimeout'],\n  latestRoute: RouteInfo,\n): void {\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document as (typeof WINDOW)['document'] | undefined;\n\n  let inflightInteractionSpan: Span | undefined;\n  const registerInteractionTransaction = (): void => {\n    const op = 'ui.action.click';\n\n    const activeIdleSpan = getActiveIdleSpan(client);\n    if (activeIdleSpan) {\n      const currentRootSpanOp = spanToJSON(activeIdleSpan).op;\n      if (['navigation', 'pageload'].includes(currentRootSpanOp as string)) {\n        DEBUG_BUILD &&\n          logger.warn(`[Tracing] Did not create ${op} span because a pageload or navigation span is in progress.`);\n        return undefined;\n      }\n    }\n\n    if (inflightInteractionSpan) {\n      inflightInteractionSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, 'interactionInterrupted');\n      inflightInteractionSpan.end();\n      inflightInteractionSpan = undefined;\n    }\n\n    if (!latestRoute.name) {\n      DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n      return undefined;\n    }\n\n    inflightInteractionSpan = startIdleSpan(\n      {\n        name: latestRoute.name,\n        op,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: latestRoute.source || 'url',\n        },\n      },\n      {\n        idleTimeout,\n        finalTimeout,\n        childSpanTimeout,\n      },\n    );\n  };\n\n  if (optionalWindowDocument) {\n    addEventListener('click', registerInteractionTransaction, { once: false, capture: true });\n  }\n}\n\n// We store the active idle span on the client object, so we can access it from exported functions\nconst ACTIVE_IDLE_SPAN_PROPERTY = '_sentry_idleSpan';\nfunction getActiveIdleSpan(client: Client): Span | undefined {\n  return (client as { [ACTIVE_IDLE_SPAN_PROPERTY]?: Span })[ACTIVE_IDLE_SPAN_PROPERTY];\n}\n\nfunction setActiveIdleSpan(client: Client, span: Span | undefined): void {\n  addNonEnumerableProperty(client, ACTIVE_IDLE_SPAN_PROPERTY, span);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}