{"ast":null,"code":"import { getInteractionCount } from './polyfills/interactionCountPolyfill.js';\n\n/*\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// A list of longest interactions on the page (by latency) sorted so the\n// longest one is first. The list is at most MAX_INTERACTIONS_TO_CONSIDER long.\nconst longestInteractionList = [];\n\n// A mapping of longest interactions by their interaction ID.\n// This is used for faster lookup.\nconst longestInteractionMap = new Map();\n\n// The default `durationThreshold` used across this library for observing\n// `event` entries via PerformanceObserver.\nconst DEFAULT_DURATION_THRESHOLD = 40;\n\n// Used to store the interaction count after a bfcache restore, since p98\n// interaction latencies should only consider the current navigation.\nlet prevInteractionCount = 0;\n\n/**\n * Returns the interaction count since the last bfcache restore (or for the\n * full page lifecycle if there were no bfcache restores).\n */\nconst getInteractionCountForNavigation = () => {\n  return getInteractionCount() - prevInteractionCount;\n};\n\n/**\n * Returns the estimated p98 longest interaction based on the stored\n * interaction candidates and the interaction count for the current page.\n */\nconst estimateP98LongestInteraction = () => {\n  const candidateInteractionIndex = Math.min(longestInteractionList.length - 1, Math.floor(getInteractionCountForNavigation() / 50));\n  return longestInteractionList[candidateInteractionIndex];\n};\n\n// To prevent unnecessary memory usage on pages with lots of interactions,\n// store at most 10 of the longest interactions to consider as INP candidates.\nconst MAX_INTERACTIONS_TO_CONSIDER = 10;\n\n/**\n * A list of callback functions to run before each entry is processed.\n * Exposing this list allows the attribution build to hook into the\n * entry processing pipeline.\n */\nconst entryPreProcessingCallbacks = [];\n\n/**\n * Takes a performance entry and adds it to the list of worst interactions\n * if its duration is long enough to make it among the worst. If the\n * entry is part of an existing interaction, it is merged and the latency\n * and entries list is updated as needed.\n */\nconst processInteractionEntry = entry => {\n  entryPreProcessingCallbacks.forEach(cb => cb(entry));\n\n  // Skip further processing for entries that cannot be INP candidates.\n  if (!(entry.interactionId || entry.entryType === 'first-input')) return;\n\n  // The least-long of the 10 longest interactions.\n  const minLongestInteraction = longestInteractionList[longestInteractionList.length - 1];\n  const existingInteraction = longestInteractionMap.get(entry.interactionId);\n\n  // Only process the entry if it's possibly one of the ten longest,\n  // or if it's part of an existing interaction.\n  if (existingInteraction || longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER || minLongestInteraction && entry.duration > minLongestInteraction.latency) {\n    // If the interaction already exists, update it. Otherwise create one.\n    if (existingInteraction) {\n      // If the new entry has a longer duration, replace the old entries,\n      // otherwise add to the array.\n      if (entry.duration > existingInteraction.latency) {\n        existingInteraction.entries = [entry];\n        existingInteraction.latency = entry.duration;\n      } else if (entry.duration === existingInteraction.latency && entry.startTime === existingInteraction.entries[0]?.startTime) {\n        existingInteraction.entries.push(entry);\n      }\n    } else {\n      const interaction = {\n        id: entry.interactionId,\n        latency: entry.duration,\n        entries: [entry]\n      };\n      longestInteractionMap.set(interaction.id, interaction);\n      longestInteractionList.push(interaction);\n    }\n\n    // Sort the entries by latency (descending) and keep only the top ten.\n    longestInteractionList.sort((a, b) => b.latency - a.latency);\n    if (longestInteractionList.length > MAX_INTERACTIONS_TO_CONSIDER) {\n      longestInteractionList.splice(MAX_INTERACTIONS_TO_CONSIDER).forEach(i => longestInteractionMap.delete(i.id));\n    }\n  }\n};\nexport { DEFAULT_DURATION_THRESHOLD, entryPreProcessingCallbacks, estimateP98LongestInteraction, longestInteractionList, longestInteractionMap, processInteractionEntry };","map":{"version":3,"names":["longestInteractionList","longestInteractionMap","Map","DEFAULT_DURATION_THRESHOLD","prevInteractionCount","getInteractionCountForNavigation","getInteractionCount","estimateP98LongestInteraction","candidateInteractionIndex","Math","min","length","floor","MAX_INTERACTIONS_TO_CONSIDER","entryPreProcessingCallbacks","processInteractionEntry","entry","forEach","cb","interactionId","entryType","minLongestInteraction","existingInteraction","get","duration","latency","entries","startTime","push","interaction","id","set","sort","a","b","splice","i","delete"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\browser-utils\\src\\metrics\\web-vitals\\lib\\interactions.ts"],"sourcesContent":["/*\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInteractionCount } from './polyfills/interactionCountPolyfill';\n\ninterface Interaction {\n  id: number;\n  latency: number;\n  entries: PerformanceEventTiming[];\n}\n\ninterface EntryPreProcessingHook {\n  (entry: PerformanceEventTiming): void;\n}\n\n// A list of longest interactions on the page (by latency) sorted so the\n// longest one is first. The list is at most MAX_INTERACTIONS_TO_CONSIDER long.\nexport const longestInteractionList: Interaction[] = [];\n\n// A mapping of longest interactions by their interaction ID.\n// This is used for faster lookup.\nexport const longestInteractionMap: Map<number, Interaction> = new Map();\n\n// The default `durationThreshold` used across this library for observing\n// `event` entries via PerformanceObserver.\nexport const DEFAULT_DURATION_THRESHOLD = 40;\n\n// Used to store the interaction count after a bfcache restore, since p98\n// interaction latencies should only consider the current navigation.\nlet prevInteractionCount = 0;\n\n/**\n * Returns the interaction count since the last bfcache restore (or for the\n * full page lifecycle if there were no bfcache restores).\n */\nconst getInteractionCountForNavigation = () => {\n  return getInteractionCount() - prevInteractionCount;\n};\n\nexport const resetInteractions = () => {\n  prevInteractionCount = getInteractionCount();\n  longestInteractionList.length = 0;\n  longestInteractionMap.clear();\n};\n\n/**\n * Returns the estimated p98 longest interaction based on the stored\n * interaction candidates and the interaction count for the current page.\n */\nexport const estimateP98LongestInteraction = () => {\n  const candidateInteractionIndex = Math.min(\n    longestInteractionList.length - 1,\n    Math.floor(getInteractionCountForNavigation() / 50),\n  );\n\n  return longestInteractionList[candidateInteractionIndex];\n};\n\n// To prevent unnecessary memory usage on pages with lots of interactions,\n// store at most 10 of the longest interactions to consider as INP candidates.\nconst MAX_INTERACTIONS_TO_CONSIDER = 10;\n\n/**\n * A list of callback functions to run before each entry is processed.\n * Exposing this list allows the attribution build to hook into the\n * entry processing pipeline.\n */\nexport const entryPreProcessingCallbacks: EntryPreProcessingHook[] = [];\n\n/**\n * Takes a performance entry and adds it to the list of worst interactions\n * if its duration is long enough to make it among the worst. If the\n * entry is part of an existing interaction, it is merged and the latency\n * and entries list is updated as needed.\n */\nexport const processInteractionEntry = (entry: PerformanceEventTiming) => {\n  entryPreProcessingCallbacks.forEach(cb => cb(entry));\n\n  // Skip further processing for entries that cannot be INP candidates.\n  if (!(entry.interactionId || entry.entryType === 'first-input')) return;\n\n  // The least-long of the 10 longest interactions.\n  const minLongestInteraction = longestInteractionList[longestInteractionList.length - 1];\n\n  const existingInteraction = longestInteractionMap.get(entry.interactionId!);\n\n  // Only process the entry if it's possibly one of the ten longest,\n  // or if it's part of an existing interaction.\n  if (\n    existingInteraction ||\n    longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER ||\n    (minLongestInteraction && entry.duration > minLongestInteraction.latency)\n  ) {\n    // If the interaction already exists, update it. Otherwise create one.\n    if (existingInteraction) {\n      // If the new entry has a longer duration, replace the old entries,\n      // otherwise add to the array.\n      if (entry.duration > existingInteraction.latency) {\n        existingInteraction.entries = [entry];\n        existingInteraction.latency = entry.duration;\n      } else if (\n        entry.duration === existingInteraction.latency &&\n        entry.startTime === existingInteraction.entries[0]?.startTime\n      ) {\n        existingInteraction.entries.push(entry);\n      }\n    } else {\n      const interaction = {\n        id: entry.interactionId!,\n        latency: entry.duration,\n        entries: [entry],\n      };\n      longestInteractionMap.set(interaction.id, interaction);\n      longestInteractionList.push(interaction);\n    }\n\n    // Sort the entries by latency (descending) and keep only the top ten.\n    longestInteractionList.sort((a, b) => b.latency - a.latency);\n    if (longestInteractionList.length > MAX_INTERACTIONS_TO_CONSIDER) {\n      longestInteractionList.splice(MAX_INTERACTIONS_TO_CONSIDER).forEach(i => longestInteractionMap.delete(i.id));\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}