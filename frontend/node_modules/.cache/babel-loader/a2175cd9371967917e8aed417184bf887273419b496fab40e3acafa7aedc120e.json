{"ast":null,"code":"import { getClient, getCurrentScope } from '../currentScopes.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { createSpanEnvelope } from '../envelope.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME, SEMANTIC_ATTRIBUTE_PROFILE_ID, SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME } from '../semanticAttributes.js';\nimport { logger } from '../utils-hoist/logger.js';\nimport { generateTraceId, generateSpanId } from '../utils-hoist/propagationContext.js';\nimport { timestampInSeconds } from '../utils-hoist/time.js';\nimport { TRACE_FLAG_SAMPLED, TRACE_FLAG_NONE, spanTimeInputToSeconds, convertSpanLinksForEnvelope, getRootSpan, getStatusMessage, spanToJSON, getSpanDescendants, spanToTransactionTraceContext } from '../utils/spanUtils.js';\nimport { getDynamicSamplingContextFromSpan } from './dynamicSamplingContext.js';\nimport { logSpanEnd } from './logSpans.js';\nimport { timedEventsToMeasurements } from './measurement.js';\nimport { getCapturedScopesOnSpan } from './utils.js';\nconst MAX_SPAN_COUNT = 1000;\n\n/**\n * Span contains all data about a span\n */\nclass SentrySpan {\n  /** Epoch timestamp in seconds when the span started. */\n\n  /** Epoch timestamp in seconds when the span ended. */\n\n  /** Internal keeper of the status */\n\n  /** The timed events added to this span. */\n\n  /** if true, treat span as a standalone span (not part of a transaction) */\n\n  /**\n   * You should never call the constructor manually, always use `Sentry.startSpan()`\n   * or other span methods.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  constructor(spanContext = {}) {\n    this._traceId = spanContext.traceId || generateTraceId();\n    this._spanId = spanContext.spanId || generateSpanId();\n    this._startTime = spanContext.startTimestamp || timestampInSeconds();\n    this._links = spanContext.links;\n    this._attributes = {};\n    this.setAttributes({\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'manual',\n      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,\n      ...spanContext.attributes\n    });\n    this._name = spanContext.name;\n    if (spanContext.parentSpanId) {\n      this._parentSpanId = spanContext.parentSpanId;\n    }\n    // We want to include booleans as well here\n    if ('sampled' in spanContext) {\n      this._sampled = spanContext.sampled;\n    }\n    if (spanContext.endTimestamp) {\n      this._endTime = spanContext.endTimestamp;\n    }\n    this._events = [];\n    this._isStandaloneSpan = spanContext.isStandalone;\n\n    // If the span is already ended, ensure we finalize the span immediately\n    if (this._endTime) {\n      this._onSpanEnded();\n    }\n  }\n\n  /** @inheritDoc */\n  addLink(link) {\n    if (this._links) {\n      this._links.push(link);\n    } else {\n      this._links = [link];\n    }\n    return this;\n  }\n\n  /** @inheritDoc */\n  addLinks(links) {\n    if (this._links) {\n      this._links.push(...links);\n    } else {\n      this._links = links;\n    }\n    return this;\n  }\n\n  /**\n   * This should generally not be used,\n   * but it is needed for being compliant with the OTEL Span interface.\n   *\n   * @hidden\n   * @internal\n   */\n  recordException(_exception, _time) {\n    // noop\n  }\n\n  /** @inheritdoc */\n  spanContext() {\n    const {\n      _spanId: spanId,\n      _traceId: traceId,\n      _sampled: sampled\n    } = this;\n    return {\n      spanId,\n      traceId,\n      traceFlags: sampled ? TRACE_FLAG_SAMPLED : TRACE_FLAG_NONE\n    };\n  }\n\n  /** @inheritdoc */\n  setAttribute(key, value) {\n    if (value === undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._attributes[key];\n    } else {\n      this._attributes[key] = value;\n    }\n    return this;\n  }\n\n  /** @inheritdoc */\n  setAttributes(attributes) {\n    Object.keys(attributes).forEach(key => this.setAttribute(key, attributes[key]));\n    return this;\n  }\n\n  /**\n   * This should generally not be used,\n   * but we need it for browser tracing where we want to adjust the start time afterwards.\n   * USE THIS WITH CAUTION!\n   *\n   * @hidden\n   * @internal\n   */\n  updateStartTime(timeInput) {\n    this._startTime = spanTimeInputToSeconds(timeInput);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setStatus(value) {\n    this._status = value;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateName(name) {\n    this._name = name;\n    this.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'custom');\n    return this;\n  }\n\n  /** @inheritdoc */\n  end(endTimestamp) {\n    // If already ended, skip\n    if (this._endTime) {\n      return;\n    }\n    this._endTime = spanTimeInputToSeconds(endTimestamp);\n    logSpanEnd(this);\n    this._onSpanEnded();\n  }\n\n  /**\n   * Get JSON representation of this span.\n   *\n   * @hidden\n   * @internal This method is purely for internal purposes and should not be used outside\n   * of SDK code. If you need to get a JSON representation of a span,\n   * use `spanToJSON(span)` instead.\n   */\n  getSpanJSON() {\n    return {\n      data: this._attributes,\n      description: this._name,\n      op: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],\n      parent_span_id: this._parentSpanId,\n      span_id: this._spanId,\n      start_timestamp: this._startTime,\n      status: getStatusMessage(this._status),\n      timestamp: this._endTime,\n      trace_id: this._traceId,\n      origin: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],\n      profile_id: this._attributes[SEMANTIC_ATTRIBUTE_PROFILE_ID],\n      exclusive_time: this._attributes[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME],\n      measurements: timedEventsToMeasurements(this._events),\n      is_segment: this._isStandaloneSpan && getRootSpan(this) === this || undefined,\n      segment_id: this._isStandaloneSpan ? getRootSpan(this).spanContext().spanId : undefined,\n      links: convertSpanLinksForEnvelope(this._links)\n    };\n  }\n\n  /** @inheritdoc */\n  isRecording() {\n    return !this._endTime && !!this._sampled;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  addEvent(name, attributesOrStartTime, startTime) {\n    DEBUG_BUILD && logger.log('[Tracing] Adding an event to span:', name);\n    const time = isSpanTimeInput(attributesOrStartTime) ? attributesOrStartTime : startTime || timestampInSeconds();\n    const attributes = isSpanTimeInput(attributesOrStartTime) ? {} : attributesOrStartTime || {};\n    const event = {\n      name,\n      time: spanTimeInputToSeconds(time),\n      attributes\n    };\n    this._events.push(event);\n    return this;\n  }\n\n  /**\n   * This method should generally not be used,\n   * but for now we need a way to publicly check if the `_isStandaloneSpan` flag is set.\n   * USE THIS WITH CAUTION!\n   * @internal\n   * @hidden\n   * @experimental\n   */\n  isStandaloneSpan() {\n    return !!this._isStandaloneSpan;\n  }\n\n  /** Emit `spanEnd` when the span is ended. */\n  _onSpanEnded() {\n    const client = getClient();\n    if (client) {\n      client.emit('spanEnd', this);\n    }\n\n    // A segment span is basically the root span of a local span tree.\n    // So for now, this is either what we previously refer to as the root span,\n    // or a standalone span.\n    const isSegmentSpan = this._isStandaloneSpan || this === getRootSpan(this);\n    if (!isSegmentSpan) {\n      return;\n    }\n\n    // if this is a standalone span, we send it immediately\n    if (this._isStandaloneSpan) {\n      if (this._sampled) {\n        sendSpanEnvelope(createSpanEnvelope([this], client));\n      } else {\n        DEBUG_BUILD && logger.log('[Tracing] Discarding standalone span because its trace was not chosen to be sampled.');\n        if (client) {\n          client.recordDroppedEvent('sample_rate', 'span');\n        }\n      }\n      return;\n    }\n    const transactionEvent = this._convertSpanToTransaction();\n    if (transactionEvent) {\n      const scope = getCapturedScopesOnSpan(this).scope || getCurrentScope();\n      scope.captureEvent(transactionEvent);\n    }\n  }\n\n  /**\n   * Finish the transaction & prepare the event to send to Sentry.\n   */\n  _convertSpanToTransaction() {\n    // We can only convert finished spans\n    if (!isFullFinishedSpan(spanToJSON(this))) {\n      return undefined;\n    }\n    if (!this._name) {\n      DEBUG_BUILD && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this._name = '<unlabeled transaction>';\n    }\n    const {\n      scope: capturedSpanScope,\n      isolationScope: capturedSpanIsolationScope\n    } = getCapturedScopesOnSpan(this);\n    if (this._sampled !== true) {\n      return undefined;\n    }\n\n    // The transaction span itself as well as any potential standalone spans should be filtered out\n    const finishedSpans = getSpanDescendants(this).filter(span => span !== this && !isStandaloneSpan(span));\n    const spans = finishedSpans.map(span => spanToJSON(span)).filter(isFullFinishedSpan);\n    const source = this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    // remove internal root span attributes we don't need to send.\n    /* eslint-disable @typescript-eslint/no-dynamic-delete */\n    delete this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n    spans.forEach(span => {\n      delete span.data[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n    });\n    // eslint-enabled-next-line @typescript-eslint/no-dynamic-delete\n\n    const transaction = {\n      contexts: {\n        trace: spanToTransactionTraceContext(this)\n      },\n      spans:\n      // spans.sort() mutates the array, but `spans` is already a copy so we can safely do this here\n      // we do not use spans anymore after this point\n      spans.length > MAX_SPAN_COUNT ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT) : spans,\n      start_timestamp: this._startTime,\n      timestamp: this._endTime,\n      transaction: this._name,\n      type: 'transaction',\n      sdkProcessingMetadata: {\n        capturedSpanScope,\n        capturedSpanIsolationScope,\n        dynamicSamplingContext: getDynamicSamplingContextFromSpan(this)\n      },\n      ...(source && {\n        transaction_info: {\n          source\n        }\n      })\n    };\n    const measurements = timedEventsToMeasurements(this._events);\n    const hasMeasurements = measurements && Object.keys(measurements).length;\n    if (hasMeasurements) {\n      DEBUG_BUILD && logger.log('[Measurements] Adding measurements to transaction event', JSON.stringify(measurements, undefined, 2));\n      transaction.measurements = measurements;\n    }\n    return transaction;\n  }\n}\nfunction isSpanTimeInput(value) {\n  return value && typeof value === 'number' || value instanceof Date || Array.isArray(value);\n}\n\n// We want to filter out any incomplete SpanJSON objects\nfunction isFullFinishedSpan(input) {\n  return !!input.start_timestamp && !!input.timestamp && !!input.span_id && !!input.trace_id;\n}\n\n/** `SentrySpan`s can be sent as a standalone span rather than belonging to a transaction */\nfunction isStandaloneSpan(span) {\n  return span instanceof SentrySpan && span.isStandaloneSpan();\n}\n\n/**\n * Sends a `SpanEnvelope`.\n *\n * Note: If the envelope's spans are dropped, e.g. via `beforeSendSpan`,\n * the envelope will not be sent either.\n */\nfunction sendSpanEnvelope(envelope) {\n  const client = getClient();\n  if (!client) {\n    return;\n  }\n  const spanItems = envelope[1];\n  if (!spanItems || spanItems.length === 0) {\n    client.recordDroppedEvent('before_send', 'span');\n    return;\n  }\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\nexport { SentrySpan };","map":{"version":3,"names":["MAX_SPAN_COUNT","SentrySpan","constructor","spanContext","_traceId","traceId","generateTraceId","_spanId","spanId","generateSpanId","_startTime","startTimestamp","timestampInSeconds","_links","links","_attributes","setAttributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","op","attributes","_name","name","parentSpanId","_parentSpanId","_sampled","sampled","endTimestamp","_endTime","_events","_isStandaloneSpan","isStandalone","_onSpanEnded","addLink","link","push","addLinks","recordException","_exception","_time","traceFlags","TRACE_FLAG_SAMPLED","TRACE_FLAG_NONE","setAttribute","key","value","undefined","Object","keys","forEach","updateStartTime","timeInput","spanTimeInputToSeconds","setStatus","_status","updateName","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","end","logSpanEnd","getSpanJSON","data","description","parent_span_id","span_id","start_timestamp","status","getStatusMessage","timestamp","trace_id","origin","profile_id","SEMANTIC_ATTRIBUTE_PROFILE_ID","exclusive_time","SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME","measurements","timedEventsToMeasurements","is_segment","getRootSpan","segment_id","convertSpanLinksForEnvelope","isRecording","addEvent","attributesOrStartTime","startTime","DEBUG_BUILD","logger","log","time","isSpanTimeInput","event","isStandaloneSpan","client","getClient","emit","isSegmentSpan","sendSpanEnvelope","createSpanEnvelope","recordDroppedEvent","transactionEvent","_convertSpanToTransaction","scope","getCapturedScopesOnSpan","getCurrentScope","captureEvent","isFullFinishedSpan","spanToJSON","warn","capturedSpanScope","isolationScope","capturedSpanIsolationScope","finishedSpans","getSpanDescendants","filter","span","spans","map","source","SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME","transaction","contexts","trace","spanToTransactionTraceContext","length","sort","a","b","slice","type","sdkProcessingMetadata","dynamicSamplingContext","getDynamicSamplingContextFromSpan","transaction_info","hasMeasurements","JSON","stringify","Date","Array","isArray","input","envelope","spanItems","sendEnvelope"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry\\core\\src\\tracing\\sentrySpan.ts"],"sourcesContent":["import { getClient, getCurrentScope } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { createSpanEnvelope } from '../envelope';\nimport {\n  SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME,\n  SEMANTIC_ATTRIBUTE_PROFILE_ID,\n  SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n} from '../semanticAttributes';\nimport type {\n  SentrySpanArguments,\n  Span,\n  SpanAttributeValue,\n  SpanAttributes,\n  SpanContextData,\n  SpanEnvelope,\n  SpanJSON,\n  SpanOrigin,\n  SpanStatus,\n  SpanTimeInput,\n  TimedEvent,\n  TransactionEvent,\n  TransactionSource,\n} from '../types-hoist';\nimport type { SpanLink } from '../types-hoist/link';\nimport { logger } from '../utils-hoist/logger';\nimport { generateSpanId, generateTraceId } from '../utils-hoist/propagationContext';\nimport { timestampInSeconds } from '../utils-hoist/time';\nimport {\n  TRACE_FLAG_NONE,\n  TRACE_FLAG_SAMPLED,\n  convertSpanLinksForEnvelope,\n  getRootSpan,\n  getSpanDescendants,\n  getStatusMessage,\n  spanTimeInputToSeconds,\n  spanToJSON,\n  spanToTransactionTraceContext,\n} from '../utils/spanUtils';\nimport { getDynamicSamplingContextFromSpan } from './dynamicSamplingContext';\nimport { logSpanEnd } from './logSpans';\nimport { timedEventsToMeasurements } from './measurement';\nimport { getCapturedScopesOnSpan } from './utils';\n\nconst MAX_SPAN_COUNT = 1000;\n\n/**\n * Span contains all data about a span\n */\nexport class SentrySpan implements Span {\n  protected _traceId: string;\n  protected _spanId: string;\n  protected _parentSpanId?: string | undefined;\n  protected _sampled: boolean | undefined;\n  protected _name?: string | undefined;\n  protected _attributes: SpanAttributes;\n  protected _links?: SpanLink[];\n  /** Epoch timestamp in seconds when the span started. */\n  protected _startTime: number;\n  /** Epoch timestamp in seconds when the span ended. */\n  protected _endTime?: number | undefined;\n  /** Internal keeper of the status */\n  protected _status?: SpanStatus;\n  /** The timed events added to this span. */\n  protected _events: TimedEvent[];\n\n  /** if true, treat span as a standalone span (not part of a transaction) */\n  private _isStandaloneSpan?: boolean;\n\n  /**\n   * You should never call the constructor manually, always use `Sentry.startSpan()`\n   * or other span methods.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  public constructor(spanContext: SentrySpanArguments = {}) {\n    this._traceId = spanContext.traceId || generateTraceId();\n    this._spanId = spanContext.spanId || generateSpanId();\n    this._startTime = spanContext.startTimestamp || timestampInSeconds();\n    this._links = spanContext.links;\n\n    this._attributes = {};\n    this.setAttributes({\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'manual',\n      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,\n      ...spanContext.attributes,\n    });\n\n    this._name = spanContext.name;\n\n    if (spanContext.parentSpanId) {\n      this._parentSpanId = spanContext.parentSpanId;\n    }\n    // We want to include booleans as well here\n    if ('sampled' in spanContext) {\n      this._sampled = spanContext.sampled;\n    }\n    if (spanContext.endTimestamp) {\n      this._endTime = spanContext.endTimestamp;\n    }\n\n    this._events = [];\n\n    this._isStandaloneSpan = spanContext.isStandalone;\n\n    // If the span is already ended, ensure we finalize the span immediately\n    if (this._endTime) {\n      this._onSpanEnded();\n    }\n  }\n\n  /** @inheritDoc */\n  public addLink(link: SpanLink): this {\n    if (this._links) {\n      this._links.push(link);\n    } else {\n      this._links = [link];\n    }\n    return this;\n  }\n\n  /** @inheritDoc */\n  public addLinks(links: SpanLink[]): this {\n    if (this._links) {\n      this._links.push(...links);\n    } else {\n      this._links = links;\n    }\n    return this;\n  }\n\n  /**\n   * This should generally not be used,\n   * but it is needed for being compliant with the OTEL Span interface.\n   *\n   * @hidden\n   * @internal\n   */\n  public recordException(_exception: unknown, _time?: number | undefined): void {\n    // noop\n  }\n\n  /** @inheritdoc */\n  public spanContext(): SpanContextData {\n    const { _spanId: spanId, _traceId: traceId, _sampled: sampled } = this;\n    return {\n      spanId,\n      traceId,\n      traceFlags: sampled ? TRACE_FLAG_SAMPLED : TRACE_FLAG_NONE,\n    };\n  }\n\n  /** @inheritdoc */\n  public setAttribute(key: string, value: SpanAttributeValue | undefined): this {\n    if (value === undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._attributes[key];\n    } else {\n      this._attributes[key] = value;\n    }\n\n    return this;\n  }\n\n  /** @inheritdoc */\n  public setAttributes(attributes: SpanAttributes): this {\n    Object.keys(attributes).forEach(key => this.setAttribute(key, attributes[key]));\n    return this;\n  }\n\n  /**\n   * This should generally not be used,\n   * but we need it for browser tracing where we want to adjust the start time afterwards.\n   * USE THIS WITH CAUTION!\n   *\n   * @hidden\n   * @internal\n   */\n  public updateStartTime(timeInput: SpanTimeInput): void {\n    this._startTime = spanTimeInputToSeconds(timeInput);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setStatus(value: SpanStatus): this {\n    this._status = value;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public updateName(name: string): this {\n    this._name = name;\n    this.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'custom');\n    return this;\n  }\n\n  /** @inheritdoc */\n  public end(endTimestamp?: SpanTimeInput): void {\n    // If already ended, skip\n    if (this._endTime) {\n      return;\n    }\n\n    this._endTime = spanTimeInputToSeconds(endTimestamp);\n    logSpanEnd(this);\n\n    this._onSpanEnded();\n  }\n\n  /**\n   * Get JSON representation of this span.\n   *\n   * @hidden\n   * @internal This method is purely for internal purposes and should not be used outside\n   * of SDK code. If you need to get a JSON representation of a span,\n   * use `spanToJSON(span)` instead.\n   */\n  public getSpanJSON(): SpanJSON {\n    return {\n      data: this._attributes,\n      description: this._name,\n      op: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],\n      parent_span_id: this._parentSpanId,\n      span_id: this._spanId,\n      start_timestamp: this._startTime,\n      status: getStatusMessage(this._status),\n      timestamp: this._endTime,\n      trace_id: this._traceId,\n      origin: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] as SpanOrigin | undefined,\n      profile_id: this._attributes[SEMANTIC_ATTRIBUTE_PROFILE_ID] as string | undefined,\n      exclusive_time: this._attributes[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME] as number | undefined,\n      measurements: timedEventsToMeasurements(this._events),\n      is_segment: (this._isStandaloneSpan && getRootSpan(this) === this) || undefined,\n      segment_id: this._isStandaloneSpan ? getRootSpan(this).spanContext().spanId : undefined,\n      links: convertSpanLinksForEnvelope(this._links),\n    };\n  }\n\n  /** @inheritdoc */\n  public isRecording(): boolean {\n    return !this._endTime && !!this._sampled;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public addEvent(\n    name: string,\n    attributesOrStartTime?: SpanAttributes | SpanTimeInput,\n    startTime?: SpanTimeInput,\n  ): this {\n    DEBUG_BUILD && logger.log('[Tracing] Adding an event to span:', name);\n\n    const time = isSpanTimeInput(attributesOrStartTime) ? attributesOrStartTime : startTime || timestampInSeconds();\n    const attributes = isSpanTimeInput(attributesOrStartTime) ? {} : attributesOrStartTime || {};\n\n    const event: TimedEvent = {\n      name,\n      time: spanTimeInputToSeconds(time),\n      attributes,\n    };\n\n    this._events.push(event);\n\n    return this;\n  }\n\n  /**\n   * This method should generally not be used,\n   * but for now we need a way to publicly check if the `_isStandaloneSpan` flag is set.\n   * USE THIS WITH CAUTION!\n   * @internal\n   * @hidden\n   * @experimental\n   */\n  public isStandaloneSpan(): boolean {\n    return !!this._isStandaloneSpan;\n  }\n\n  /** Emit `spanEnd` when the span is ended. */\n  private _onSpanEnded(): void {\n    const client = getClient();\n    if (client) {\n      client.emit('spanEnd', this);\n    }\n\n    // A segment span is basically the root span of a local span tree.\n    // So for now, this is either what we previously refer to as the root span,\n    // or a standalone span.\n    const isSegmentSpan = this._isStandaloneSpan || this === getRootSpan(this);\n\n    if (!isSegmentSpan) {\n      return;\n    }\n\n    // if this is a standalone span, we send it immediately\n    if (this._isStandaloneSpan) {\n      if (this._sampled) {\n        sendSpanEnvelope(createSpanEnvelope([this], client));\n      } else {\n        DEBUG_BUILD &&\n          logger.log('[Tracing] Discarding standalone span because its trace was not chosen to be sampled.');\n        if (client) {\n          client.recordDroppedEvent('sample_rate', 'span');\n        }\n      }\n      return;\n    }\n\n    const transactionEvent = this._convertSpanToTransaction();\n    if (transactionEvent) {\n      const scope = getCapturedScopesOnSpan(this).scope || getCurrentScope();\n      scope.captureEvent(transactionEvent);\n    }\n  }\n\n  /**\n   * Finish the transaction & prepare the event to send to Sentry.\n   */\n  private _convertSpanToTransaction(): TransactionEvent | undefined {\n    // We can only convert finished spans\n    if (!isFullFinishedSpan(spanToJSON(this))) {\n      return undefined;\n    }\n\n    if (!this._name) {\n      DEBUG_BUILD && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this._name = '<unlabeled transaction>';\n    }\n\n    const { scope: capturedSpanScope, isolationScope: capturedSpanIsolationScope } = getCapturedScopesOnSpan(this);\n\n    if (this._sampled !== true) {\n      return undefined;\n    }\n\n    // The transaction span itself as well as any potential standalone spans should be filtered out\n    const finishedSpans = getSpanDescendants(this).filter(span => span !== this && !isStandaloneSpan(span));\n\n    const spans = finishedSpans.map(span => spanToJSON(span)).filter(isFullFinishedSpan);\n\n    const source = this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] as TransactionSource | undefined;\n\n    // remove internal root span attributes we don't need to send.\n    /* eslint-disable @typescript-eslint/no-dynamic-delete */\n    delete this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n    spans.forEach(span => {\n      delete span.data[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n    });\n    // eslint-enabled-next-line @typescript-eslint/no-dynamic-delete\n\n    const transaction: TransactionEvent = {\n      contexts: {\n        trace: spanToTransactionTraceContext(this),\n      },\n      spans:\n        // spans.sort() mutates the array, but `spans` is already a copy so we can safely do this here\n        // we do not use spans anymore after this point\n        spans.length > MAX_SPAN_COUNT\n          ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n          : spans,\n      start_timestamp: this._startTime,\n      timestamp: this._endTime,\n      transaction: this._name,\n      type: 'transaction',\n      sdkProcessingMetadata: {\n        capturedSpanScope,\n        capturedSpanIsolationScope,\n        dynamicSamplingContext: getDynamicSamplingContextFromSpan(this),\n      },\n      ...(source && {\n        transaction_info: {\n          source,\n        },\n      }),\n    };\n\n    const measurements = timedEventsToMeasurements(this._events);\n    const hasMeasurements = measurements && Object.keys(measurements).length;\n\n    if (hasMeasurements) {\n      DEBUG_BUILD &&\n        logger.log(\n          '[Measurements] Adding measurements to transaction event',\n          JSON.stringify(measurements, undefined, 2),\n        );\n      transaction.measurements = measurements;\n    }\n\n    return transaction;\n  }\n}\n\nfunction isSpanTimeInput(value: undefined | SpanAttributes | SpanTimeInput): value is SpanTimeInput {\n  return (value && typeof value === 'number') || value instanceof Date || Array.isArray(value);\n}\n\n// We want to filter out any incomplete SpanJSON objects\nfunction isFullFinishedSpan(input: Partial<SpanJSON>): input is SpanJSON {\n  return !!input.start_timestamp && !!input.timestamp && !!input.span_id && !!input.trace_id;\n}\n\n/** `SentrySpan`s can be sent as a standalone span rather than belonging to a transaction */\nfunction isStandaloneSpan(span: Span): boolean {\n  return span instanceof SentrySpan && span.isStandaloneSpan();\n}\n\n/**\n * Sends a `SpanEnvelope`.\n *\n * Note: If the envelope's spans are dropped, e.g. via `beforeSendSpan`,\n * the envelope will not be sent either.\n */\nfunction sendSpanEnvelope(envelope: SpanEnvelope): void {\n  const client = getClient();\n  if (!client) {\n    return;\n  }\n\n  const spanItems = envelope[1];\n  if (!spanItems || spanItems.length === 0) {\n    client.recordDroppedEvent('before_send', 'span');\n    return;\n  }\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}