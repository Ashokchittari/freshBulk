{"ast":null,"code":"import { getCurrentScope, logger } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\n\n/**\n * Ordered LRU cache for storing feature flags in the scope context. The name\n * of each flag in the buffer is unique, and the output of getAll() is ordered\n * from oldest to newest.\n */\n\n/**\n * Max size of the LRU flag buffer stored in Sentry scope and event contexts.\n */\nconst FLAG_BUFFER_SIZE = 100;\n\n/**\n * Copies feature flags that are in current scope context to the event context\n */\nfunction copyFlagsFromScopeToEvent(event) {\n  const scope = getCurrentScope();\n  const flagContext = scope.getScopeData().contexts.flags;\n  const flagBuffer = flagContext ? flagContext.values : [];\n  if (!flagBuffer.length) {\n    return event;\n  }\n  if (event.contexts === undefined) {\n    event.contexts = {};\n  }\n  event.contexts.flags = {\n    values: [...flagBuffer]\n  };\n  return event;\n}\n\n/**\n * Creates a feature flags values array in current context if it does not exist\n * and inserts the flag into a FeatureFlag array while maintaining ordered LRU\n * properties. Not thread-safe. After inserting:\n * - `flags` is sorted in order of recency, with the newest flag at the end.\n * - No other flags with the same name exist in `flags`.\n * - The length of `flags` does not exceed `maxSize`. The oldest flag is evicted\n *  as needed.\n *\n * @param name     Name of the feature flag to insert.\n * @param value    Value of the feature flag.\n * @param maxSize  Max number of flags the buffer should store. It's recommended\n *   to keep this consistent across insertions. Default is FLAG_BUFFER_SIZE\n */\nfunction insertFlagToScope(name, value, maxSize = FLAG_BUFFER_SIZE) {\n  const scopeContexts = getCurrentScope().getScopeData().contexts;\n  if (!scopeContexts.flags) {\n    scopeContexts.flags = {\n      values: []\n    };\n  }\n  const flags = scopeContexts.flags.values;\n  insertToFlagBuffer(flags, name, value, maxSize);\n}\n\n/**\n * Exported for tests. Currently only accepts boolean values (otherwise no-op).\n */\nfunction insertToFlagBuffer(flags, name, value, maxSize) {\n  if (typeof value !== 'boolean') {\n    return;\n  }\n  if (flags.length > maxSize) {\n    DEBUG_BUILD && logger.error(`[Feature Flags] insertToFlagBuffer called on a buffer larger than maxSize=${maxSize}`);\n    return;\n  }\n\n  // Check if the flag is already in the buffer - O(n)\n  const index = flags.findIndex(f => f.flag === name);\n  if (index !== -1) {\n    // The flag was found, remove it from its current position - O(n)\n    flags.splice(index, 1);\n  }\n  if (flags.length === maxSize) {\n    // If at capacity, pop the earliest flag - O(n)\n    flags.shift();\n  }\n\n  // Push the flag to the end - O(1)\n  flags.push({\n    flag: name,\n    result: value\n  });\n}\nexport { FLAG_BUFFER_SIZE, copyFlagsFromScopeToEvent, insertFlagToScope, insertToFlagBuffer };","map":{"version":3,"names":["FLAG_BUFFER_SIZE","copyFlagsFromScopeToEvent","event","scope","getCurrentScope","flagContext","getScopeData","contexts","flags","flagBuffer","values","length","undefined","insertFlagToScope","name","value","maxSize","scopeContexts","insertToFlagBuffer","DEBUG_BUILD","logger","error","index","findIndex","f","flag","splice","shift","push","result"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry\\browser\\src\\utils\\featureFlags.ts"],"sourcesContent":["import type { Event, FeatureFlag } from '@sentry/core';\n\nimport { getCurrentScope, logger } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\n\n/**\n * Ordered LRU cache for storing feature flags in the scope context. The name\n * of each flag in the buffer is unique, and the output of getAll() is ordered\n * from oldest to newest.\n */\n\n/**\n * Max size of the LRU flag buffer stored in Sentry scope and event contexts.\n */\nexport const FLAG_BUFFER_SIZE = 100;\n\n/**\n * Copies feature flags that are in current scope context to the event context\n */\nexport function copyFlagsFromScopeToEvent(event: Event): Event {\n  const scope = getCurrentScope();\n  const flagContext = scope.getScopeData().contexts.flags;\n  const flagBuffer = flagContext ? flagContext.values : [];\n\n  if (!flagBuffer.length) {\n    return event;\n  }\n\n  if (event.contexts === undefined) {\n    event.contexts = {};\n  }\n  event.contexts.flags = { values: [...flagBuffer] };\n  return event;\n}\n\n/**\n * Creates a feature flags values array in current context if it does not exist\n * and inserts the flag into a FeatureFlag array while maintaining ordered LRU\n * properties. Not thread-safe. After inserting:\n * - `flags` is sorted in order of recency, with the newest flag at the end.\n * - No other flags with the same name exist in `flags`.\n * - The length of `flags` does not exceed `maxSize`. The oldest flag is evicted\n *  as needed.\n *\n * @param name     Name of the feature flag to insert.\n * @param value    Value of the feature flag.\n * @param maxSize  Max number of flags the buffer should store. It's recommended\n *   to keep this consistent across insertions. Default is FLAG_BUFFER_SIZE\n */\nexport function insertFlagToScope(name: string, value: unknown, maxSize: number = FLAG_BUFFER_SIZE): void {\n  const scopeContexts = getCurrentScope().getScopeData().contexts;\n  if (!scopeContexts.flags) {\n    scopeContexts.flags = { values: [] };\n  }\n  const flags = scopeContexts.flags.values as FeatureFlag[];\n  insertToFlagBuffer(flags, name, value, maxSize);\n}\n\n/**\n * Exported for tests. Currently only accepts boolean values (otherwise no-op).\n */\nexport function insertToFlagBuffer(flags: FeatureFlag[], name: string, value: unknown, maxSize: number): void {\n  if (typeof value !== 'boolean') {\n    return;\n  }\n\n  if (flags.length > maxSize) {\n    DEBUG_BUILD && logger.error(`[Feature Flags] insertToFlagBuffer called on a buffer larger than maxSize=${maxSize}`);\n    return;\n  }\n\n  // Check if the flag is already in the buffer - O(n)\n  const index = flags.findIndex(f => f.flag === name);\n\n  if (index !== -1) {\n    // The flag was found, remove it from its current position - O(n)\n    flags.splice(index, 1);\n  }\n\n  if (flags.length === maxSize) {\n    // If at capacity, pop the earliest flag - O(n)\n    flags.shift();\n  }\n\n  // Push the flag to the end - O(1)\n  flags.push({\n    flag: name,\n    result: value,\n  });\n}\n"],"mappings":";;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,MAAMA,gBAAiB,GAAE;;AAEhC;AACA;AACA;AACO,SAASC,yBAAyBA,CAACC,KAAK,EAAgB;EAC7D,MAAMC,KAAA,GAAQC,eAAe,EAAE;EAC/B,MAAMC,WAAY,GAAEF,KAAK,CAACG,YAAY,EAAE,CAACC,QAAQ,CAACC,KAAK;EACvD,MAAMC,UAAW,GAAEJ,WAAY,GAAEA,WAAW,CAACK,MAAA,GAAS,EAAE;EAExD,IAAI,CAACD,UAAU,CAACE,MAAM,EAAE;IACtB,OAAOT,KAAK;EAChB;EAEE,IAAIA,KAAK,CAACK,QAAS,KAAIK,SAAS,EAAE;IAChCV,KAAK,CAACK,QAAS,GAAE,EAAE;EACvB;EACEL,KAAK,CAACK,QAAQ,CAACC,KAAM,GAAE;IAAEE,MAAM,EAAE,CAAC,GAAGD,UAAU;EAAA,CAAG;EAClD,OAAOP,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASW,iBAAiBA,CAACC,IAAI,EAAUC,KAAK,EAAWC,OAAO,GAAWhB,gBAAgB,EAAQ;EACxG,MAAMiB,aAAc,GAAEb,eAAe,EAAE,CAACE,YAAY,EAAE,CAACC,QAAQ;EAC/D,IAAI,CAACU,aAAa,CAACT,KAAK,EAAE;IACxBS,aAAa,CAACT,KAAM,GAAE;MAAEE,MAAM,EAAE;IAAC,CAAG;EACxC;EACE,MAAMF,KAAM,GAAES,aAAa,CAACT,KAAK,CAACE,MAAO;EACzCQ,kBAAkB,CAACV,KAAK,EAAEM,IAAI,EAAEC,KAAK,EAAEC,OAAO,CAAC;AACjD;;AAEA;AACA;AACA;AACO,SAASE,kBAAkBA,CAACV,KAAK,EAAiBM,IAAI,EAAUC,KAAK,EAAWC,OAAO,EAAgB;EAC5G,IAAI,OAAOD,KAAM,KAAI,SAAS,EAAE;IAC9B;EACJ;EAEE,IAAIP,KAAK,CAACG,MAAO,GAAEK,OAAO,EAAE;IAC1BG,WAAA,IAAeC,MAAM,CAACC,KAAK,CAAC,6EAA6EL,OAAO,EAAC;IACA;EACA;;EAEA;EACA,MAAAM,KAAA,GAAAd,KAAA,CAAAe,SAAA,CAAAC,CAAA,IAAAA,CAAA,CAAAC,IAAA,KAAAX,IAAA;EAEA,IAAAQ,KAAA;IACA;IACAd,KAAA,CAAAkB,MAAA,CAAAJ,KAAA;EACA;EAEA,IAAAd,KAAA,CAAAG,MAAA,KAAAK,OAAA;IACA;IACAR,KAAA,CAAAmB,KAAA;EACA;;EAEA;EACAnB,KAAA,CAAAoB,IAAA;IACAH,IAAA,EAAAX,IAAA;IACAe,MAAA,EAAAd;EACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}