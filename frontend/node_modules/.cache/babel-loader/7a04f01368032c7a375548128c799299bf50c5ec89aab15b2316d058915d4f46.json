{"ast":null,"code":"import { GLOBAL_OBJ, normalize, fill, htmlTreeAsString, browserPerformanceTimeOrigin, logger as logger$1, severityLevelFromString, captureException, addBreadcrumb, uuid4, getClient, getLocationHref, getCurrentScope, getActiveSpan, getDynamicSamplingContextFromSpan, isSentryRequestUrl, stringMatchesSomePattern, addEventProcessor, createEnvelope, createEventEnvelopeHeaders, getSdkMetadataForEnvelopeHeader, prepareEvent, getIsolationScope, resolvedSyncPromise, updateRateLimits, isRateLimited, setContext, getRootSpan, spanToJSON, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, isBrowser, parseSampleRate, consoleSandbox } from '@sentry/core';\nimport { setTimeout as setTimeout$3, addPerformanceInstrumentationHandler, addLcpInstrumentationHandler, addClsInstrumentationHandler, addFidInstrumentationHandler, addInpInstrumentationHandler, serializeFormData, getFetchRequestArgBody, getBodyString, SENTRY_XHR_DATA_KEY, addClickKeypressInstrumentationHandler, addHistoryInstrumentationHandler } from '@sentry-internal/browser-utils';\n\n// exporting a separate copy of `WINDOW` rather than exporting the one from `@sentry/browser`\n// prevents the browser package from being bundled in the CDN bundle, and avoids a\n// circular dependency between the browser and replay packages should `@sentry/browser` import\n// from `@sentry/replay` in the future\nconst WINDOW = GLOBAL_OBJ;\nconst REPLAY_SESSION_KEY = 'sentryReplaySession';\nconst REPLAY_EVENT_NAME = 'replay_event';\nconst UNABLE_TO_SEND_REPLAY = 'Unable to send Replay';\n\n// The idle limit for a session after which recording is paused.\nconst SESSION_IDLE_PAUSE_DURATION = 300000; // 5 minutes in ms\n\n// The idle limit for a session after which the session expires.\nconst SESSION_IDLE_EXPIRE_DURATION = 900000; // 15 minutes in ms\n\n/** Default flush delays */\nconst DEFAULT_FLUSH_MIN_DELAY = 5000;\n// XXX: Temp fix for our debounce logic where `maxWait` would never occur if it\n// was the same as `wait`\nconst DEFAULT_FLUSH_MAX_DELAY = 5500;\n\n/* How long to wait for error checkouts */\nconst BUFFER_CHECKOUT_TIME = 60000;\nconst RETRY_BASE_INTERVAL = 5000;\nconst RETRY_MAX_COUNT = 3;\n\n/* The max (uncompressed) size in bytes of a network body. Any body larger than this will be truncated. */\nconst NETWORK_BODY_MAX_SIZE = 150000;\n\n/* The max size of a single console arg that is captured. Any arg larger than this will be truncated. */\nconst CONSOLE_ARG_MAX_SIZE = 5000;\n\n/* Min. time to wait before we consider something a slow click. */\nconst SLOW_CLICK_THRESHOLD = 3000;\n/* For scroll actions after a click, we only look for a very short time period to detect programmatic scrolling. */\nconst SLOW_CLICK_SCROLL_TIMEOUT = 300;\n\n/** When encountering a total segment size exceeding this size, stop the replay (as we cannot properly ingest it). */\nconst REPLAY_MAX_EVENT_BUFFER_SIZE = 20000000; // ~20MB\n\n/** Replays must be min. 5s long before we send them. */\nconst MIN_REPLAY_DURATION = 4999;\n/* The max. allowed value that the minReplayDuration can be set to. */\nconst MIN_REPLAY_DURATION_LIMIT = 15000;\n\n/** The max. length of a replay. */\nconst MAX_REPLAY_DURATION = 3600000; // 60 minutes in ms;\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar NodeType$2 = /* @__PURE__ */(NodeType2 => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType$2 || {});\nfunction isElement$1(n2) {\n  return n2.nodeType === n2.ELEMENT_NODE;\n}\nfunction isShadowRoot(n2) {\n  const host = n2?.host;\n  return Boolean(host?.shadowRoot === n2);\n}\nfunction isNativeShadowDom(shadowRoot) {\n  return Object.prototype.toString.call(shadowRoot) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n  if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n    cssText = cssText.replace(/\\sbackground-clip:\\s*text;/g, \" -webkit-background-clip: text; background-clip: text;\");\n  }\n  return cssText;\n}\nfunction escapeImportStatement(rule) {\n  const {\n    cssText\n  } = rule;\n  if (cssText.split('\"').length < 3) return cssText;\n  const statement = [\"@import\", `url(${JSON.stringify(rule.href)})`];\n  if (rule.layerName === \"\") {\n    statement.push(`layer`);\n  } else if (rule.layerName) {\n    statement.push(`layer(${rule.layerName})`);\n  }\n  if (rule.supportsText) {\n    statement.push(`supports(${rule.supportsText})`);\n  }\n  if (rule.media.length) {\n    statement.push(rule.media.mediaText);\n  }\n  return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s2) {\n  try {\n    const rules2 = s2.rules || s2.cssRules;\n    return rules2 ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules2, stringifyRule).join(\"\")) : null;\n  } catch (error) {\n    return null;\n  }\n}\nfunction fixAllCssProperty(rule) {\n  let styles = \"\";\n  for (let i2 = 0; i2 < rule.style.length; i2++) {\n    const styleDeclaration = rule.style;\n    const attribute = styleDeclaration[i2];\n    const isImportant = styleDeclaration.getPropertyPriority(attribute);\n    styles += `${attribute}:${styleDeclaration.getPropertyValue(attribute)}${isImportant ? ` !important` : \"\"};`;\n  }\n  return `${rule.selectorText} { ${styles} }`;\n}\nfunction stringifyRule(rule) {\n  let importStringified;\n  if (isCSSImportRule(rule)) {\n    try {\n      importStringified =\n      // for same-origin stylesheets,\n      // we can access the imported stylesheet rules directly\n      stringifyStylesheet(rule.styleSheet) ||\n      // work around browser issues with the raw string `@import url(...)` statement\n      escapeImportStatement(rule);\n    } catch (error) {}\n  } else if (isCSSStyleRule(rule)) {\n    let cssText = rule.cssText;\n    const needsSafariColonFix = rule.selectorText.includes(\":\");\n    const needsAllFix = typeof rule.style[\"all\"] === \"string\" && rule.style[\"all\"];\n    if (needsAllFix) {\n      cssText = fixAllCssProperty(rule);\n    }\n    if (needsSafariColonFix) {\n      cssText = fixSafariColons(cssText);\n    }\n    if (needsSafariColonFix || needsAllFix) {\n      return cssText;\n    }\n  }\n  return importStringified || rule.cssText;\n}\nfunction fixSafariColons(cssStringified) {\n  const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n  return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule) {\n  return \"styleSheet\" in rule;\n}\nfunction isCSSStyleRule(rule) {\n  return \"selectorText\" in rule;\n}\nclass Mirror {\n  constructor() {\n    __publicField$1(this, \"idNodeMap\", /* @__PURE__ */new Map());\n    __publicField$1(this, \"nodeMetaMap\", /* @__PURE__ */new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach(childNode => this.removeNodeFromMap(childNode));\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */new Map();\n    this.nodeMetaMap = /* @__PURE__ */new WeakMap();\n  }\n}\nfunction createMirror$2() {\n  return new Mirror();\n}\nfunction shouldMaskInput({\n  maskInputOptions,\n  tagName,\n  type\n}) {\n  if (tagName === \"OPTION\") {\n    tagName = \"SELECT\";\n  }\n  return Boolean(maskInputOptions[tagName.toLowerCase()] || type && maskInputOptions[type] || type === \"password\" ||\n  // Default to \"text\" option for inputs without a \"type\" attribute defined\n  tagName === \"INPUT\" && !type && maskInputOptions[\"text\"]);\n}\nfunction maskInputValue({\n  isMasked,\n  element,\n  value,\n  maskInputFn\n}) {\n  let text = value || \"\";\n  if (!isMasked) {\n    return text;\n  }\n  if (maskInputFn) {\n    text = maskInputFn(text, element);\n  }\n  return \"*\".repeat(text.length);\n}\nfunction toLowerCase(str) {\n  return str.toLowerCase();\n}\nfunction toUpperCase(str) {\n  return str.toUpperCase();\n}\nconst ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return true;\n  const chunkSize = 50;\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData;\n      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n      const pixelBuffer = new Uint32Array(\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n      originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\n      if (pixelBuffer.some(pixel => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\nfunction getInputType(element) {\n  const type = element.type;\n  return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ?\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  toLowerCase(type) : null;\n}\nfunction getInputValue(el, tagName, type) {\n  if (tagName === \"INPUT\" && (type === \"radio\" || type === \"checkbox\")) {\n    return el.getAttribute(\"value\") || \"\";\n  }\n  return el.value;\n}\nfunction extractFileExtension(path, baseURL) {\n  let url;\n  try {\n    url = new URL(path, baseURL ?? window.location.href);\n  } catch (err) {\n    return null;\n  }\n  const regex = /\\.([0-9a-z]+)(?:$)/i;\n  const match = url.pathname.match(regex);\n  return match?.[1] ?? null;\n}\nconst cachedImplementations$1 = {};\nfunction getImplementation$1(name) {\n  const cached = cachedImplementations$1[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl =\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {}\n  }\n  return cachedImplementations$1[name] = impl.bind(window);\n}\nfunction setTimeout$2(...rest) {\n  return getImplementation$1(\"setTimeout\")(...rest);\n}\nfunction clearTimeout$1(...rest) {\n  return getImplementation$1(\"clearTimeout\")(...rest);\n}\nfunction getIframeContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {}\n}\nlet _id = 1;\nconst tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nconst IGNORED_NODE = -2;\nfunction genId() {\n  return _id++;\n}\nfunction getValidTagName$1(element) {\n  if (element instanceof HTMLFormElement) {\n    return \"form\";\n  }\n  const processedTagName = toLowerCase(element.tagName);\n  if (tagNameRegex.test(processedTagName)) {\n    return \"div\";\n  }\n  return processedTagName;\n}\nfunction extractOrigin(url) {\n  let origin = \"\";\n  if (url.indexOf(\"//\") > -1) {\n    origin = url.split(\"/\").slice(0, 3).join(\"/\");\n  } else {\n    origin = url.split(\"/\")[0];\n  }\n  origin = origin.split(\"?\")[0];\n  return origin;\n}\nlet canvasService;\nlet canvasCtx;\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n  return (cssText || \"\").replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {\n    const filePath = path1 || path2 || path3;\n    const maybeQuote = quote1 || quote2 || \"\";\n    if (!filePath) {\n      return origin;\n    }\n    if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n      return `url(${maybeQuote}${filePath}${maybeQuote})`;\n    }\n    if (DATA_URI.test(filePath)) {\n      return `url(${maybeQuote}${filePath}${maybeQuote})`;\n    }\n    if (filePath[0] === \"/\") {\n      return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\n    }\n    const stack = href.split(\"/\");\n    const parts = filePath.split(\"/\");\n    stack.pop();\n    for (const part of parts) {\n      if (part === \".\") {\n        continue;\n      } else if (part === \"..\") {\n        stack.pop();\n      } else {\n        stack.push(part);\n      }\n    }\n    return `url(${maybeQuote}${stack.join(\"/\")}${maybeQuote})`;\n  });\n}\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n  if (attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  let pos = 0;\n  function collectCharacters(regEx) {\n    let chars2;\n    const match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars2 = match[0];\n      pos += chars2.length;\n      return chars2;\n    }\n    return \"\";\n  }\n  const output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === \",\") {\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      output.push(url);\n    } else {\n      let descriptorsStr = \"\";\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        const c2 = attributeValue.charAt(pos);\n        if (c2 === \"\") {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c2 === \",\") {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break;\n          } else if (c2 === \"(\") {\n            inParens = true;\n          }\n        } else {\n          if (c2 === \")\") {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c2;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(\", \");\n}\nconst cachedDocument = /* @__PURE__ */new WeakMap();\nfunction absoluteToDoc(doc, attributeValue) {\n  if (!attributeValue || attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  return getHref(doc, attributeValue);\n}\nfunction isSVGElement(el) {\n  return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref(doc, customHref) {\n  let a2 = cachedDocument.get(doc);\n  if (!a2) {\n    a2 = doc.createElement(\"a\");\n    cachedDocument.set(doc, a2);\n  }\n  if (!customHref) {\n    customHref = \"\";\n  } else if (customHref.startsWith(\"blob:\") || customHref.startsWith(\"data:\")) {\n    return customHref;\n  }\n  a2.setAttribute(\"href\", customHref);\n  return a2.href;\n}\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn) {\n  if (!value) {\n    return value;\n  }\n  if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"srcset\") {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === \"style\") {\n    return absoluteToStylesheet(value, getHref(doc));\n  } else if (tagName === \"object\" && name === \"data\") {\n    return absoluteToDoc(doc, value);\n  }\n  if (typeof maskAttributeFn === \"function\") {\n    return maskAttributeFn(name, value, element);\n  }\n  return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n  return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\n  try {\n    if (unblockSelector && element.matches(unblockSelector)) {\n      return false;\n    }\n    if (typeof blockClass === \"string\") {\n      if (element.classList.contains(blockClass)) {\n        return true;\n      }\n    } else {\n      for (let eIndex = element.classList.length; eIndex--;) {\n        const className = element.classList[eIndex];\n        if (blockClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (blockSelector) {\n      return element.matches(blockSelector);\n    }\n  } catch (e2) {}\n  return false;\n}\nfunction elementClassMatchesRegex(el, regex) {\n  for (let eIndex = el.classList.length; eIndex--;) {\n    const className = el.classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\n  if (!node) return -1;\n  if (node.nodeType !== node.ELEMENT_NODE) return -1;\n  if (distance > limit) return -1;\n  if (matchPredicate(node)) return distance;\n  return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\n}\nfunction createMatchPredicate(className, selector) {\n  return node => {\n    const el = node;\n    if (el === null) return false;\n    try {\n      if (className) {\n        if (typeof className === \"string\") {\n          if (el.matches(`.${className}`)) return true;\n        } else if (elementClassMatchesRegex(el, className)) {\n          return true;\n        }\n      }\n      if (selector && el.matches(selector)) return true;\n      return false;\n    } catch {\n      return false;\n    }\n  };\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    if (el === null) return false;\n    if (el.tagName === \"INPUT\") {\n      const autocomplete = el.getAttribute(\"autocomplete\");\n      const disallowedAutocompleteValues = [\"current-password\", \"new-password\", \"cc-number\", \"cc-exp\", \"cc-exp-month\", \"cc-exp-year\", \"cc-csc\"];\n      if (disallowedAutocompleteValues.includes(autocomplete)) {\n        return true;\n      }\n    }\n    let maskDistance = -1;\n    let unmaskDistance = -1;\n    if (maskAllText) {\n      unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector));\n      if (unmaskDistance < 0) {\n        return true;\n      }\n      maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector), unmaskDistance >= 0 ? unmaskDistance : Infinity);\n    } else {\n      maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector));\n      if (maskDistance < 0) {\n        return false;\n      }\n      unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector), maskDistance >= 0 ? maskDistance : Infinity);\n    }\n    return maskDistance >= 0 ? unmaskDistance >= 0 ? maskDistance <= unmaskDistance : true : unmaskDistance >= 0 ? false : !!maskAllText;\n  } catch (e2) {}\n  return !!maskAllText;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  let fired = false;\n  let readyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== \"complete\") {\n    const timer = setTimeout$2(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener(\"load\", () => {\n      clearTimeout$1(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  const blankUrl = \"about:blank\";\n  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n    setTimeout$2(listener, 0);\n    return iframeEl.addEventListener(\"load\", listener);\n  }\n  iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n  let fired = false;\n  let styleSheetLoaded;\n  try {\n    styleSheetLoaded = link.sheet;\n  } catch (error) {\n    return;\n  }\n  if (styleSheetLoaded) return;\n  const timer = setTimeout$2(() => {\n    if (!fired) {\n      listener();\n      fired = true;\n    }\n  }, styleSheetLoadTimeout);\n  link.addEventListener(\"load\", () => {\n    clearTimeout$1(timer);\n    fired = true;\n    listener();\n  });\n}\nfunction serializeNode(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskAttributeFn,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false\n  } = options;\n  const rootId = getRootId(doc, mirror2);\n  switch (n2.nodeType) {\n    case n2.DOCUMENT_NODE:\n      if (n2.compatMode !== \"CSS1Compat\") {\n        return {\n          type: NodeType$2.Document,\n          childNodes: [],\n          compatMode: n2.compatMode\n          // probably \"BackCompat\"\n        };\n      } else {\n        return {\n          type: NodeType$2.Document,\n          childNodes: []\n        };\n      }\n    case n2.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType$2.DocumentType,\n        name: n2.name,\n        publicId: n2.publicId,\n        systemId: n2.systemId,\n        rootId\n      };\n    case n2.ELEMENT_NODE:\n      return serializeElementNode(n2, {\n        doc,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        inlineStylesheet,\n        maskAttributeFn,\n        maskInputOptions,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement,\n        rootId,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector\n      });\n    case n2.TEXT_NODE:\n      return serializeTextNode(n2, {\n        doc,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        maskTextFn,\n        maskInputOptions,\n        maskInputFn,\n        rootId\n      });\n    case n2.CDATA_SECTION_NODE:\n      return {\n        type: NodeType$2.CDATA,\n        textContent: \"\",\n        rootId\n      };\n    case n2.COMMENT_NODE:\n      return {\n        type: NodeType$2.Comment,\n        textContent: n2.textContent || \"\",\n        rootId\n      };\n    default:\n      return false;\n  }\n}\nfunction getRootId(doc, mirror2) {\n  if (!mirror2.hasNode(doc)) return void 0;\n  const docId = mirror2.getId(doc);\n  return docId === 1 ? void 0 : docId;\n}\nfunction serializeTextNode(n2, options) {\n  const {\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    maskTextFn,\n    maskInputOptions,\n    maskInputFn,\n    rootId\n  } = options;\n  const parentTagName = n2.parentNode && n2.parentNode.tagName;\n  let textContent = n2.textContent;\n  const isStyle = parentTagName === \"STYLE\" ? true : void 0;\n  const isScript = parentTagName === \"SCRIPT\" ? true : void 0;\n  const isTextarea = parentTagName === \"TEXTAREA\" ? true : void 0;\n  if (isStyle && textContent) {\n    try {\n      if (n2.nextSibling || n2.previousSibling) {} else if (n2.parentNode.sheet?.cssRules) {\n        textContent = stringifyStylesheet(n2.parentNode.sheet);\n      }\n    } catch (err) {\n      console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n2);\n    }\n    textContent = absoluteToStylesheet(textContent, getHref(options.doc));\n  }\n  if (isScript) {\n    textContent = \"SCRIPT_PLACEHOLDER\";\n  }\n  const forceMask = needMaskingText(n2, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText);\n  if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\n    textContent = maskTextFn ? maskTextFn(textContent, n2.parentElement) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\n    textContent = maskInputFn ? maskInputFn(textContent, n2.parentNode) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (parentTagName === \"OPTION\" && textContent) {\n    const isInputMasked = shouldMaskInput({\n      type: null,\n      tagName: parentTagName,\n      maskInputOptions\n    });\n    textContent = maskInputValue({\n      isMasked: needMaskingText(n2, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked),\n      element: n2,\n      value: textContent,\n      maskInputFn\n    });\n  }\n  return {\n    type: NodeType$2.Text,\n    textContent: textContent || \"\",\n    isStyle,\n    rootId\n  };\n}\nfunction serializeElementNode(n2, options) {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    rootId,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector\n  } = options;\n  const needBlock = _isBlockedElement(n2, blockClass, blockSelector, unblockSelector);\n  const tagName = getValidTagName$1(n2);\n  let attributes2 = {};\n  const len = n2.attributes.length;\n  for (let i2 = 0; i2 < len; i2++) {\n    const attr = n2.attributes[i2];\n    if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\n      attributes2[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value, n2, maskAttributeFn);\n    }\n  }\n  if (tagName === \"link\" && inlineStylesheet) {\n    const stylesheet = Array.from(doc.styleSheets).find(s2 => {\n      return s2.href === n2.href;\n    });\n    let cssText = null;\n    if (stylesheet) {\n      cssText = stringifyStylesheet(stylesheet);\n    }\n    if (cssText) {\n      attributes2.rel = null;\n      attributes2.href = null;\n      attributes2.crossorigin = null;\n      attributes2._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n    }\n  }\n  if (tagName === \"style\" && n2.sheet &&\n  // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n  !(n2.innerText || n2.textContent || \"\").trim().length) {\n    const cssText = stringifyStylesheet(n2.sheet);\n    if (cssText) {\n      attributes2._cssText = absoluteToStylesheet(cssText, getHref(doc));\n    }\n  }\n  if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\" || tagName === \"option\") {\n    const el = n2;\n    const type = getInputType(el);\n    const value = getInputValue(el, toUpperCase(tagName), type);\n    const checked = el.checked;\n    if (type !== \"submit\" && type !== \"button\" && value) {\n      const forceMask = needMaskingText(el, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, shouldMaskInput({\n        type,\n        tagName: toUpperCase(tagName),\n        maskInputOptions\n      }));\n      attributes2.value = maskInputValue({\n        isMasked: forceMask,\n        element: el,\n        value,\n        maskInputFn\n      });\n    }\n    if (checked) {\n      attributes2.checked = checked;\n    }\n  }\n  if (tagName === \"option\") {\n    if (n2.selected && !maskInputOptions[\"select\"]) {\n      attributes2.selected = true;\n    } else {\n      delete attributes2.selected;\n    }\n  }\n  if (tagName === \"canvas\" && recordCanvas) {\n    if (n2.__context === \"2d\") {\n      if (!is2DCanvasBlank(n2)) {\n        attributes2.rr_dataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n      }\n    } else if (!(\"__context\" in n2)) {\n      const canvasDataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n      const blankCanvas = doc.createElement(\"canvas\");\n      blankCanvas.width = n2.width;\n      blankCanvas.height = n2.height;\n      const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n      if (canvasDataURL !== blankCanvasDataURL) {\n        attributes2.rr_dataURL = canvasDataURL;\n      }\n    }\n  }\n  if (tagName === \"img\" && inlineImages) {\n    if (!canvasService) {\n      canvasService = doc.createElement(\"canvas\");\n      canvasCtx = canvasService.getContext(\"2d\");\n    }\n    const image = n2;\n    const imageSrc = image.currentSrc || image.getAttribute(\"src\") || \"<unknown-src>\";\n    const priorCrossOrigin = image.crossOrigin;\n    const recordInlineImage = () => {\n      image.removeEventListener(\"load\", recordInlineImage);\n      try {\n        canvasService.width = image.naturalWidth;\n        canvasService.height = image.naturalHeight;\n        canvasCtx.drawImage(image, 0, 0);\n        attributes2.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n      } catch (err) {\n        if (image.crossOrigin !== \"anonymous\") {\n          image.crossOrigin = \"anonymous\";\n          if (image.complete && image.naturalWidth !== 0) recordInlineImage();else image.addEventListener(\"load\", recordInlineImage);\n          return;\n        } else {\n          console.warn(`Cannot inline img src=${imageSrc}! Error: ${err}`);\n        }\n      }\n      if (image.crossOrigin === \"anonymous\") {\n        priorCrossOrigin ? attributes2.crossOrigin = priorCrossOrigin : image.removeAttribute(\"crossorigin\");\n      }\n    };\n    if (image.complete && image.naturalWidth !== 0) recordInlineImage();else image.addEventListener(\"load\", recordInlineImage);\n  }\n  if (tagName === \"audio\" || tagName === \"video\") {\n    attributes2.rr_mediaState = n2.paused ? \"paused\" : \"played\";\n    attributes2.rr_mediaCurrentTime = n2.currentTime;\n  }\n  if (!newlyAddedElement) {\n    if (n2.scrollLeft) {\n      attributes2.rr_scrollLeft = n2.scrollLeft;\n    }\n    if (n2.scrollTop) {\n      attributes2.rr_scrollTop = n2.scrollTop;\n    }\n  }\n  if (needBlock) {\n    const {\n      width,\n      height\n    } = n2.getBoundingClientRect();\n    attributes2 = {\n      class: attributes2.class,\n      rr_width: `${width}px`,\n      rr_height: `${height}px`\n    };\n  }\n  if (tagName === \"iframe\" && !keepIframeSrcFn(attributes2.src)) {\n    if (!needBlock && !getIframeContentDocument(n2)) {\n      attributes2.rr_src = attributes2.src;\n    }\n    delete attributes2.src;\n  }\n  let isCustomElement;\n  try {\n    if (customElements.get(tagName)) isCustomElement = true;\n  } catch (e2) {}\n  return {\n    type: NodeType$2.Element,\n    tagName,\n    attributes: attributes2,\n    childNodes: [],\n    isSVG: isSVGElement(n2) || void 0,\n    needBlock,\n    rootId,\n    isCustom: isCustomElement\n  };\n}\nfunction lowerIfExists(maybeAttr) {\n  if (maybeAttr === void 0 || maybeAttr === null) {\n    return \"\";\n  } else {\n    return maybeAttr.toLowerCase();\n  }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n  if (slimDOMOptions.comment && sn.type === NodeType$2.Comment) {\n    return true;\n  } else if (sn.type === NodeType$2.Element) {\n    if (slimDOMOptions.script && (\n    // script tag\n    sn.tagName === \"script\" ||\n    // (module)preload link\n    sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" || sn.attributes.rel === \"modulepreload\") ||\n    // prefetch link\n    sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n      return true;\n    } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n      return true;\n    } else if (sn.tagName === \"meta\") {\n      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n        return true;\n      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||\n      // og = opengraph (facebook)\n      lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== void 0) {\n        return true;\n      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n        return true;\n      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction serializeNodeWithId(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5e3,\n    onStylesheetLoad,\n    stylesheetLoadTimeout = 5e3,\n    keepIframeSrcFn = () => false,\n    newlyAddedElement = false\n  } = options;\n  let {\n    preserveWhiteSpace = true\n  } = options;\n  const _serializedNode = serializeNode(n2, {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    maskAllText,\n    unblockSelector,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement\n  });\n  if (!_serializedNode) {\n    console.warn(n2, \"not serialized\");\n    return null;\n  }\n  let id;\n  if (mirror2.hasNode(n2)) {\n    id = mirror2.getId(n2);\n  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$2.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode2 = Object.assign(_serializedNode, {\n    id\n  });\n  mirror2.add(n2, serializedNode2);\n  if (id === IGNORED_NODE) {\n    return null;\n  }\n  if (onSerialize) {\n    onSerialize(n2);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode2.type === NodeType$2.Element) {\n    recordChild = recordChild && !serializedNode2.needBlock;\n    delete serializedNode2.needBlock;\n    const shadowRoot = n2.shadowRoot;\n    if (shadowRoot && isNativeShadowDom(shadowRoot)) serializedNode2.isShadowHost = true;\n  }\n  if ((serializedNode2.type === NodeType$2.Document || serializedNode2.type === NodeType$2.Element) && recordChild) {\n    if (slimDOMOptions.headWhitespace && serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"head\") {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      mirror: mirror2,\n      blockClass,\n      blockSelector,\n      maskAllText,\n      unblockSelector,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      onStylesheetLoad,\n      stylesheetLoadTimeout,\n      keepIframeSrcFn\n    };\n    for (const childN of Array.from(n2.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode2.childNodes.push(serializedChildNode);\n      }\n    }\n    if (isElement$1(n2) && n2.shadowRoot) {\n      for (const childN of Array.from(n2.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          isNativeShadowDom(n2.shadowRoot) && (serializedChildNode.isShadow = true);\n          serializedNode2.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n  if (n2.parentNode && isShadowRoot(n2.parentNode) && isNativeShadowDom(n2.parentNode)) {\n    serializedNode2.isShadow = true;\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"iframe\" && !_isBlockedElement(n2, blockClass, blockSelector, unblockSelector)) {\n    onceIframeLoaded(n2, () => {\n      const iframeDoc = getIframeContentDocument(n2);\n      if (iframeDoc && onIframeLoad) {\n        const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n          doc: iframeDoc,\n          mirror: mirror2,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector,\n          skipChild: false,\n          inlineStylesheet,\n          maskInputOptions,\n          maskAttributeFn,\n          maskTextFn,\n          maskInputFn,\n          slimDOMOptions,\n          dataURLOptions,\n          inlineImages,\n          recordCanvas,\n          preserveWhiteSpace,\n          onSerialize,\n          onIframeLoad,\n          iframeLoadTimeout,\n          onStylesheetLoad,\n          stylesheetLoadTimeout,\n          keepIframeSrcFn\n        });\n        if (serializedIframeNode) {\n          onIframeLoad(n2, serializedIframeNode);\n        }\n      }\n    }, iframeLoadTimeout);\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"link\" && typeof serializedNode2.attributes.rel === \"string\" && (serializedNode2.attributes.rel === \"stylesheet\" || serializedNode2.attributes.rel === \"preload\" && typeof serializedNode2.attributes.href === \"string\" && extractFileExtension(serializedNode2.attributes.href) === \"css\")) {\n    onceStylesheetLoaded(n2, () => {\n      if (onStylesheetLoad) {\n        const serializedLinkNode = serializeNodeWithId(n2, {\n          doc,\n          mirror: mirror2,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector,\n          skipChild: false,\n          inlineStylesheet,\n          maskInputOptions,\n          maskAttributeFn,\n          maskTextFn,\n          maskInputFn,\n          slimDOMOptions,\n          dataURLOptions,\n          inlineImages,\n          recordCanvas,\n          preserveWhiteSpace,\n          onSerialize,\n          onIframeLoad,\n          iframeLoadTimeout,\n          onStylesheetLoad,\n          stylesheetLoadTimeout,\n          keepIframeSrcFn\n        });\n        if (serializedLinkNode) {\n          onStylesheetLoad(n2, serializedLinkNode);\n        }\n      }\n    }, stylesheetLoadTimeout);\n  }\n  return serializedNode2;\n}\nfunction snapshot(n2, options) {\n  const {\n    mirror: mirror2 = new Mirror(),\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn = () => false\n  } = options || {};\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true\n  } : maskAllInputs === false ? {} : maskAllInputs;\n  const slimDOMOptions = slimDOM === true || slimDOM === \"all\" ?\n  // if true: set of sensible options that should not throw away any information\n  {\n    script: true,\n    comment: true,\n    headFavicon: true,\n    headWhitespace: true,\n    headMetaDescKeywords: slimDOM === \"all\",\n    // destructive\n    headMetaSocial: true,\n    headMetaRobots: true,\n    headMetaHttpEquiv: true,\n    headMetaAuthorship: true,\n    headMetaVerification: true\n  } : slimDOM === false ? {} : slimDOM;\n  return serializeNodeWithId(n2, {\n    doc: n2,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild: false,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn,\n    newlyAddedElement: false\n  });\n}\nfunction on(type, fn, target = document) {\n  const options = {\n    capture: true,\n    passive: true\n  };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\nconst DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.\";\nlet _mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  }\n};\nif (typeof window !== \"undefined\" && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === \"map\") {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction throttle$1(func, wait, options = {}) {\n  let timeout = null;\n  let previous = 0;\n  return function (...args) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    const context = this;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout$2(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout$1(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\nfunction hookSetter(target, key, d, isRevoked, win = window) {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(target, key, isRevoked ? d : {\n    set(value) {\n      setTimeout$1(() => {\n        d.set.call(this, value);\n      }, 0);\n      if (original && original.set) {\n        original.set.call(this, value);\n      }\n    }\n  });\n  return () => hookSetter(target, key, original || {}, true);\n}\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return () => {};\n    }\n    const original = source[name];\n    const wrapped = replacement(original);\n    if (typeof wrapped === \"function\") {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    }\n    source[name] = wrapped;\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {};\n  }\n}\nlet nowTimestamp = Date.now;\nif (! /* @__PURE__ *//[1-9][0-9]{12}/.test(Date.now().toString())) {\n  nowTimestamp = () => (/* @__PURE__ */new Date()).getTime();\n}\nfunction getWindowScroll(win) {\n  const doc = win.document;\n  return {\n    left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc?.documentElement.scrollLeft || doc?.body?.parentElement?.scrollLeft || doc?.body?.scrollLeft || 0,\n    top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : doc?.documentElement.scrollTop || doc?.body?.parentElement?.scrollTop || doc?.body?.scrollTop || 0\n  };\n}\nfunction getWindowHeight() {\n  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode(node) {\n  if (!node) {\n    return null;\n  }\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    return el;\n  } catch (error) {\n    return null;\n  }\n}\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\n  if (!node) {\n    return false;\n  }\n  const el = closestElementOfNode(node);\n  if (!el) {\n    return false;\n  }\n  const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\n  if (!checkAncestors) {\n    const isUnblocked = unblockSelector && el.matches(unblockSelector);\n    return blockedPredicate(el) && !isUnblocked;\n  }\n  const blockDistance = distanceToMatch(el, blockedPredicate);\n  let unblockDistance = -1;\n  if (blockDistance < 0) {\n    return false;\n  }\n  if (unblockSelector) {\n    unblockDistance = distanceToMatch(el, createMatchPredicate(null, unblockSelector));\n  }\n  if (blockDistance > -1 && unblockDistance < 0) {\n    return true;\n  }\n  return blockDistance < unblockDistance;\n}\nfunction isSerialized(n2, mirror2) {\n  return mirror2.getId(n2) !== -1;\n}\nfunction isIgnored(n2, mirror2) {\n  return mirror2.getId(n2) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror2) {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror2.getId(target);\n  if (!mirror2.has(id)) {\n    return true;\n  }\n  if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n    return false;\n  }\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved(target.parentNode, mirror2);\n}\nfunction legacy_isTouchEvent(event) {\n  return Boolean(event.changedTouches);\n}\nfunction polyfill$1(win = window) {\n  if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = (...args) => {\n      let node = args[0];\n      if (!(0 in args)) {\n        throw new TypeError(\"1 argument is required\");\n      }\n      do {\n        if (this === node) {\n          return true;\n        }\n      } while (node = node && node.parentNode);\n      return false;\n    };\n  }\n}\nfunction isSerializedIframe(n2, mirror2) {\n  return Boolean(n2.nodeName === \"IFRAME\" && mirror2.getMeta(n2));\n}\nfunction isSerializedStylesheet(n2, mirror2) {\n  return Boolean(n2.nodeName === \"LINK\" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute(\"rel\") === \"stylesheet\" && mirror2.getMeta(n2));\n}\nfunction hasShadowRoot(n2) {\n  return Boolean(n2?.shadowRoot);\n}\nclass StyleSheetMirror {\n  constructor() {\n    this.id = 1;\n    this.styleIDMap = /* @__PURE__ */new WeakMap();\n    this.idStyleMap = /* @__PURE__ */new Map();\n  }\n  getId(stylesheet) {\n    return this.styleIDMap.get(stylesheet) ?? -1;\n  }\n  has(stylesheet) {\n    return this.styleIDMap.has(stylesheet);\n  }\n  /**\n   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.\n   */\n  add(stylesheet, id) {\n    if (this.has(stylesheet)) return this.getId(stylesheet);\n    let newId;\n    if (id === void 0) {\n      newId = this.id++;\n    } else newId = id;\n    this.styleIDMap.set(stylesheet, newId);\n    this.idStyleMap.set(newId, stylesheet);\n    return newId;\n  }\n  getStyle(id) {\n    return this.idStyleMap.get(id) || null;\n  }\n  reset() {\n    this.styleIDMap = /* @__PURE__ */new WeakMap();\n    this.idStyleMap = /* @__PURE__ */new Map();\n    this.id = 1;\n  }\n  generateId() {\n    return this.id++;\n  }\n}\nfunction getShadowHost(n2) {\n  let shadowHost = null;\n  if (n2.getRootNode?.()?.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n2.getRootNode().host) shadowHost = n2.getRootNode().host;\n  return shadowHost;\n}\nfunction getRootShadowHost(n2) {\n  let rootShadowHost = n2;\n  let shadowHost;\n  while (shadowHost = getShadowHost(rootShadowHost)) rootShadowHost = shadowHost;\n  return rootShadowHost;\n}\nfunction shadowHostInDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  const shadowHost = getRootShadowHost(n2);\n  return doc.contains(shadowHost);\n}\nfunction inDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  return doc.contains(n2) || shadowHostInDom(n2);\n}\nconst cachedImplementations = {};\nfunction getImplementation(name) {\n  const cached = cachedImplementations[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl =\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {}\n  }\n  return cachedImplementations[name] = impl.bind(window);\n}\nfunction onRequestAnimationFrame(...rest) {\n  return getImplementation(\"requestAnimationFrame\")(...rest);\n}\nfunction setTimeout$1(...rest) {\n  return getImplementation(\"setTimeout\")(...rest);\n}\nfunction clearTimeout$2(...rest) {\n  return getImplementation(\"clearTimeout\")(...rest);\n}\nvar EventType = /* @__PURE__ */(EventType2 => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */(IncrementalSource2 => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */(MouseInteractions2 => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */(PointerTypes2 => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar MediaInteractions = /* @__PURE__ */(MediaInteractions2 => {\n  MediaInteractions2[MediaInteractions2[\"Play\"] = 0] = \"Play\";\n  MediaInteractions2[MediaInteractions2[\"Pause\"] = 1] = \"Pause\";\n  MediaInteractions2[MediaInteractions2[\"Seeked\"] = 2] = \"Seeked\";\n  MediaInteractions2[MediaInteractions2[\"VolumeChange\"] = 3] = \"VolumeChange\";\n  MediaInteractions2[MediaInteractions2[\"RateChange\"] = 4] = \"RateChange\";\n  return MediaInteractions2;\n})(MediaInteractions || {});\nfunction getIFrameContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {}\n}\nfunction getIFrameContentWindow(iframe) {\n  try {\n    return iframe.contentWindow;\n  } catch (e2) {}\n}\nfunction isNodeInLinkedList(n2) {\n  return \"__ln\" in n2;\n}\nclass DoubleLinkedList {\n  constructor() {\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n  }\n  get(position) {\n    if (position >= this.length) {\n      throw new Error(\"Position outside of list range\");\n    }\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n  addNode(n2) {\n    const node = {\n      value: n2,\n      previous: null,\n      next: null\n    };\n    n2.__ln = node;\n    if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {\n      const current = n2.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n2.previousSibling.__ln;\n      n2.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {\n      const current = n2.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n2.nextSibling.__ln;\n      n2.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    if (node.next === null) {\n      this.tail = node;\n    }\n    this.length++;\n  }\n  removeNode(n2) {\n    const current = n2.__ln;\n    if (!this.head) {\n      return;\n    }\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      } else {\n        this.tail = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      } else {\n        this.tail = current.previous;\n      }\n    }\n    if (n2.__ln) {\n      delete n2.__ln;\n    }\n    this.length--;\n  }\n}\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\nclass MutationBuffer {\n  constructor() {\n    this.frozen = false;\n    this.locked = false;\n    this.texts = [];\n    this.attributes = [];\n    this.attributeMap = /* @__PURE__ */new WeakMap();\n    this.removes = [];\n    this.mapRemoves = [];\n    this.movedMap = {};\n    this.addedSet = /* @__PURE__ */new Set();\n    this.movedSet = /* @__PURE__ */new Set();\n    this.droppedSet = /* @__PURE__ */new Set();\n    this.processMutations = mutations => {\n      mutations.forEach(this.processMutation);\n      this.emit();\n    };\n    this.emit = () => {\n      if (this.frozen || this.locked) {\n        return;\n      }\n      const adds = [];\n      const addedIds = /* @__PURE__ */new Set();\n      const addList = new DoubleLinkedList();\n      const getNextId = n2 => {\n        let ns = n2;\n        let nextId = IGNORED_NODE;\n        while (nextId === IGNORED_NODE) {\n          ns = ns && ns.nextSibling;\n          nextId = ns && this.mirror.getId(ns);\n        }\n        return nextId;\n      };\n      const pushAdd = n2 => {\n        if (!n2.parentNode || !inDom(n2)) {\n          return;\n        }\n        const parentId = isShadowRoot(n2.parentNode) ? this.mirror.getId(getShadowHost(n2)) : this.mirror.getId(n2.parentNode);\n        const nextId = getNextId(n2);\n        if (parentId === -1 || nextId === -1) {\n          return addList.addNode(n2);\n        }\n        const sn = serializeNodeWithId(n2, {\n          doc: this.doc,\n          mirror: this.mirror,\n          blockClass: this.blockClass,\n          blockSelector: this.blockSelector,\n          maskAllText: this.maskAllText,\n          unblockSelector: this.unblockSelector,\n          maskTextClass: this.maskTextClass,\n          unmaskTextClass: this.unmaskTextClass,\n          maskTextSelector: this.maskTextSelector,\n          unmaskTextSelector: this.unmaskTextSelector,\n          skipChild: true,\n          newlyAddedElement: true,\n          inlineStylesheet: this.inlineStylesheet,\n          maskInputOptions: this.maskInputOptions,\n          maskAttributeFn: this.maskAttributeFn,\n          maskTextFn: this.maskTextFn,\n          maskInputFn: this.maskInputFn,\n          slimDOMOptions: this.slimDOMOptions,\n          dataURLOptions: this.dataURLOptions,\n          recordCanvas: this.recordCanvas,\n          inlineImages: this.inlineImages,\n          onSerialize: currentN => {\n            if (isSerializedIframe(currentN, this.mirror) && !isBlocked(currentN, this.blockClass, this.blockSelector, this.unblockSelector, false)) {\n              this.iframeManager.addIframe(currentN);\n            }\n            if (isSerializedStylesheet(currentN, this.mirror)) {\n              this.stylesheetManager.trackLinkElement(currentN);\n            }\n            if (hasShadowRoot(n2)) {\n              this.shadowDomManager.addShadowRoot(n2.shadowRoot, this.doc);\n            }\n          },\n          onIframeLoad: (iframe, childSn) => {\n            if (isBlocked(iframe, this.blockClass, this.blockSelector, this.unblockSelector, false)) {\n              return;\n            }\n            this.iframeManager.attachIframe(iframe, childSn);\n            if (iframe.contentWindow) {\n              this.canvasManager.addWindow(iframe.contentWindow);\n            }\n            this.shadowDomManager.observeAttachShadow(iframe);\n          },\n          onStylesheetLoad: (link, childSn) => {\n            this.stylesheetManager.attachLinkElement(link, childSn);\n          }\n        });\n        if (sn) {\n          adds.push({\n            parentId,\n            nextId,\n            node: sn\n          });\n          addedIds.add(sn.id);\n        }\n      };\n      while (this.mapRemoves.length) {\n        this.mirror.removeNodeFromMap(this.mapRemoves.shift());\n      }\n      for (const n2 of this.movedSet) {\n        if (isParentRemoved(this.removes, n2, this.mirror) && !this.movedSet.has(n2.parentNode)) {\n          continue;\n        }\n        pushAdd(n2);\n      }\n      for (const n2 of this.addedSet) {\n        if (!isAncestorInSet(this.droppedSet, n2) && !isParentRemoved(this.removes, n2, this.mirror)) {\n          pushAdd(n2);\n        } else if (isAncestorInSet(this.movedSet, n2)) {\n          pushAdd(n2);\n        } else {\n          this.droppedSet.add(n2);\n        }\n      }\n      let candidate = null;\n      while (addList.length) {\n        let node = null;\n        if (candidate) {\n          const parentId = this.mirror.getId(candidate.value.parentNode);\n          const nextId = getNextId(candidate.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = candidate;\n          }\n        }\n        if (!node) {\n          let tailNode = addList.tail;\n          while (tailNode) {\n            const _node = tailNode;\n            tailNode = tailNode.previous;\n            if (_node) {\n              const parentId = this.mirror.getId(_node.value.parentNode);\n              const nextId = getNextId(_node.value);\n              if (nextId === -1) continue;else if (parentId !== -1) {\n                node = _node;\n                break;\n              } else {\n                const unhandledNode = _node.value;\n                if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                  const shadowHost = unhandledNode.parentNode.host;\n                  const parentId2 = this.mirror.getId(shadowHost);\n                  if (parentId2 !== -1) {\n                    node = _node;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (!node) {\n          while (addList.head) {\n            addList.removeNode(addList.head.value);\n          }\n          break;\n        }\n        candidate = node.previous;\n        addList.removeNode(node.value);\n        pushAdd(node.value);\n      }\n      const payload = {\n        texts: this.texts.map(text => ({\n          id: this.mirror.getId(text.node),\n          value: text.value\n        })).filter(text => !addedIds.has(text.id)).filter(text => this.mirror.has(text.id)),\n        attributes: this.attributes.map(attribute => {\n          const {\n            attributes\n          } = attribute;\n          if (typeof attributes.style === \"string\") {\n            const diffAsStr = JSON.stringify(attribute.styleDiff);\n            const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n            if (diffAsStr.length < attributes.style.length) {\n              if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                attributes.style = attribute.styleDiff;\n              }\n            }\n          }\n          return {\n            id: this.mirror.getId(attribute.node),\n            attributes\n          };\n        }).filter(attribute => !addedIds.has(attribute.id)).filter(attribute => this.mirror.has(attribute.id)),\n        removes: this.removes,\n        adds\n      };\n      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n        return;\n      }\n      this.texts = [];\n      this.attributes = [];\n      this.attributeMap = /* @__PURE__ */new WeakMap();\n      this.removes = [];\n      this.addedSet = /* @__PURE__ */new Set();\n      this.movedSet = /* @__PURE__ */new Set();\n      this.droppedSet = /* @__PURE__ */new Set();\n      this.movedMap = {};\n      this.mutationCb(payload);\n    };\n    this.processMutation = m => {\n      if (isIgnored(m.target, this.mirror)) {\n        return;\n      }\n      switch (m.type) {\n        case \"characterData\":\n          {\n            const value = m.target.textContent;\n            if (!isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) && value !== m.oldValue) {\n              this.texts.push({\n                value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n                node: m.target\n              });\n            }\n            break;\n          }\n        case \"attributes\":\n          {\n            const target = m.target;\n            let attributeName = m.attributeName;\n            let value = m.target.getAttribute(attributeName);\n            if (attributeName === \"value\") {\n              const type = getInputType(target);\n              const tagName = target.tagName;\n              value = getInputValue(target, tagName, type);\n              const isInputMasked = shouldMaskInput({\n                maskInputOptions: this.maskInputOptions,\n                tagName,\n                type\n              });\n              const forceMask = needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, isInputMasked);\n              value = maskInputValue({\n                isMasked: forceMask,\n                element: target,\n                value,\n                maskInputFn: this.maskInputFn\n              });\n            }\n            if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) || value === m.oldValue) {\n              return;\n            }\n            let item = this.attributeMap.get(m.target);\n            if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !this.keepIframeSrcFn(value)) {\n              const iframeDoc = getIFrameContentDocument(target);\n              if (!iframeDoc) {\n                attributeName = \"rr_src\";\n              } else {\n                return;\n              }\n            }\n            if (!item) {\n              item = {\n                node: m.target,\n                attributes: {},\n                styleDiff: {},\n                _unchangedStyles: {}\n              };\n              this.attributes.push(item);\n              this.attributeMap.set(m.target, item);\n            }\n            if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n              target.setAttribute(\"data-rr-is-password\", \"true\");\n            }\n            if (!ignoreAttribute(target.tagName, attributeName)) {\n              item.attributes[attributeName] = transformAttribute(this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value, target, this.maskAttributeFn);\n              if (attributeName === \"style\") {\n                if (!this.unattachedDoc) {\n                  try {\n                    this.unattachedDoc = document.implementation.createHTMLDocument();\n                  } catch (e2) {\n                    this.unattachedDoc = this.doc;\n                  }\n                }\n                const old = this.unattachedDoc.createElement(\"span\");\n                if (m.oldValue) {\n                  old.setAttribute(\"style\", m.oldValue);\n                }\n                for (const pname of Array.from(target.style)) {\n                  const newValue = target.style.getPropertyValue(pname);\n                  const newPriority = target.style.getPropertyPriority(pname);\n                  if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                    if (newPriority === \"\") {\n                      item.styleDiff[pname] = newValue;\n                    } else {\n                      item.styleDiff[pname] = [newValue, newPriority];\n                    }\n                  } else {\n                    item._unchangedStyles[pname] = [newValue, newPriority];\n                  }\n                }\n                for (const pname of Array.from(old.style)) {\n                  if (target.style.getPropertyValue(pname) === \"\") {\n                    item.styleDiff[pname] = false;\n                  }\n                }\n              }\n            }\n            break;\n          }\n        case \"childList\":\n          {\n            if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, true)) {\n              return;\n            }\n            m.addedNodes.forEach(n2 => this.genAdds(n2, m.target));\n            m.removedNodes.forEach(n2 => {\n              const nodeId = this.mirror.getId(n2);\n              const parentId = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);\n              if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) || isIgnored(n2, this.mirror) || !isSerialized(n2, this.mirror)) {\n                return;\n              }\n              if (this.addedSet.has(n2)) {\n                deepDelete(this.addedSet, n2);\n                this.droppedSet.add(n2);\n              } else if (this.addedSet.has(m.target) && nodeId === -1) ;else if (isAncestorRemoved(m.target, this.mirror)) ;else if (this.movedSet.has(n2) && this.movedMap[moveKey(nodeId, parentId)]) {\n                deepDelete(this.movedSet, n2);\n              } else {\n                this.removes.push({\n                  parentId,\n                  id: nodeId,\n                  isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0\n                });\n              }\n              this.mapRemoves.push(n2);\n            });\n            break;\n          }\n      }\n    };\n    this.genAdds = (n2, target) => {\n      if (this.processedNodeManager.inOtherBuffer(n2, this)) return;\n      if (this.addedSet.has(n2) || this.movedSet.has(n2)) return;\n      if (this.mirror.hasNode(n2)) {\n        if (isIgnored(n2, this.mirror)) {\n          return;\n        }\n        this.movedSet.add(n2);\n        let targetId = null;\n        if (target && this.mirror.hasNode(target)) {\n          targetId = this.mirror.getId(target);\n        }\n        if (targetId && targetId !== -1) {\n          this.movedMap[moveKey(this.mirror.getId(n2), targetId)] = true;\n        }\n      } else {\n        this.addedSet.add(n2);\n        this.droppedSet.delete(n2);\n      }\n      if (!isBlocked(n2, this.blockClass, this.blockSelector, this.unblockSelector, false)) {\n        n2.childNodes.forEach(childN => this.genAdds(childN));\n        if (hasShadowRoot(n2)) {\n          n2.shadowRoot.childNodes.forEach(childN => {\n            this.processedNodeManager.add(childN, this);\n            this.genAdds(childN, n2);\n          });\n        }\n      }\n    };\n  }\n  init(options) {\n    [\"mutationCb\", \"blockClass\", \"blockSelector\", \"unblockSelector\", \"maskAllText\", \"maskTextClass\", \"unmaskTextClass\", \"maskTextSelector\", \"unmaskTextSelector\", \"inlineStylesheet\", \"maskInputOptions\", \"maskAttributeFn\", \"maskTextFn\", \"maskInputFn\", \"keepIframeSrcFn\", \"recordCanvas\", \"inlineImages\", \"slimDOMOptions\", \"dataURLOptions\", \"doc\", \"mirror\", \"iframeManager\", \"stylesheetManager\", \"shadowDomManager\", \"canvasManager\", \"processedNodeManager\"].forEach(key => {\n      this[key] = options[key];\n    });\n  }\n  freeze() {\n    this.frozen = true;\n    this.canvasManager.freeze();\n  }\n  unfreeze() {\n    this.frozen = false;\n    this.canvasManager.unfreeze();\n    this.emit();\n  }\n  isFrozen() {\n    return this.frozen;\n  }\n  lock() {\n    this.locked = true;\n    this.canvasManager.lock();\n  }\n  unlock() {\n    this.locked = false;\n    this.canvasManager.unlock();\n    this.emit();\n  }\n  reset() {\n    this.shadowDomManager.reset();\n    this.canvasManager.reset();\n  }\n}\nfunction deepDelete(addsSet, n2) {\n  addsSet.delete(n2);\n  n2.childNodes.forEach(childN => deepDelete(addsSet, childN));\n}\nfunction isParentRemoved(removes, n2, mirror2) {\n  if (removes.length === 0) return false;\n  return _isParentRemoved(removes, n2, mirror2);\n}\nfunction _isParentRemoved(removes, n2, mirror2) {\n  let node = n2.parentNode;\n  while (node) {\n    const parentId = mirror2.getId(node);\n    if (removes.some(r2 => r2.id === parentId)) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\nfunction isAncestorInSet(set, n2) {\n  if (set.size === 0) return false;\n  return _isAncestorInSet(set, n2);\n}\nfunction _isAncestorInSet(set, n2) {\n  const {\n    parentNode\n  } = n2;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return _isAncestorInSet(set, parentNode);\n}\nlet errorHandler;\nfunction registerErrorHandler(handler) {\n  errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n  errorHandler = void 0;\n}\nconst callbackWrapper = cb => {\n  if (!errorHandler) {\n    return cb;\n  }\n  const rrwebWrapped = (...rest) => {\n    try {\n      return cb(...rest);\n    } catch (error) {\n      if (errorHandler && errorHandler(error) === true) {\n        return () => {};\n      }\n      throw error;\n    }\n  };\n  return rrwebWrapped;\n};\nconst mutationBuffers = [];\nfunction getEventTarget(event) {\n  try {\n    if (\"composedPath\" in event) {\n      const path = event.composedPath();\n      if (path.length) {\n        return path[0];\n      }\n    } else if (\"path\" in event && event.path.length) {\n      return event.path[0];\n    }\n  } catch {}\n  return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  mutationBuffer.init(options);\n  let mutationObserverCtor = window.MutationObserver ||\n  /**\n  * Some websites may disable MutationObserver by removing it from the window object.\n  * If someone is using rrweb to build a browser extention or things like it, they\n  * could not change the website's code but can have an opportunity to inject some\n  * code before the website executing its JS logic.\n  * Then they can do this to store the native MutationObserver:\n  * window.__rrMutationObserver = MutationObserver\n  */\n  window.__rrMutationObserver;\n  const angularZoneSymbol = window?.Zone?.__symbol__?.(\"MutationObserver\");\n  if (angularZoneSymbol && window[angularZoneSymbol]) {\n    mutationObserverCtor = window[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(callbackWrapper(mutations => {\n    if (options.onMutation && options.onMutation(mutations) === false) {\n      return;\n    }\n    mutationBuffer.processMutations.bind(mutationBuffer)(mutations);\n  }));\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\nfunction initMoveObserver({\n  mousemoveCb,\n  sampling,\n  doc,\n  mirror: mirror2\n}) {\n  if (sampling.mousemove === false) {\n    return () => {};\n  }\n  const threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n  const callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n  let positions = [];\n  let timeBaseline;\n  const wrappedCb = throttle$1(callbackWrapper(source => {\n    const totalOffset = Date.now() - timeBaseline;\n    mousemoveCb(positions.map(p => {\n      p.timeOffset -= totalOffset;\n      return p;\n    }), source);\n    positions = [];\n    timeBaseline = null;\n  }), callbackThreshold);\n  const updatePosition = callbackWrapper(throttle$1(callbackWrapper(evt => {\n    const target = getEventTarget(evt);\n    const {\n      clientX,\n      clientY\n    } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;\n    if (!timeBaseline) {\n      timeBaseline = nowTimestamp();\n    }\n    positions.push({\n      x: clientX,\n      y: clientY,\n      id: mirror2.getId(target),\n      timeOffset: nowTimestamp() - timeBaseline\n    });\n    wrappedCb(typeof DragEvent !== \"undefined\" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove);\n  }), threshold, {\n    trailing: false\n  }));\n  const handlers = [on(\"mousemove\", updatePosition, doc), on(\"touchmove\", updatePosition, doc), on(\"drag\", updatePosition, doc)];\n  return callbackWrapper(() => {\n    handlers.forEach(h => h());\n  });\n}\nfunction initMouseInteractionObserver({\n  mouseInteractionCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  if (sampling.mouseInteraction === false) {\n    return () => {};\n  }\n  const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;\n  const handlers = [];\n  let currentPointerType = null;\n  const getHandler = eventKey => {\n    return event => {\n      const target = getEventTarget(event);\n      if (isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n        return;\n      }\n      let pointerType = null;\n      let thisEventKey = eventKey;\n      if (\"pointerType\" in event) {\n        switch (event.pointerType) {\n          case \"mouse\":\n            pointerType = PointerTypes.Mouse;\n            break;\n          case \"touch\":\n            pointerType = PointerTypes.Touch;\n            break;\n          case \"pen\":\n            pointerType = PointerTypes.Pen;\n            break;\n        }\n        if (pointerType === PointerTypes.Touch) {\n          if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n            thisEventKey = \"TouchStart\";\n          } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n            thisEventKey = \"TouchEnd\";\n          }\n        } else if (pointerType === PointerTypes.Pen) ;\n      } else if (legacy_isTouchEvent(event)) {\n        pointerType = PointerTypes.Touch;\n      }\n      if (pointerType !== null) {\n        currentPointerType = pointerType;\n        if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n          pointerType = null;\n        }\n      } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n        pointerType = currentPointerType;\n        currentPointerType = null;\n      }\n      const e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e2) {\n        return;\n      }\n      const id = mirror2.getId(target);\n      const {\n        clientX,\n        clientY\n      } = e2;\n      callbackWrapper(mouseInteractionCb)({\n        type: MouseInteractions[thisEventKey],\n        id,\n        x: clientX,\n        y: clientY,\n        ...(pointerType !== null && {\n          pointerType\n        })\n      });\n    };\n  };\n  Object.keys(MouseInteractions).filter(key => Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false).forEach(eventKey => {\n    let eventName = toLowerCase(eventKey);\n    const handler = getHandler(eventKey);\n    if (window.PointerEvent) {\n      switch (MouseInteractions[eventKey]) {\n        case MouseInteractions.MouseDown:\n        case MouseInteractions.MouseUp:\n          eventName = eventName.replace(\"mouse\", \"pointer\");\n          break;\n        case MouseInteractions.TouchStart:\n        case MouseInteractions.TouchEnd:\n          return;\n      }\n    }\n    handlers.push(on(eventName, handler, doc));\n  });\n  return callbackWrapper(() => {\n    handlers.forEach(h => h());\n  });\n}\nfunction initScrollObserver({\n  scrollCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  const updatePosition = callbackWrapper(throttle$1(callbackWrapper(evt => {\n    const target = getEventTarget(evt);\n    if (!target || isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n      return;\n    }\n    const id = mirror2.getId(target);\n    if (target === doc && doc.defaultView) {\n      const scrollLeftTop = getWindowScroll(doc.defaultView);\n      scrollCb({\n        id,\n        x: scrollLeftTop.left,\n        y: scrollLeftTop.top\n      });\n    } else {\n      scrollCb({\n        id,\n        x: target.scrollLeft,\n        y: target.scrollTop\n      });\n    }\n  }), sampling.scroll || 100));\n  return on(\"scroll\", updatePosition, doc);\n}\nfunction initViewportResizeObserver({\n  viewportResizeCb\n}, {\n  win\n}) {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = callbackWrapper(throttle$1(callbackWrapper(() => {\n    const height = getWindowHeight();\n    const width = getWindowWidth();\n    if (lastH !== height || lastW !== width) {\n      viewportResizeCb({\n        width: Number(width),\n        height: Number(height)\n      });\n      lastH = height;\n      lastW = width;\n    }\n  }), 200));\n  return on(\"resize\", updateDimension, win);\n}\nconst INPUT_TAGS = [\"INPUT\", \"TEXTAREA\", \"SELECT\"];\nconst lastInputValueMap = /* @__PURE__ */new WeakMap();\nfunction initInputObserver({\n  inputCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  ignoreClass,\n  ignoreSelector,\n  maskInputOptions,\n  maskInputFn,\n  sampling,\n  userTriggeredOnInput,\n  maskTextClass,\n  unmaskTextClass,\n  maskTextSelector,\n  unmaskTextSelector\n}) {\n  function eventHandler(event) {\n    let target = getEventTarget(event);\n    const userTriggered = event.isTrusted;\n    const tagName = target && toUpperCase(target.tagName);\n    if (tagName === \"OPTION\") target = target.parentElement;\n    if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n      return;\n    }\n    const el = target;\n    if (el.classList.contains(ignoreClass) || ignoreSelector && el.matches(ignoreSelector)) {\n      return;\n    }\n    const type = getInputType(target);\n    let text = getInputValue(el, tagName, type);\n    let isChecked = false;\n    const isInputMasked = shouldMaskInput({\n      maskInputOptions,\n      tagName,\n      type\n    });\n    const forceMask = needMaskingText(target, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked);\n    if (type === \"radio\" || type === \"checkbox\") {\n      isChecked = target.checked;\n    }\n    text = maskInputValue({\n      isMasked: forceMask,\n      element: target,\n      value: text,\n      maskInputFn\n    });\n    cbWithDedup(target, userTriggeredOnInput ? {\n      text,\n      isChecked,\n      userTriggered\n    } : {\n      text,\n      isChecked\n    });\n    const name = target.name;\n    if (type === \"radio\" && name && isChecked) {\n      doc.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`).forEach(el2 => {\n        if (el2 !== target) {\n          const text2 = maskInputValue({\n            // share mask behavior of `target`\n            isMasked: forceMask,\n            element: el2,\n            value: getInputValue(el2, tagName, type),\n            maskInputFn\n          });\n          cbWithDedup(el2, userTriggeredOnInput ? {\n            text: text2,\n            isChecked: !isChecked,\n            userTriggered: false\n          } : {\n            text: text2,\n            isChecked: !isChecked\n          });\n        }\n      });\n    }\n  }\n  function cbWithDedup(target, v2) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {\n      lastInputValueMap.set(target, v2);\n      const id = mirror2.getId(target);\n      callbackWrapper(inputCb)({\n        ...v2,\n        id\n      });\n    }\n  }\n  const events = sampling.input === \"last\" ? [\"change\"] : [\"input\", \"change\"];\n  const handlers = events.map(eventName => on(eventName, callbackWrapper(eventHandler), doc));\n  const currentWindow = doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n      handlers.forEach(h => h());\n    };\n  }\n  const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, \"value\");\n  const hookProperties = [[currentWindow.HTMLInputElement.prototype, \"value\"], [currentWindow.HTMLInputElement.prototype, \"checked\"], [currentWindow.HTMLSelectElement.prototype, \"value\"], [currentWindow.HTMLTextAreaElement.prototype, \"value\"],\n  // Some UI library use selectedIndex to set select value\n  [currentWindow.HTMLSelectElement.prototype, \"selectedIndex\"], [currentWindow.HTMLOptionElement.prototype, \"selected\"]];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(...hookProperties.map(p => hookSetter(p[0], p[1], {\n      set() {\n        callbackWrapper(eventHandler)({\n          target: this,\n          isTrusted: false\n          // userTriggered to false as this could well be programmatic\n        });\n      }\n    }, false, currentWindow)));\n  }\n  return callbackWrapper(() => {\n    handlers.forEach(h => h());\n  });\n}\nfunction getNestedCSSRulePositions(rule) {\n  const positions = [];\n  function recurse(childRule, pos) {\n    if (hasNestedCSSRule(\"CSSGroupingRule\") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule(\"CSSMediaRule\") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule(\"CSSSupportsRule\") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule(\"CSSConditionRule\") && childRule.parentRule instanceof CSSConditionRule) {\n      const rules2 = Array.from(childRule.parentRule.cssRules);\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    } else if (childRule.parentStyleSheet) {\n      const rules2 = Array.from(childRule.parentStyleSheet.cssRules);\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    }\n    return pos;\n  }\n  return recurse(rule, positions);\n}\nfunction getIdAndStyleId(sheet, mirror2, styleMirror) {\n  let id, styleId;\n  if (!sheet) return {};\n  if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);else styleId = styleMirror.getId(sheet);\n  return {\n    styleId,\n    id\n  };\n}\nfunction initStyleSheetObserver({\n  styleSheetRuleCb,\n  mirror: mirror2,\n  stylesheetManager\n}, {\n  win\n}) {\n  if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n    return () => {};\n  }\n  const insertRule = win.CSSStyleSheet.prototype.insertRule;\n  win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n    apply: callbackWrapper((target, thisArg, argumentsList) => {\n      const [rule, index] = argumentsList;\n      const {\n        id,\n        styleId\n      } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);\n      if (id && id !== -1 || styleId && styleId !== -1) {\n        styleSheetRuleCb({\n          id,\n          styleId,\n          adds: [{\n            rule,\n            index\n          }]\n        });\n      }\n      return target.apply(thisArg, argumentsList);\n    })\n  });\n  const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n  win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n    apply: callbackWrapper((target, thisArg, argumentsList) => {\n      const [index] = argumentsList;\n      const {\n        id,\n        styleId\n      } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);\n      if (id && id !== -1 || styleId && styleId !== -1) {\n        styleSheetRuleCb({\n          id,\n          styleId,\n          removes: [{\n            index\n          }]\n        });\n      }\n      return target.apply(thisArg, argumentsList);\n    })\n  });\n  let replace;\n  if (win.CSSStyleSheet.prototype.replace) {\n    replace = win.CSSStyleSheet.prototype.replace;\n    win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n      apply: callbackWrapper((target, thisArg, argumentsList) => {\n        const [text] = argumentsList;\n        const {\n          id,\n          styleId\n        } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            replace: text\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      })\n    });\n  }\n  let replaceSync;\n  if (win.CSSStyleSheet.prototype.replaceSync) {\n    replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n    win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n      apply: callbackWrapper((target, thisArg, argumentsList) => {\n        const [text] = argumentsList;\n        const {\n          id,\n          styleId\n        } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            replaceSync: text\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      })\n    });\n  }\n  const supportedNestedCSSRuleTypes = {};\n  if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n  } else {\n    if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n    }\n    if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n    }\n    if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n    }\n  }\n  const unmodifiedFunctions = {};\n  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n    unmodifiedFunctions[typeKey] = {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      insertRule: type.prototype.insertRule,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      deleteRule: type.prototype.deleteRule\n    };\n    type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\n      apply: callbackWrapper((target, thisArg, argumentsList) => {\n        const [rule, index] = argumentsList;\n        const {\n          id,\n          styleId\n        } = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror);\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            adds: [{\n              rule,\n              index: [...getNestedCSSRulePositions(thisArg), index || 0\n              // defaults to 0\n              ]\n            }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      })\n    });\n    type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\n      apply: callbackWrapper((target, thisArg, argumentsList) => {\n        const [index] = argumentsList;\n        const {\n          id,\n          styleId\n        } = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror);\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            removes: [{\n              index: [...getNestedCSSRulePositions(thisArg), index]\n            }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      })\n    });\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleSheet.prototype.insertRule = insertRule;\n    win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n    replace && (win.CSSStyleSheet.prototype.replace = replace);\n    replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n    });\n  });\n}\nfunction initAdoptedStyleSheetObserver({\n  mirror: mirror2,\n  stylesheetManager\n}, host) {\n  let hostId = null;\n  if (host.nodeName === \"#document\") hostId = mirror2.getId(host);else hostId = mirror2.getId(host.host);\n  const patchTarget = host.nodeName === \"#document\" ? host.defaultView?.Document : host.ownerDocument?.defaultView?.ShadowRoot;\n  const originalPropertyDescriptor = patchTarget?.prototype ? Object.getOwnPropertyDescriptor(patchTarget?.prototype, \"adoptedStyleSheets\") : void 0;\n  if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor) return () => {};\n  Object.defineProperty(host, \"adoptedStyleSheets\", {\n    configurable: originalPropertyDescriptor.configurable,\n    enumerable: originalPropertyDescriptor.enumerable,\n    get() {\n      return originalPropertyDescriptor.get?.call(this);\n    },\n    set(sheets) {\n      const result = originalPropertyDescriptor.set?.call(this, sheets);\n      if (hostId !== null && hostId !== -1) {\n        try {\n          stylesheetManager.adoptStyleSheets(sheets, hostId);\n        } catch (e2) {}\n      }\n      return result;\n    }\n  });\n  return callbackWrapper(() => {\n    Object.defineProperty(host, \"adoptedStyleSheets\", {\n      configurable: originalPropertyDescriptor.configurable,\n      enumerable: originalPropertyDescriptor.enumerable,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      get: originalPropertyDescriptor.get,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      set: originalPropertyDescriptor.set\n    });\n  });\n}\nfunction initStyleDeclarationObserver({\n  styleDeclarationCb,\n  mirror: mirror2,\n  ignoreCSSAttributes,\n  stylesheetManager\n}, {\n  win\n}) {\n  const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n  win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n    apply: callbackWrapper((target, thisArg, argumentsList) => {\n      const [property, value, priority] = argumentsList;\n      if (ignoreCSSAttributes.has(property)) {\n        return setProperty.apply(thisArg, [property, value, priority]);\n      }\n      const {\n        id,\n        styleId\n      } = getIdAndStyleId(thisArg.parentRule?.parentStyleSheet, mirror2, stylesheetManager.styleMirror);\n      if (id && id !== -1 || styleId && styleId !== -1) {\n        styleDeclarationCb({\n          id,\n          styleId,\n          set: {\n            property,\n            value,\n            priority\n          },\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          index: getNestedCSSRulePositions(thisArg.parentRule)\n        });\n      }\n      return target.apply(thisArg, argumentsList);\n    })\n  });\n  const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n  win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n    apply: callbackWrapper((target, thisArg, argumentsList) => {\n      const [property] = argumentsList;\n      if (ignoreCSSAttributes.has(property)) {\n        return removeProperty.apply(thisArg, [property]);\n      }\n      const {\n        id,\n        styleId\n      } = getIdAndStyleId(thisArg.parentRule?.parentStyleSheet, mirror2, stylesheetManager.styleMirror);\n      if (id && id !== -1 || styleId && styleId !== -1) {\n        styleDeclarationCb({\n          id,\n          styleId,\n          remove: {\n            property\n          },\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          index: getNestedCSSRulePositions(thisArg.parentRule)\n        });\n      }\n      return target.apply(thisArg, argumentsList);\n    })\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n  });\n}\nfunction initMediaInteractionObserver({\n  mediaInteractionCb,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  mirror: mirror2,\n  sampling,\n  doc\n}) {\n  const handler = callbackWrapper(type => throttle$1(callbackWrapper(event => {\n    const target = getEventTarget(event);\n    if (!target || isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n      return;\n    }\n    const {\n      currentTime,\n      volume,\n      muted,\n      playbackRate\n    } = target;\n    mediaInteractionCb({\n      type,\n      id: mirror2.getId(target),\n      currentTime,\n      volume,\n      muted,\n      playbackRate\n    });\n  }), sampling.media || 500));\n  const handlers = [on(\"play\", handler(MediaInteractions.Play), doc), on(\"pause\", handler(MediaInteractions.Pause), doc), on(\"seeked\", handler(MediaInteractions.Seeked), doc), on(\"volumechange\", handler(MediaInteractions.VolumeChange), doc), on(\"ratechange\", handler(MediaInteractions.RateChange), doc)];\n  return callbackWrapper(() => {\n    handlers.forEach(h => h());\n  });\n}\nfunction initFontObserver({\n  fontCb,\n  doc\n}) {\n  const win = doc.defaultView;\n  if (!win) {\n    return () => {};\n  }\n  const handlers = [];\n  const fontMap = /* @__PURE__ */new WeakMap();\n  const originalFontFace = win.FontFace;\n  win.FontFace = function FontFace2(family, source, descriptors) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== \"string\",\n      descriptors,\n      fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n    });\n    return fontFace;\n  };\n  const restoreHandler = patch(doc.fonts, \"add\", function (original) {\n    return function (fontFace) {\n      setTimeout$1(callbackWrapper(() => {\n        const p = fontMap.get(fontFace);\n        if (p) {\n          fontCb(p);\n          fontMap.delete(fontFace);\n        }\n      }), 0);\n      return original.apply(this, [fontFace]);\n    };\n  });\n  handlers.push(() => {\n    win.FontFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n  return callbackWrapper(() => {\n    handlers.forEach(h => h());\n  });\n}\nfunction initSelectionObserver(param) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    selectionCb\n  } = param;\n  let collapsed = true;\n  const updateSelection = callbackWrapper(() => {\n    const selection = doc.getSelection();\n    if (!selection || collapsed && selection?.isCollapsed) return;\n    collapsed = selection.isCollapsed || false;\n    const ranges = [];\n    const count = selection.rangeCount || 0;\n    for (let i2 = 0; i2 < count; i2++) {\n      const range = selection.getRangeAt(i2);\n      const {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      } = range;\n      const blocked = isBlocked(startContainer, blockClass, blockSelector, unblockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, unblockSelector, true);\n      if (blocked) continue;\n      ranges.push({\n        start: mirror2.getId(startContainer),\n        startOffset,\n        end: mirror2.getId(endContainer),\n        endOffset\n      });\n    }\n    selectionCb({\n      ranges\n    });\n  });\n  updateSelection();\n  return on(\"selectionchange\", updateSelection);\n}\nfunction initCustomElementObserver({\n  doc,\n  customElementCb\n}) {\n  const win = doc.defaultView;\n  if (!win || !win.customElements) return () => {};\n  const restoreHandler = patch(win.customElements, \"define\", function (original) {\n    return function (name, constructor, options) {\n      try {\n        customElementCb({\n          define: {\n            name\n          }\n        });\n      } catch (e2) {}\n      return original.apply(this, [name, constructor, options]);\n    };\n  });\n  return restoreHandler;\n}\nfunction initObservers(o2, _hooks = {}) {\n  const currentWindow = o2.doc.defaultView;\n  if (!currentWindow) {\n    return () => {};\n  }\n  let mutationObserver;\n  if (o2.recordDOM) {\n    mutationObserver = initMutationObserver(o2, o2.doc);\n  }\n  const mousemoveHandler = initMoveObserver(o2);\n  const mouseInteractionHandler = initMouseInteractionObserver(o2);\n  const scrollHandler = initScrollObserver(o2);\n  const viewportResizeHandler = initViewportResizeObserver(o2, {\n    win: currentWindow\n  });\n  const inputHandler = initInputObserver(o2);\n  const mediaInteractionHandler = initMediaInteractionObserver(o2);\n  let styleSheetObserver = () => {};\n  let adoptedStyleSheetObserver = () => {};\n  let styleDeclarationObserver = () => {};\n  let fontObserver = () => {};\n  if (o2.recordDOM) {\n    styleSheetObserver = initStyleSheetObserver(o2, {\n      win: currentWindow\n    });\n    adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);\n    styleDeclarationObserver = initStyleDeclarationObserver(o2, {\n      win: currentWindow\n    });\n    if (o2.collectFonts) {\n      fontObserver = initFontObserver(o2);\n    }\n  }\n  const selectionObserver = initSelectionObserver(o2);\n  const customElementObserver = initCustomElementObserver(o2);\n  const pluginHandlers = [];\n  for (const plugin of o2.plugins) {\n    pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));\n  }\n  return callbackWrapper(() => {\n    mutationBuffers.forEach(b => b.reset());\n    mutationObserver?.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    adoptedStyleSheetObserver();\n    styleDeclarationObserver();\n    fontObserver();\n    selectionObserver();\n    customElementObserver();\n    pluginHandlers.forEach(h => h());\n  });\n}\nfunction hasNestedCSSRule(prop) {\n  return typeof window[prop] !== \"undefined\";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n  return Boolean(typeof window[prop] !== \"undefined\" &&\n  // Note: Generally, this check _shouldn't_ be necessary\n  // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here\n  window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype);\n}\nclass CrossOriginIframeMirror {\n  constructor(generateIdFn) {\n    this.generateIdFn = generateIdFn;\n    this.iframeIdToRemoteIdMap = /* @__PURE__ */new WeakMap();\n    this.iframeRemoteIdToIdMap = /* @__PURE__ */new WeakMap();\n  }\n  getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n    const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n    let id = idToRemoteIdMap.get(remoteId);\n    if (!id) {\n      id = this.generateIdFn();\n      idToRemoteIdMap.set(remoteId, id);\n      remoteIdToIdMap.set(id, remoteId);\n    }\n    return id;\n  }\n  getIds(iframe, remoteId) {\n    const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return remoteId.map(id => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap));\n  }\n  getRemoteId(iframe, id, map) {\n    const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n    if (typeof id !== \"number\") return id;\n    const remoteId = remoteIdToIdMap.get(id);\n    if (!remoteId) return -1;\n    return remoteId;\n  }\n  getRemoteIds(iframe, ids) {\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return ids.map(id => this.getRemoteId(iframe, id, remoteIdToIdMap));\n  }\n  reset(iframe) {\n    if (!iframe) {\n      this.iframeIdToRemoteIdMap = /* @__PURE__ */new WeakMap();\n      this.iframeRemoteIdToIdMap = /* @__PURE__ */new WeakMap();\n      return;\n    }\n    this.iframeIdToRemoteIdMap.delete(iframe);\n    this.iframeRemoteIdToIdMap.delete(iframe);\n  }\n  getIdToRemoteIdMap(iframe) {\n    let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n    if (!idToRemoteIdMap) {\n      idToRemoteIdMap = /* @__PURE__ */new Map();\n      this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n    }\n    return idToRemoteIdMap;\n  }\n  getRemoteIdToIdMap(iframe) {\n    let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n    if (!remoteIdToIdMap) {\n      remoteIdToIdMap = /* @__PURE__ */new Map();\n      this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n    }\n    return remoteIdToIdMap;\n  }\n}\nclass IframeManagerNoop {\n  constructor() {\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */new WeakMap();\n  }\n  addIframe() {}\n  addLoadListener() {}\n  attachIframe() {}\n}\nclass IframeManager {\n  constructor(options) {\n    this.iframes = /* @__PURE__ */new WeakMap();\n    this.crossOriginIframeMap = /* @__PURE__ */new WeakMap();\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */new WeakMap();\n    this.mutationCb = options.mutationCb;\n    this.wrappedEmit = options.wrappedEmit;\n    this.stylesheetManager = options.stylesheetManager;\n    this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\n    this.mirror = options.mirror;\n    if (this.recordCrossOriginIframes) {\n      window.addEventListener(\"message\", this.handleMessage.bind(this));\n    }\n  }\n  addIframe(iframeEl) {\n    this.iframes.set(iframeEl, true);\n    if (iframeEl.contentWindow) this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n  }\n  addLoadListener(cb) {\n    this.loadListener = cb;\n  }\n  attachIframe(iframeEl, childSn) {\n    this.mutationCb({\n      adds: [{\n        parentId: this.mirror.getId(iframeEl),\n        nextId: null,\n        node: childSn\n      }],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true\n    });\n    if (this.recordCrossOriginIframes) iframeEl.contentWindow?.addEventListener(\"message\", this.handleMessage.bind(this));\n    this.loadListener?.(iframeEl);\n    const iframeDoc = getIFrameContentDocument(iframeEl);\n    if (iframeDoc && iframeDoc.adoptedStyleSheets && iframeDoc.adoptedStyleSheets.length > 0) this.stylesheetManager.adoptStyleSheets(iframeDoc.adoptedStyleSheets, this.mirror.getId(iframeDoc));\n  }\n  handleMessage(message) {\n    const crossOriginMessageEvent = message;\n    if (crossOriginMessageEvent.data.type !== \"rrweb\" ||\n    // To filter out the rrweb messages which are forwarded by some sites.\n    crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin) return;\n    const iframeSourceWindow = message.source;\n    if (!iframeSourceWindow) return;\n    const iframeEl = this.crossOriginIframeMap.get(message.source);\n    if (!iframeEl) return;\n    const transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\n    if (transformedEvent) this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\n  }\n  transformCrossOriginEvent(iframeEl, e2) {\n    switch (e2.type) {\n      case EventType.FullSnapshot:\n        {\n          this.crossOriginIframeMirror.reset(iframeEl);\n          this.crossOriginIframeStyleMirror.reset(iframeEl);\n          this.replaceIdOnNode(e2.data.node, iframeEl);\n          const rootId = e2.data.node.id;\n          this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n          this.patchRootIdOnNode(e2.data.node, rootId);\n          return {\n            timestamp: e2.timestamp,\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Mutation,\n              adds: [{\n                parentId: this.mirror.getId(iframeEl),\n                nextId: null,\n                node: e2.data.node\n              }],\n              removes: [],\n              texts: [],\n              attributes: [],\n              isAttachIframe: true\n            }\n          };\n        }\n      case EventType.Meta:\n      case EventType.Load:\n      case EventType.DomContentLoaded:\n        {\n          return false;\n        }\n      case EventType.Plugin:\n        {\n          return e2;\n        }\n      case EventType.Custom:\n        {\n          this.replaceIds(e2.data.payload, iframeEl, [\"id\", \"parentId\", \"previousId\", \"nextId\"]);\n          return e2;\n        }\n      case EventType.IncrementalSnapshot:\n        {\n          switch (e2.data.source) {\n            case IncrementalSource.Mutation:\n              {\n                e2.data.adds.forEach(n2 => {\n                  this.replaceIds(n2, iframeEl, [\"parentId\", \"nextId\", \"previousId\"]);\n                  this.replaceIdOnNode(n2.node, iframeEl);\n                  const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\n                  rootId && this.patchRootIdOnNode(n2.node, rootId);\n                });\n                e2.data.removes.forEach(n2 => {\n                  this.replaceIds(n2, iframeEl, [\"parentId\", \"id\"]);\n                });\n                e2.data.attributes.forEach(n2 => {\n                  this.replaceIds(n2, iframeEl, [\"id\"]);\n                });\n                e2.data.texts.forEach(n2 => {\n                  this.replaceIds(n2, iframeEl, [\"id\"]);\n                });\n                return e2;\n              }\n            case IncrementalSource.Drag:\n            case IncrementalSource.TouchMove:\n            case IncrementalSource.MouseMove:\n              {\n                e2.data.positions.forEach(p => {\n                  this.replaceIds(p, iframeEl, [\"id\"]);\n                });\n                return e2;\n              }\n            case IncrementalSource.ViewportResize:\n              {\n                return false;\n              }\n            case IncrementalSource.MediaInteraction:\n            case IncrementalSource.MouseInteraction:\n            case IncrementalSource.Scroll:\n            case IncrementalSource.CanvasMutation:\n            case IncrementalSource.Input:\n              {\n                this.replaceIds(e2.data, iframeEl, [\"id\"]);\n                return e2;\n              }\n            case IncrementalSource.StyleSheetRule:\n            case IncrementalSource.StyleDeclaration:\n              {\n                this.replaceIds(e2.data, iframeEl, [\"id\"]);\n                this.replaceStyleIds(e2.data, iframeEl, [\"styleId\"]);\n                return e2;\n              }\n            case IncrementalSource.Font:\n              {\n                return e2;\n              }\n            case IncrementalSource.Selection:\n              {\n                e2.data.ranges.forEach(range => {\n                  this.replaceIds(range, iframeEl, [\"start\", \"end\"]);\n                });\n                return e2;\n              }\n            case IncrementalSource.AdoptedStyleSheet:\n              {\n                this.replaceIds(e2.data, iframeEl, [\"id\"]);\n                this.replaceStyleIds(e2.data, iframeEl, [\"styleIds\"]);\n                e2.data.styles?.forEach(style => {\n                  this.replaceStyleIds(style, iframeEl, [\"styleId\"]);\n                });\n                return e2;\n              }\n          }\n        }\n    }\n    return false;\n  }\n  replace(iframeMirror, obj, iframeEl, keys) {\n    for (const key of keys) {\n      if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\") continue;\n      if (Array.isArray(obj[key])) {\n        obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\n      } else {\n        obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n      }\n    }\n    return obj;\n  }\n  replaceIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n  }\n  replaceStyleIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n  }\n  replaceIdOnNode(node, iframeEl) {\n    this.replaceIds(node, iframeEl, [\"id\", \"rootId\"]);\n    if (\"childNodes\" in node) {\n      node.childNodes.forEach(child => {\n        this.replaceIdOnNode(child, iframeEl);\n      });\n    }\n  }\n  patchRootIdOnNode(node, rootId) {\n    if (node.type !== NodeType$2.Document && !node.rootId) node.rootId = rootId;\n    if (\"childNodes\" in node) {\n      node.childNodes.forEach(child => {\n        this.patchRootIdOnNode(child, rootId);\n      });\n    }\n  }\n}\nclass ShadowDomManagerNoop {\n  init() {}\n  addShadowRoot() {}\n  observeAttachShadow() {}\n  reset() {}\n}\nclass ShadowDomManager {\n  constructor(options) {\n    this.shadowDoms = /* @__PURE__ */new WeakSet();\n    this.restoreHandlers = [];\n    this.mutationCb = options.mutationCb;\n    this.scrollCb = options.scrollCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n    this.init();\n  }\n  init() {\n    this.reset();\n    this.patchAttachShadow(Element, document);\n  }\n  addShadowRoot(shadowRoot, doc) {\n    if (!isNativeShadowDom(shadowRoot)) return;\n    if (this.shadowDoms.has(shadowRoot)) return;\n    this.shadowDoms.add(shadowRoot);\n    this.bypassOptions.canvasManager.addShadowRoot(shadowRoot);\n    const observer = initMutationObserver({\n      ...this.bypassOptions,\n      doc,\n      mutationCb: this.mutationCb,\n      mirror: this.mirror,\n      shadowDomManager: this\n    }, shadowRoot);\n    this.restoreHandlers.push(() => observer.disconnect());\n    this.restoreHandlers.push(initScrollObserver({\n      ...this.bypassOptions,\n      scrollCb: this.scrollCb,\n      // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813\n      // scroll is not allowed to pass the boundary, so we need to listen the shadow document\n      doc: shadowRoot,\n      mirror: this.mirror\n    }));\n    setTimeout$1(() => {\n      if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0) this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot.adoptedStyleSheets, this.mirror.getId(shadowRoot.host));\n      this.restoreHandlers.push(initAdoptedStyleSheetObserver({\n        mirror: this.mirror,\n        stylesheetManager: this.bypassOptions.stylesheetManager\n      }, shadowRoot));\n    }, 0);\n  }\n  /**\n   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.\n   */\n  observeAttachShadow(iframeElement) {\n    const iframeDoc = getIFrameContentDocument(iframeElement);\n    const iframeWindow = getIFrameContentWindow(iframeElement);\n    if (!iframeDoc || !iframeWindow) return;\n    this.patchAttachShadow(iframeWindow.Element, iframeDoc);\n  }\n  /**\n   * Patch 'attachShadow' to observe newly added shadow doms.\n   */\n  patchAttachShadow(element, doc) {\n    const manager = this;\n    this.restoreHandlers.push(patch(element.prototype, \"attachShadow\", function (original) {\n      return function (option) {\n        const shadowRoot = original.call(this, option);\n        if (this.shadowRoot && inDom(this)) manager.addShadowRoot(this.shadowRoot, doc);\n        return shadowRoot;\n      };\n    }));\n  }\n  reset() {\n    this.restoreHandlers.forEach(handler => {\n      try {\n        handler();\n      } catch (e2) {}\n    });\n    this.restoreHandlers = [];\n    this.shadowDoms = /* @__PURE__ */new WeakSet();\n    this.bypassOptions.canvasManager.resetShadowRoots();\n  }\n}\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (var i$1 = 0; i$1 < chars.length; i$1++) {\n  lookup[chars.charCodeAt(i$1)] = i$1;\n}\nclass CanvasManagerNoop {\n  reset() {}\n  freeze() {}\n  unfreeze() {}\n  lock() {}\n  unlock() {}\n  snapshot() {}\n  addWindow() {}\n  addShadowRoot() {}\n  resetShadowRoots() {}\n}\nclass StylesheetManager {\n  constructor(options) {\n    this.trackedLinkElements = /* @__PURE__ */new WeakSet();\n    this.styleMirror = new StyleSheetMirror();\n    this.mutationCb = options.mutationCb;\n    this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n  }\n  attachLinkElement(linkEl, childSn) {\n    if (\"_cssText\" in childSn.attributes) this.mutationCb({\n      adds: [],\n      removes: [],\n      texts: [],\n      attributes: [{\n        id: childSn.id,\n        attributes: childSn.attributes\n      }]\n    });\n    this.trackLinkElement(linkEl);\n  }\n  trackLinkElement(linkEl) {\n    if (this.trackedLinkElements.has(linkEl)) return;\n    this.trackedLinkElements.add(linkEl);\n    this.trackStylesheetInLinkElement(linkEl);\n  }\n  adoptStyleSheets(sheets, hostId) {\n    if (sheets.length === 0) return;\n    const adoptedStyleSheetData = {\n      id: hostId,\n      styleIds: []\n    };\n    const styles = [];\n    for (const sheet of sheets) {\n      let styleId;\n      if (!this.styleMirror.has(sheet)) {\n        styleId = this.styleMirror.add(sheet);\n        styles.push({\n          styleId,\n          rules: Array.from(sheet.rules || CSSRule, (r2, index) => ({\n            rule: stringifyRule(r2),\n            index\n          }))\n        });\n      } else styleId = this.styleMirror.getId(sheet);\n      adoptedStyleSheetData.styleIds.push(styleId);\n    }\n    if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n    this.adoptedStyleSheetCb(adoptedStyleSheetData);\n  }\n  reset() {\n    this.styleMirror.reset();\n    this.trackedLinkElements = /* @__PURE__ */new WeakSet();\n  }\n  // TODO: take snapshot on stylesheet reload by applying event listener\n  trackStylesheetInLinkElement(_linkEl) {}\n}\nclass ProcessedNodeManager {\n  constructor() {\n    this.nodeMap = /* @__PURE__ */new WeakMap();\n    this.active = false;\n  }\n  inOtherBuffer(node, thisBuffer) {\n    const buffers = this.nodeMap.get(node);\n    return buffers && Array.from(buffers).some(buffer => buffer !== thisBuffer);\n  }\n  add(node, buffer) {\n    if (!this.active) {\n      this.active = true;\n      onRequestAnimationFrame(() => {\n        this.nodeMap = /* @__PURE__ */new WeakMap();\n        this.active = false;\n      });\n    }\n    this.nodeMap.set(node, (this.nodeMap.get(node) || /* @__PURE__ */new Set()).add(buffer));\n  }\n  destroy() {}\n}\nlet wrappedEmit;\nlet _takeFullSnapshot;\ntry {\n  if (Array.from([1], x => x * 2)[0] !== 2) {\n    const cleanFrame = document.createElement(\"iframe\");\n    document.body.appendChild(cleanFrame);\n    Array.from = cleanFrame.contentWindow?.Array.from || Array.from;\n    document.body.removeChild(cleanFrame);\n  }\n} catch (err) {\n  console.debug(\"Unable to override Array.from\", err);\n}\nconst mirror = createMirror$2();\nfunction record(options = {}) {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    ignoreClass = \"rr-ignore\",\n    ignoreSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskAttributeFn,\n    maskInputFn,\n    maskTextFn,\n    maxCanvasSize = null,\n    packFn,\n    sampling = {},\n    dataURLOptions = {},\n    mousemoveWait,\n    recordDOM = true,\n    recordCanvas = false,\n    recordCrossOriginIframes = false,\n    recordAfter = options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\",\n    userTriggeredOnInput = false,\n    collectFonts = false,\n    inlineImages = false,\n    plugins,\n    keepIframeSrcFn = () => false,\n    ignoreCSSAttributes = /* @__PURE__ */new Set([]),\n    errorHandler: errorHandler2,\n    onMutation,\n    getCanvasManager\n  } = options;\n  registerErrorHandler(errorHandler2);\n  const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n  let passEmitsToParent = false;\n  if (!inEmittingFrame) {\n    try {\n      if (window.parent.document) {\n        passEmitsToParent = false;\n      }\n    } catch (e2) {\n      passEmitsToParent = true;\n    }\n  }\n  if (inEmittingFrame && !emit) {\n    throw new Error(\"emit function is required\");\n  }\n  if (!inEmittingFrame && !passEmitsToParent) {\n    return () => {};\n  }\n  if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {\n    sampling.mousemove = mousemoveWait;\n  }\n  mirror.reset();\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true,\n    radio: true,\n    checkbox: true\n  } : _maskInputOptions !== void 0 ? _maskInputOptions : {};\n  const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n    script: true,\n    comment: true,\n    headFavicon: true,\n    headWhitespace: true,\n    headMetaSocial: true,\n    headMetaRobots: true,\n    headMetaHttpEquiv: true,\n    headMetaVerification: true,\n    // the following are off for slimDOMOptions === true,\n    // as they destroy some (hidden) info:\n    headMetaAuthorship: _slimDOMOptions === \"all\",\n    headMetaDescKeywords: _slimDOMOptions === \"all\"\n  } : _slimDOMOptions ? _slimDOMOptions : {};\n  polyfill$1();\n  let lastFullSnapshotEvent;\n  let incrementalSnapshotCount = 0;\n  const eventProcessor = e2 => {\n    for (const plugin of plugins || []) {\n      if (plugin.eventProcessor) {\n        e2 = plugin.eventProcessor(e2);\n      }\n    }\n    if (packFn &&\n    // Disable packing events which will be emitted to parent frames.\n    !passEmitsToParent) {\n      e2 = packFn(e2);\n    }\n    return e2;\n  };\n  wrappedEmit = (r2, isCheckout) => {\n    const e2 = r2;\n    e2.timestamp = nowTimestamp();\n    if (mutationBuffers[0]?.isFrozen() && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {\n      mutationBuffers.forEach(buf => buf.unfreeze());\n    }\n    if (inEmittingFrame) {\n      emit?.(eventProcessor(e2), isCheckout);\n    } else if (passEmitsToParent) {\n      const message = {\n        type: \"rrweb\",\n        event: eventProcessor(e2),\n        origin: window.location.origin,\n        isCheckout\n      };\n      window.parent.postMessage(message, \"*\");\n    }\n    if (e2.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e2;\n      incrementalSnapshotCount = 0;\n    } else if (e2.type === EventType.IncrementalSnapshot) {\n      if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {\n        return;\n      }\n      incrementalSnapshotCount++;\n      const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime = checkoutEveryNms && lastFullSnapshotEvent && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot2(true);\n      }\n    }\n  };\n  const wrappedMutationEmit = m => {\n    wrappedEmit({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.Mutation,\n        ...m\n      }\n    });\n  };\n  const wrappedScrollEmit = p => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.Scroll,\n      ...p\n    }\n  });\n  const wrappedCanvasMutationEmit = p => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.CanvasMutation,\n      ...p\n    }\n  });\n  const wrappedAdoptedStyleSheetEmit = a2 => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.AdoptedStyleSheet,\n      ...a2\n    }\n  });\n  const stylesheetManager = new StylesheetManager({\n    mutationCb: wrappedMutationEmit,\n    adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n  });\n  const iframeManager = typeof __RRWEB_EXCLUDE_IFRAME__ === \"boolean\" && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop() : new IframeManager({\n    mirror,\n    mutationCb: wrappedMutationEmit,\n    stylesheetManager,\n    recordCrossOriginIframes,\n    wrappedEmit\n  });\n  for (const plugin of plugins || []) {\n    if (plugin.getMirror) plugin.getMirror({\n      nodeMirror: mirror,\n      crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n      crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n    });\n  }\n  const processedNodeManager = new ProcessedNodeManager();\n  const canvasManager = _getCanvasManager(getCanvasManager, {\n    mirror,\n    win: window,\n    mutationCb: p => wrappedEmit({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.CanvasMutation,\n        ...p\n      }\n    }),\n    recordCanvas,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maxCanvasSize,\n    sampling: sampling[\"canvas\"],\n    dataURLOptions,\n    errorHandler: errorHandler2\n  });\n  const shadowDomManager = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ === \"boolean\" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop() : new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    scrollCb: wrappedScrollEmit,\n    bypassOptions: {\n      onMutation,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      dataURLOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      recordCanvas,\n      inlineImages,\n      sampling,\n      slimDOMOptions,\n      iframeManager,\n      stylesheetManager,\n      canvasManager,\n      keepIframeSrcFn,\n      processedNodeManager\n    },\n    mirror\n  });\n  const takeFullSnapshot2 = (isCheckout = false) => {\n    if (!recordDOM) {\n      return;\n    }\n    wrappedEmit({\n      type: EventType.Meta,\n      data: {\n        href: window.location.href,\n        width: getWindowWidth(),\n        height: getWindowHeight()\n      }\n    }, isCheckout);\n    stylesheetManager.reset();\n    shadowDomManager.init();\n    mutationBuffers.forEach(buf => buf.lock());\n    const node = snapshot(document, {\n      mirror,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskAttributeFn,\n      maskInputFn,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      dataURLOptions,\n      recordCanvas,\n      inlineImages,\n      onSerialize: n2 => {\n        if (isSerializedIframe(n2, mirror)) {\n          iframeManager.addIframe(n2);\n        }\n        if (isSerializedStylesheet(n2, mirror)) {\n          stylesheetManager.trackLinkElement(n2);\n        }\n        if (hasShadowRoot(n2)) {\n          shadowDomManager.addShadowRoot(n2.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n        if (iframe.contentWindow) {\n          canvasManager.addWindow(iframe.contentWindow);\n        }\n        shadowDomManager.observeAttachShadow(iframe);\n      },\n      onStylesheetLoad: (linkEl, childSn) => {\n        stylesheetManager.attachLinkElement(linkEl, childSn);\n      },\n      keepIframeSrcFn\n    });\n    if (!node) {\n      return console.warn(\"Failed to snapshot the document\");\n    }\n    wrappedEmit({\n      type: EventType.FullSnapshot,\n      data: {\n        node,\n        initialOffset: getWindowScroll(window)\n      }\n    });\n    mutationBuffers.forEach(buf => buf.unlock());\n    if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0) stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\n  };\n  _takeFullSnapshot = takeFullSnapshot2;\n  try {\n    const handlers = [];\n    const observe = doc => {\n      return callbackWrapper(initObservers)({\n        onMutation,\n        mutationCb: wrappedMutationEmit,\n        mousemoveCb: (positions, source) => wrappedEmit({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source,\n            positions\n          }\n        }),\n        mouseInteractionCb: d => wrappedEmit({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.MouseInteraction,\n            ...d\n          }\n        }),\n        scrollCb: wrappedScrollEmit,\n        viewportResizeCb: d => wrappedEmit({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.ViewportResize,\n            ...d\n          }\n        }),\n        inputCb: v2 => wrappedEmit({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.Input,\n            ...v2\n          }\n        }),\n        mediaInteractionCb: p => wrappedEmit({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.MediaInteraction,\n            ...p\n          }\n        }),\n        styleSheetRuleCb: r2 => wrappedEmit({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.StyleSheetRule,\n            ...r2\n          }\n        }),\n        styleDeclarationCb: r2 => wrappedEmit({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.StyleDeclaration,\n            ...r2\n          }\n        }),\n        canvasMutationCb: wrappedCanvasMutationEmit,\n        fontCb: p => wrappedEmit({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.Font,\n            ...p\n          }\n        }),\n        selectionCb: p => {\n          wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Selection,\n              ...p\n            }\n          });\n        },\n        customElementCb: c2 => {\n          wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.CustomElement,\n              ...c2\n            }\n          });\n        },\n        blockClass,\n        ignoreClass,\n        ignoreSelector,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        maskInputOptions,\n        inlineStylesheet,\n        sampling,\n        recordDOM,\n        recordCanvas,\n        inlineImages,\n        userTriggeredOnInput,\n        collectFonts,\n        doc,\n        maskAttributeFn,\n        maskInputFn,\n        maskTextFn,\n        keepIframeSrcFn,\n        blockSelector,\n        unblockSelector,\n        slimDOMOptions,\n        dataURLOptions,\n        mirror,\n        iframeManager,\n        stylesheetManager,\n        shadowDomManager,\n        processedNodeManager,\n        canvasManager,\n        ignoreCSSAttributes,\n        plugins: plugins?.filter(p => p.observer)?.map(p => ({\n          observer: p.observer,\n          options: p.options,\n          callback: payload => wrappedEmit({\n            type: EventType.Plugin,\n            data: {\n              plugin: p.name,\n              payload\n            }\n          })\n        })) || []\n      }, {});\n    };\n    iframeManager.addLoadListener(iframeEl => {\n      try {\n        handlers.push(observe(iframeEl.contentDocument));\n      } catch (error) {\n        console.warn(error);\n      }\n    });\n    const init = () => {\n      takeFullSnapshot2();\n      handlers.push(observe(document));\n    };\n    if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n      init();\n    } else {\n      handlers.push(on(\"DOMContentLoaded\", () => {\n        wrappedEmit({\n          type: EventType.DomContentLoaded,\n          data: {}\n        });\n        if (recordAfter === \"DOMContentLoaded\") init();\n      }));\n      handlers.push(on(\"load\", () => {\n        wrappedEmit({\n          type: EventType.Load,\n          data: {}\n        });\n        if (recordAfter === \"load\") init();\n      }, window));\n    }\n    return () => {\n      handlers.forEach(h => h());\n      processedNodeManager.destroy();\n      _takeFullSnapshot = void 0;\n      unregisterErrorHandler();\n    };\n  } catch (error) {\n    console.warn(error);\n  }\n}\nfunction takeFullSnapshot(isCheckout) {\n  if (!_takeFullSnapshot) {\n    throw new Error(\"please take full snapshot after start recording\");\n  }\n  _takeFullSnapshot(isCheckout);\n}\nrecord.mirror = mirror;\nrecord.takeFullSnapshot = takeFullSnapshot;\nfunction _getCanvasManager(getCanvasManagerFn, options) {\n  try {\n    return getCanvasManagerFn ? getCanvasManagerFn(options) : new CanvasManagerNoop();\n  } catch {\n    console.warn(\"Unable to initialize CanvasManager\");\n    return new CanvasManagerNoop();\n  }\n}\nvar n;\n!function (t2) {\n  t2[t2.NotStarted = 0] = \"NotStarted\", t2[t2.Running = 1] = \"Running\", t2[t2.Stopped = 2] = \"Stopped\";\n}(n || (n = {}));\nconst ReplayEventTypeIncrementalSnapshot = 3;\nconst ReplayEventTypeCustom = 5;\n\n/**\n * Converts a timestamp to ms, if it was in s, or keeps it as ms.\n */\nfunction timestampToMs(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp : timestamp * 1000;\n}\n\n/**\n * Converts a timestamp to s, if it was in ms, or keeps it as s.\n */\nfunction timestampToS(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n\n/**\n * Add a breadcrumb event to replay.\n */\nfunction addBreadcrumbEvent(replay, breadcrumb) {\n  if (breadcrumb.category === 'sentry.transaction') {\n    return;\n  }\n  if (['ui.click', 'ui.input'].includes(breadcrumb.category)) {\n    replay.triggerUserActivity();\n  } else {\n    replay.checkAndHandleExpiredSession();\n  }\n  replay.addUpdate(() => {\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      // TODO: We were converting from ms to seconds for breadcrumbs, spans,\n      // but maybe we should just keep them as milliseconds\n      timestamp: (breadcrumb.timestamp || 0) * 1000,\n      data: {\n        tag: 'breadcrumb',\n        // normalize to max. 10 depth and 1_000 properties per object\n        payload: normalize(breadcrumb, 10, 1000)\n      }\n    });\n\n    // Do not flush after console log messages\n    return breadcrumb.category === 'console';\n  });\n}\nconst INTERACTIVE_SELECTOR = 'button,a';\n\n/** Get the closest interactive parent element, or else return the given element. */\nfunction getClosestInteractive(element) {\n  const closestInteractive = element.closest(INTERACTIVE_SELECTOR);\n  return closestInteractive || element;\n}\n\n/**\n * For clicks, we check if the target is inside of a button or link\n * If so, we use this as the target instead\n * This is useful because if you click on the image in <button><img></button>,\n * The target will be the image, not the button, which we don't want here\n */\nfunction getClickTargetNode(event) {\n  const target = getTargetNode(event);\n  if (!target || !(target instanceof Element)) {\n    return target;\n  }\n  return getClosestInteractive(target);\n}\n\n/** Get the event target node. */\nfunction getTargetNode(event) {\n  if (isEventWithTarget(event)) {\n    return event.target;\n  }\n  return event;\n}\nfunction isEventWithTarget(event) {\n  return typeof event === 'object' && !!event && 'target' in event;\n}\nlet handlers;\n\n/**\n * Register a handler to be called when `window.open()` is called.\n * Returns a cleanup function.\n */\nfunction onWindowOpen(cb) {\n  // Ensure to only register this once\n  if (!handlers) {\n    handlers = [];\n    monkeyPatchWindowOpen();\n  }\n  handlers.push(cb);\n  return () => {\n    const pos = handlers ? handlers.indexOf(cb) : -1;\n    if (pos > -1) {\n      handlers.splice(pos, 1);\n    }\n  };\n}\nfunction monkeyPatchWindowOpen() {\n  fill(WINDOW, 'open', function (originalWindowOpen) {\n    return function (...args) {\n      if (handlers) {\n        try {\n          handlers.forEach(handler => handler());\n        } catch (e) {\n          // ignore errors in here\n        }\n      }\n      return originalWindowOpen.apply(WINDOW, args);\n    };\n  });\n}\n\n/** Any IncrementalSource for rrweb that we interpret as a kind of mutation. */\nconst IncrementalMutationSources = new Set([IncrementalSource.Mutation, IncrementalSource.StyleSheetRule, IncrementalSource.StyleDeclaration, IncrementalSource.AdoptedStyleSheet, IncrementalSource.CanvasMutation, IncrementalSource.Selection, IncrementalSource.MediaInteraction]);\n\n/** Handle a click. */\nfunction handleClick(clickDetector, clickBreadcrumb, node) {\n  clickDetector.handleClick(clickBreadcrumb, node);\n}\n\n/** A click detector class that can be used to detect slow or rage clicks on elements. */\nclass ClickDetector {\n  // protected for testing\n\n  constructor(replay, slowClickConfig,\n  // Just for easier testing\n  _addBreadcrumbEvent = addBreadcrumbEvent) {\n    this._lastMutation = 0;\n    this._lastScroll = 0;\n    this._clicks = [];\n\n    // We want everything in s, but options are in ms\n    this._timeout = slowClickConfig.timeout / 1000;\n    this._threshold = slowClickConfig.threshold / 1000;\n    this._scrollTimeout = slowClickConfig.scrollTimeout / 1000;\n    this._replay = replay;\n    this._ignoreSelector = slowClickConfig.ignoreSelector;\n    this._addBreadcrumbEvent = _addBreadcrumbEvent;\n  }\n\n  /** Register click detection handlers on mutation or scroll. */\n  addListeners() {\n    const cleanupWindowOpen = onWindowOpen(() => {\n      // Treat window.open as mutation\n      this._lastMutation = nowInSeconds();\n    });\n    this._teardown = () => {\n      cleanupWindowOpen();\n      this._clicks = [];\n      this._lastMutation = 0;\n      this._lastScroll = 0;\n    };\n  }\n\n  /** Clean up listeners. */\n  removeListeners() {\n    if (this._teardown) {\n      this._teardown();\n    }\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n  }\n\n  /** @inheritDoc */\n  handleClick(breadcrumb, node) {\n    if (ignoreElement(node, this._ignoreSelector) || !isClickBreadcrumb(breadcrumb)) {\n      return;\n    }\n    const newClick = {\n      timestamp: timestampToS(breadcrumb.timestamp),\n      clickBreadcrumb: breadcrumb,\n      // Set this to 0 so we know it originates from the click breadcrumb\n      clickCount: 0,\n      node\n    };\n\n    // If there was a click in the last 1s on the same element, ignore it - only keep a single reference per second\n    if (this._clicks.some(click => click.node === newClick.node && Math.abs(click.timestamp - newClick.timestamp) < 1)) {\n      return;\n    }\n    this._clicks.push(newClick);\n\n    // If this is the first new click, set a timeout to check for multi clicks\n    if (this._clicks.length === 1) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** @inheritDoc */\n  registerMutation(timestamp = Date.now()) {\n    this._lastMutation = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n  registerScroll(timestamp = Date.now()) {\n    this._lastScroll = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n  registerClick(element) {\n    const node = getClosestInteractive(element);\n    this._handleMultiClick(node);\n  }\n\n  /** Count multiple clicks on elements. */\n  _handleMultiClick(node) {\n    this._getClicks(node).forEach(click => {\n      click.clickCount++;\n    });\n  }\n\n  /** Get all pending clicks for a given node. */\n  _getClicks(node) {\n    return this._clicks.filter(click => click.node === node);\n  }\n\n  /** Check the clicks that happened. */\n  _checkClicks() {\n    const timedOutClicks = [];\n    const now = nowInSeconds();\n    this._clicks.forEach(click => {\n      if (!click.mutationAfter && this._lastMutation) {\n        click.mutationAfter = click.timestamp <= this._lastMutation ? this._lastMutation - click.timestamp : undefined;\n      }\n      if (!click.scrollAfter && this._lastScroll) {\n        click.scrollAfter = click.timestamp <= this._lastScroll ? this._lastScroll - click.timestamp : undefined;\n      }\n\n      // All of these are in seconds!\n      if (click.timestamp + this._timeout <= now) {\n        timedOutClicks.push(click);\n      }\n    });\n\n    // Remove \"old\" clicks\n    for (const click of timedOutClicks) {\n      const pos = this._clicks.indexOf(click);\n      if (pos > -1) {\n        this._generateBreadcrumbs(click);\n        this._clicks.splice(pos, 1);\n      }\n    }\n\n    // Trigger new check, unless no clicks left\n    if (this._clicks.length) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** Generate matching breadcrumb(s) for the click. */\n  _generateBreadcrumbs(click) {\n    const replay = this._replay;\n    const hadScroll = click.scrollAfter && click.scrollAfter <= this._scrollTimeout;\n    const hadMutation = click.mutationAfter && click.mutationAfter <= this._threshold;\n    const isSlowClick = !hadScroll && !hadMutation;\n    const {\n      clickCount,\n      clickBreadcrumb\n    } = click;\n\n    // Slow click\n    if (isSlowClick) {\n      // If `mutationAfter` is set, it means a mutation happened after the threshold, but before the timeout\n      // If not, it means we just timed out without scroll & mutation\n      const timeAfterClickMs = Math.min(click.mutationAfter || this._timeout, this._timeout) * 1000;\n      const endReason = timeAfterClickMs < this._timeout * 1000 ? 'mutation' : 'timeout';\n      const breadcrumb = {\n        type: 'default',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: 'ui.slowClickDetected',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          timeAfterClickMs,\n          endReason,\n          // If clickCount === 0, it means multiClick was not correctly captured here\n          // - we still want to send 1 in this case\n          clickCount: clickCount || 1\n        }\n      };\n      this._addBreadcrumbEvent(replay, breadcrumb);\n      return;\n    }\n\n    // Multi click\n    if (clickCount > 1) {\n      const breadcrumb = {\n        type: 'default',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: 'ui.multiClick',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          clickCount,\n          metric: true\n        }\n      };\n      this._addBreadcrumbEvent(replay, breadcrumb);\n    }\n  }\n\n  /** Schedule to check current clicks. */\n  _scheduleCheckClicks() {\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n    this._checkClickTimeout = setTimeout$3(() => this._checkClicks(), 1000);\n  }\n}\nconst SLOW_CLICK_TAGS = ['A', 'BUTTON', 'INPUT'];\n\n/** exported for tests only */\nfunction ignoreElement(node, ignoreSelector) {\n  if (!SLOW_CLICK_TAGS.includes(node.tagName)) {\n    return true;\n  }\n\n  // If <input> tag, we only want to consider input[type='submit'] & input[type='button']\n  if (node.tagName === 'INPUT' && !['submit', 'button'].includes(node.getAttribute('type') || '')) {\n    return true;\n  }\n\n  // If <a> tag, detect special variants that may not lead to an action\n  // If target !== _self, we may open the link somewhere else, which would lead to no action\n  // Also, when downloading a file, we may not leave the page, but still not trigger an action\n  if (node.tagName === 'A' && (node.hasAttribute('download') || node.hasAttribute('target') && node.getAttribute('target') !== '_self')) {\n    return true;\n  }\n  if (ignoreSelector && node.matches(ignoreSelector)) {\n    return true;\n  }\n  return false;\n}\nfunction isClickBreadcrumb(breadcrumb) {\n  return !!(breadcrumb.data && typeof breadcrumb.data.nodeId === 'number' && breadcrumb.timestamp);\n}\n\n// This is good enough for us, and is easier to test/mock than `timestampInSeconds`\nfunction nowInSeconds() {\n  return Date.now() / 1000;\n}\n\n/** Update the click detector based on a recording event of rrweb. */\nfunction updateClickDetectorForRecordingEvent(clickDetector, event) {\n  try {\n    // note: We only consider incremental snapshots here\n    // This means that any full snapshot is ignored for mutation detection - the reason is that we simply cannot know if a mutation happened here.\n    // E.g. think that we are buffering, an error happens and we take a full snapshot because we switched to session mode -\n    // in this scenario, we would not know if a dead click happened because of the error, which is a key dead click scenario.\n    // Instead, by ignoring full snapshots, we have the risk that we generate a false positive\n    // (if a mutation _did_ happen but was \"swallowed\" by the full snapshot)\n    // But this should be more unlikely as we'd generally capture the incremental snapshot right away\n\n    if (!isIncrementalEvent(event)) {\n      return;\n    }\n    const {\n      source\n    } = event.data;\n    if (IncrementalMutationSources.has(source)) {\n      clickDetector.registerMutation(event.timestamp);\n    }\n    if (source === IncrementalSource.Scroll) {\n      clickDetector.registerScroll(event.timestamp);\n    }\n    if (isIncrementalMouseInteraction(event)) {\n      const {\n        type,\n        id\n      } = event.data;\n      const node = record.mirror.getNode(id);\n      if (node instanceof HTMLElement && type === MouseInteractions.Click) {\n        clickDetector.registerClick(node);\n      }\n    }\n  } catch {\n    // ignore errors here, e.g. if accessing something that does not exist\n  }\n}\nfunction isIncrementalEvent(event) {\n  return event.type === ReplayEventTypeIncrementalSnapshot;\n}\nfunction isIncrementalMouseInteraction(event) {\n  return event.data.source === IncrementalSource.MouseInteraction;\n}\n\n/**\n * Create a breadcrumb for a replay.\n */\nfunction createBreadcrumb(breadcrumb) {\n  return {\n    timestamp: Date.now() / 1000,\n    type: 'default',\n    ...breadcrumb\n  };\n}\nvar NodeType = /* @__PURE__ */(NodeType2 => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType || {});\n\n// Note that these are the serialized attributes and not attributes directly on\n// the DOM Node. Attributes we are interested in:\nconst ATTRIBUTES_TO_RECORD = new Set(['id', 'class', 'aria-label', 'role', 'name', 'alt', 'title', 'data-test-id', 'data-testid', 'disabled', 'aria-disabled', 'data-sentry-component']);\n\n/**\n * Inclusion list of attributes that we want to record from the DOM element\n */\nfunction getAttributesToRecord(attributes) {\n  const obj = {};\n  if (!attributes['data-sentry-component'] && attributes['data-sentry-element']) {\n    attributes['data-sentry-component'] = attributes['data-sentry-element'];\n  }\n  for (const key in attributes) {\n    if (ATTRIBUTES_TO_RECORD.has(key)) {\n      let normalizedKey = key;\n      if (key === 'data-testid' || key === 'data-test-id') {\n        normalizedKey = 'testId';\n      }\n      obj[normalizedKey] = attributes[key];\n    }\n  }\n  return obj;\n}\nconst handleDomListener = replay => {\n  return handlerData => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n    const result = handleDom(handlerData);\n    if (!result) {\n      return;\n    }\n    const isClick = handlerData.name === 'click';\n    const event = isClick ? handlerData.event : undefined;\n    // Ignore clicks if ctrl/alt/meta/shift keys are held down as they alter behavior of clicks (e.g. open in new tab)\n    if (isClick && replay.clickDetector && event && event.target && !event.altKey && !event.metaKey && !event.ctrlKey && !event.shiftKey) {\n      handleClick(replay.clickDetector, result, getClickTargetNode(handlerData.event));\n    }\n    addBreadcrumbEvent(replay, result);\n  };\n};\n\n/** Get the base DOM breadcrumb. */\nfunction getBaseDomBreadcrumb(target, message) {\n  const nodeId = record.mirror.getId(target);\n  const node = nodeId && record.mirror.getNode(nodeId);\n  const meta = node && record.mirror.getMeta(node);\n  const element = meta && isElement(meta) ? meta : null;\n  return {\n    message,\n    data: element ? {\n      nodeId,\n      node: {\n        id: nodeId,\n        tagName: element.tagName,\n        textContent: Array.from(element.childNodes).map(node => node.type === NodeType.Text && node.textContent).filter(Boolean) // filter out empty values\n        .map(text => text.trim()).join(''),\n        attributes: getAttributesToRecord(element.attributes)\n      }\n    } : {}\n  };\n}\n\n/**\n * An event handler to react to DOM events.\n * Exported for tests.\n */\nfunction handleDom(handlerData) {\n  const {\n    target,\n    message\n  } = getDomTarget(handlerData);\n  return createBreadcrumb({\n    category: `ui.${handlerData.name}`,\n    ...getBaseDomBreadcrumb(target, message)\n  });\n}\nfunction getDomTarget(handlerData) {\n  const isClick = handlerData.name === 'click';\n  let message;\n  let target = null;\n\n  // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n  try {\n    target = isClick ? getClickTargetNode(handlerData.event) : getTargetNode(handlerData.event);\n    message = htmlTreeAsString(target, {\n      maxStringLength: 200\n    }) || '<unknown>';\n  } catch (e) {\n    message = '<unknown>';\n  }\n  return {\n    target,\n    message\n  };\n}\nfunction isElement(node) {\n  return node.type === NodeType.Element;\n}\n\n/** Handle keyboard events & create breadcrumbs. */\nfunction handleKeyboardEvent(replay, event) {\n  if (!replay.isEnabled()) {\n    return;\n  }\n\n  // Update user activity, but do not restart recording as it can create\n  // noisy/low-value replays (e.g. user comes back from idle, hits alt-tab, new\n  // session with a single \"keydown\" breadcrumb is created)\n  replay.updateUserActivity();\n  const breadcrumb = getKeyboardBreadcrumb(event);\n  if (!breadcrumb) {\n    return;\n  }\n  addBreadcrumbEvent(replay, breadcrumb);\n}\n\n/** exported only for tests */\nfunction getKeyboardBreadcrumb(event) {\n  const {\n    metaKey,\n    shiftKey,\n    ctrlKey,\n    altKey,\n    key,\n    target\n  } = event;\n\n  // never capture for input fields\n  if (!target || isInputElement(target) || !key) {\n    return null;\n  }\n\n  // Note: We do not consider shift here, as that means \"uppercase\"\n  const hasModifierKey = metaKey || ctrlKey || altKey;\n  const isCharacterKey = key.length === 1; // other keys like Escape, Tab, etc have a longer length\n\n  // Do not capture breadcrumb if only a word key is pressed\n  // This could leak e.g. user input\n  if (!hasModifierKey && isCharacterKey) {\n    return null;\n  }\n  const message = htmlTreeAsString(target, {\n    maxStringLength: 200\n  }) || '<unknown>';\n  const baseBreadcrumb = getBaseDomBreadcrumb(target, message);\n  return createBreadcrumb({\n    category: 'ui.keyDown',\n    message,\n    data: {\n      ...baseBreadcrumb.data,\n      metaKey,\n      shiftKey,\n      ctrlKey,\n      altKey,\n      key\n    }\n  });\n}\nfunction isInputElement(target) {\n  return target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;\n}\n\n// Map entryType -> function to normalize data for event\nconst ENTRY_TYPES = {\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  resource: createResourceEntry,\n  paint: createPaintEntry,\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  navigation: createNavigationEntry\n};\n\n/**\n * Handler creater for web vitals\n */\nfunction webVitalHandler(getter, replay) {\n  return ({\n    metric\n  }) => void replay.replayPerformanceEntries.push(getter(metric));\n}\n\n/**\n * Create replay performance entries from the browser performance entries.\n */\nfunction createPerformanceEntries(entries) {\n  return entries.map(createPerformanceEntry).filter(Boolean);\n}\nfunction createPerformanceEntry(entry) {\n  const entryType = ENTRY_TYPES[entry.entryType];\n  if (!entryType) {\n    return null;\n  }\n  return entryType(entry);\n}\nfunction getAbsoluteTime(time) {\n  // browserPerformanceTimeOrigin can be undefined if `performance` or\n  // `performance.now` doesn't exist, but this is already checked by this integration\n  return ((browserPerformanceTimeOrigin() || WINDOW.performance.timeOrigin) + time) / 1000;\n}\nfunction createPaintEntry(entry) {\n  const {\n    duration,\n    entryType,\n    name,\n    startTime\n  } = entry;\n  const start = getAbsoluteTime(startTime);\n  return {\n    type: entryType,\n    name,\n    start,\n    end: start + duration,\n    data: undefined\n  };\n}\nfunction createNavigationEntry(entry) {\n  const {\n    entryType,\n    name,\n    decodedBodySize,\n    duration,\n    domComplete,\n    encodedBodySize,\n    domContentLoadedEventStart,\n    domContentLoadedEventEnd,\n    domInteractive,\n    loadEventStart,\n    loadEventEnd,\n    redirectCount,\n    startTime,\n    transferSize,\n    type\n  } = entry;\n\n  // Ignore entries with no duration, they do not seem to be useful and cause dupes\n  if (duration === 0) {\n    return null;\n  }\n  return {\n    type: `${entryType}.${type}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(domComplete),\n    name,\n    data: {\n      size: transferSize,\n      decodedBodySize,\n      encodedBodySize,\n      duration,\n      domInteractive,\n      domContentLoadedEventStart,\n      domContentLoadedEventEnd,\n      loadEventStart,\n      loadEventEnd,\n      domComplete,\n      redirectCount\n    }\n  };\n}\nfunction createResourceEntry(entry) {\n  const {\n    entryType,\n    initiatorType,\n    name,\n    responseEnd,\n    startTime,\n    decodedBodySize,\n    encodedBodySize,\n    responseStatus,\n    transferSize\n  } = entry;\n\n  // Core SDK handles these\n  if (['fetch', 'xmlhttprequest'].includes(initiatorType)) {\n    return null;\n  }\n  return {\n    type: `${entryType}.${initiatorType}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(responseEnd),\n    name,\n    data: {\n      size: transferSize,\n      statusCode: responseStatus,\n      decodedBodySize,\n      encodedBodySize\n    }\n  };\n}\n\n/**\n * Add a LCP event to the replay based on a LCP metric.\n */\nfunction getLargestContentfulPaint(metric) {\n  const lastEntry = metric.entries[metric.entries.length - 1];\n  const node = lastEntry?.element ? [lastEntry.element] : undefined;\n  return getWebVital(metric, 'largest-contentful-paint', node);\n}\nfunction isLayoutShift(entry) {\n  return entry.sources !== undefined;\n}\n\n/**\n * Add a CLS event to the replay based on a CLS metric.\n */\nfunction getCumulativeLayoutShift(metric) {\n  const layoutShifts = [];\n  const nodes = [];\n  for (const entry of metric.entries) {\n    if (isLayoutShift(entry)) {\n      const nodeIds = [];\n      for (const source of entry.sources) {\n        if (source.node) {\n          nodes.push(source.node);\n          const nodeId = record.mirror.getId(source.node);\n          if (nodeId) {\n            nodeIds.push(nodeId);\n          }\n        }\n      }\n      layoutShifts.push({\n        value: entry.value,\n        nodeIds: nodeIds.length ? nodeIds : undefined\n      });\n    }\n  }\n  return getWebVital(metric, 'cumulative-layout-shift', nodes, layoutShifts);\n}\n\n/**\n * Add a FID event to the replay based on a FID metric.\n */\nfunction getFirstInputDelay(metric) {\n  const lastEntry = metric.entries[metric.entries.length - 1];\n  const node = lastEntry?.target ? [lastEntry.target] : undefined;\n  return getWebVital(metric, 'first-input-delay', node);\n}\n\n/**\n * Add an INP event to the replay based on an INP metric.\n */\nfunction getInteractionToNextPaint(metric) {\n  const lastEntry = metric.entries[metric.entries.length - 1];\n  const node = lastEntry?.target ? [lastEntry.target] : undefined;\n  return getWebVital(metric, 'interaction-to-next-paint', node);\n}\n\n/**\n * Add an web vital event to the replay based on the web vital metric.\n */\nfunction getWebVital(metric, name, nodes, attributions) {\n  const value = metric.value;\n  const rating = metric.rating;\n  const end = getAbsoluteTime(value);\n  return {\n    type: 'web-vital',\n    name,\n    start: end,\n    end,\n    data: {\n      value,\n      size: value,\n      rating,\n      nodeIds: nodes ? nodes.map(node => record.mirror.getId(node)) : undefined,\n      attributions\n    }\n  };\n}\n\n/**\n * Sets up a PerformanceObserver to listen to all performance entry types.\n * Returns a callback to stop observing.\n */\nfunction setupPerformanceObserver(replay) {\n  function addPerformanceEntry(entry) {\n    // It is possible for entries to come up multiple times\n    if (!replay.performanceEntries.includes(entry)) {\n      replay.performanceEntries.push(entry);\n    }\n  }\n  function onEntries({\n    entries\n  }) {\n    entries.forEach(addPerformanceEntry);\n  }\n  const clearCallbacks = [];\n  ['navigation', 'paint', 'resource'].forEach(type => {\n    clearCallbacks.push(addPerformanceInstrumentationHandler(type, onEntries));\n  });\n  clearCallbacks.push(addLcpInstrumentationHandler(webVitalHandler(getLargestContentfulPaint, replay)), addClsInstrumentationHandler(webVitalHandler(getCumulativeLayoutShift, replay)), addFidInstrumentationHandler(webVitalHandler(getFirstInputDelay, replay)), addInpInstrumentationHandler(webVitalHandler(getInteractionToNextPaint, replay)));\n\n  // A callback to cleanup all handlers\n  return () => {\n    clearCallbacks.forEach(clearCallback => clearCallback());\n  };\n}\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__;\nconst r = `var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),s=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),a=function(t,e){for(var i=new n(31),s=0;s<31;++s)i[s]=e+=1<<t[s-1];var a=new r(i[30]);for(s=1;s<30;++s)for(var o=i[s];o<i[s+1];++o)a[o]=o-i[s]<<5|s;return{b:i,r:a}},o=a(e,2),h=o.b,f=o.r;h[28]=258,f[258]=28;for(var l=a(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,s=0,a=new n(r);s<i;++s)t[s]&&++a[t[s]-1];var o,h=new n(r);for(s=1;s<r;++s)h[s]=h[s-1]+a[s-1]<<1;if(e){o=new n(1<<r);var f=15-r;for(s=0;s<i;++s)if(t[s])for(var l=s<<4|t[s],c=r-t[s],v=h[t[s]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>f]=l}else for(o=new n(i),s=0;s<i;++s)t[s]&&(o[s]=u[h[t[s]-1]++]>>15-t[s]);return o},p=new t(288);for(c=0;c<144;++c)p[c]=8;for(c=144;c<256;++c)p[c]=9;for(c=256;c<280;++c)p[c]=7;for(c=280;c<288;++c)p[c]=8;var g=new t(32);for(c=0;c<32;++c)g[c]=5;var w=d(p,9,0),y=d(g,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},_=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},x=function(r,e){for(var i=[],s=0;s<r.length;++s)r[s]&&i.push({s:s,f:r[s]});var a=i.length,o=i.slice();if(!a)return{t:F,l:0};if(1==a){var h=new t(i[0].s+1);return h[i[0].s]=1,{t:h,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var f=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:f.f+l.f,l:f,r:l};c!=a-1;)f=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:f.f+l.f,l:f,r:l};var d=o[0].s;for(s=1;s<a;++s)o[s].s>d&&(d=o[s].s);var p=new n(d+1),g=A(i[c-1],p,0);if(g>e){s=0;var w=0,y=g-e,m=1<<y;for(o.sort((function(t,n){return p[n.s]-p[t.s]||t.f-n.f}));s<a;++s){var b=o[s].s;if(!(p[b]>e))break;w+=m-(1<<g-p[b]),p[b]=e}for(w>>=y;w>0;){var M=o[s].s;p[M]<e?w-=1<<e-p[M]++-1:++s}for(;s>=0&&w;--s){var E=o[s].s;p[E]==e&&(--p[E],++w)}g=e}return{t:new t(p),l:g}},A=function(t,n,r){return-1==t.s?Math.max(A(t.l,n,r+1),A(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,s=t[0],a=1,o=function(t){e[i++]=t},h=1;h<=r;++h)if(t[h]==s&&h!=r)++a;else{if(!s&&a>2){for(;a>138;a-=138)o(32754);a>2&&(o(a>10?a-11<<5|28690:a-3<<5|12305),a=0)}else if(a>3){for(o(s),--a;a>6;a-=6)o(8304);a>2&&(o(a-3<<5|8208),a=0)}for(;a--;)o(s);a=1,s=t[h]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var s=0;s<e;++s)t[i+s+4]=r[s];return 8*(i+4+e)},U=function(t,r,a,o,h,f,l,u,c,v,m){z(r,m++,a),++h[256];for(var b=x(h,15),M=b.t,E=b.l,A=x(f,15),U=A.t,C=A.l,F=D(M),I=F.c,S=F.n,L=D(U),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=x(q,7),H=G.t,J=G.l,K=19;K>4&&!H[s[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(h,p)+T(f,g)+l,X=T(h,M)+T(f,U)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(U,C,0),R=U;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[s[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=w,P=p,Q=y,R=g;for(B=0;B<u;++B){var rt=o[B];if(rt>255){_(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;_(r,m,Q[et]),m+=R[et],et>3&&(_(r,m,rt>>5&8191),m+=i[et])}else _(r,m,N[rt]),m+=P[rt]}return _(r,m,N[256]),m+P[256]},C=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}},L=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,s=0|r.length,a=0;a!=s;){for(var o=Math.min(a+2655,s);a<o;++a)i+=e+=r[a];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},O=function(s,a,o,h,u){if(!u&&(u={l:1},a.dictionary)){var c=a.dictionary.subarray(-32768),v=new t(c.length+s.length);v.set(c),v.set(s,c.length),s=v,u.w=c.length}return function(s,a,o,h,u,c){var v=c.z||s.length,d=new t(h+v+5*(1+Math.ceil(v/7e3))+u),p=d.subarray(h,d.length-u),g=c.l,w=7&(c.r||0);if(a){w&&(p[0]=c.r>>3);for(var y=C[a-1],M=y>>13,E=8191&y,z=(1<<o)-1,_=c.p||new n(32768),x=c.h||new n(z+1),A=Math.ceil(o/3),D=2*A,T=function(t){return(s[t]^s[t+1]<<A^s[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=x[H];if(_[J]=K,x[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!g)){w=U(s,p,0,F,I,S,O,q,G,j-G,w),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(s[j+Q]==s[j+Q-W]){for(var $=0;$<Z&&s[j+$]==s[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-_[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=_[J])&32767}if(R){F[q++]=268435456|f[Q]<<18|l[R];var it=31&f[Q],st=31&l[R];O+=e[it]+i[st],++I[257+it],++S[st],B=j+Q,++L}else F[q++]=s[j],++I[s[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=s[j],++I[s[j]];w=U(s,p,g,F,I,S,O,q,G,j-G,w),g||(c.r=7&w|p[w/8|0]<<3,w-=7,c.h=x,c.p=_,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+g;j+=65535){var at=j+65535;at>=v&&(p[w/8|0]=g,at=v),w=k(p,w+1,s.subarray(j,at))}c.i=v}return b(d,0,h+m(w)+u)}(s,null==a.level?6:a.level,null==a.mem?u.l?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(s.length)))):20:12+a.mem,o,h,u)},j=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},q=function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&j(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}},B=function(t){return 10+(t.filename?t.filename.length+1:0)},G=function(){function n(n,r){if(\"function\"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(O(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var s=this.b.length-this.s.z;this.b.set(n.subarray(0,s),this.s.z),this.s.z=this.b.length,this.p(this.b,!1),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(s),32768),this.s.z=n.length-s+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n.prototype.flush=function(){this.ondata||E(5),this.s.l&&E(4),this.p(this.b,!1),this.s.w=this.s.i,this.s.i-=2},n}();var H=function(){function t(t,n){this.c=L(),this.v=1,G.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),G.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=O(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=L();i.p(n.dictionary),j(t,2,i.d())}}(r,this.o),this.v=0),n&&j(r,r.length-4,this.c.d()),this.ondata(r,n)},t.prototype.flush=function(){G.prototype.flush.call(this)},t}(),J=\"undefined\"!=typeof TextEncoder&&new TextEncoder,K=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{K.decode(F,{stream:!0})}catch(t){}var N=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(P(t),this.d=n||!1)},t}();function P(n,r){if(J)return J.encode(n);for(var e=n.length,i=new t(n.length+(n.length>>1)),s=0,a=function(t){i[s++]=t},o=0;o<e;++o){if(s+5>i.length){var h=new t(s+8+(e-o<<1));h.set(i),i=h}var f=n.charCodeAt(o);f<128||r?a(f):f<2048?(a(192|f>>6),a(128|63&f)):f>55295&&f<57344?(a(240|(f=65536+(1047552&f)|1023&n.charCodeAt(++o))>>18),a(128|f>>12&63),a(128|f>>6&63),a(128|63&f)):(a(224|f>>12),a(128|f>>6&63),a(128|63&f))}return b(i,0,s)}function Q(t){return function(t,n){n||(n={});var r=S(),e=t.length;r.p(t);var i=O(t,n,B(n),8),s=i.length;return q(i,n),j(i,s-8,r.d()),j(i,s-4,e),i}(P(t))}const R=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error(\"Adding invalid event\");const n=this._hasEvents?\",\":\"\";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push(\"]\",!0);const t=function(t){let n=0;for(const r of t)n+=r.length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new H,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new N(((t,n)=>{this.deflate.push(t,n)})),this.stream.push(\"[\")}},V={clear:()=>{R.clear()},addEvent:t=>R.addEvent(t),finish:()=>R.finish(),compress:t=>Q(t)};addEventListener(\"message\",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in V&&\"function\"==typeof V[n])try{const t=V[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:\"init\",success:!0,response:void 0});`;\nfunction e() {\n  const e = new Blob([r]);\n  return URL.createObjectURL(e);\n}\nconst CONSOLE_LEVELS = ['info', 'warn', 'error', 'log'];\nconst PREFIX = '[Replay] ';\nfunction _addBreadcrumb(message, level = 'info') {\n  addBreadcrumb({\n    category: 'console',\n    data: {\n      logger: 'replay'\n    },\n    level,\n    message: `${PREFIX}${message}`\n  }, {\n    level\n  });\n}\nfunction makeReplayLogger() {\n  let _capture = false;\n  let _trace = false;\n  const _logger = {\n    exception: () => undefined,\n    infoTick: () => undefined,\n    setConfig: opts => {\n      _capture = !!opts.captureExceptions;\n      _trace = !!opts.traceInternals;\n    }\n  };\n  if (DEBUG_BUILD) {\n    CONSOLE_LEVELS.forEach(name => {\n      _logger[name] = (...args) => {\n        logger$1[name](PREFIX, ...args);\n        if (_trace) {\n          _addBreadcrumb(args.join(''), severityLevelFromString(name));\n        }\n      };\n    });\n    _logger.exception = (error, ...message) => {\n      if (message.length && _logger.error) {\n        _logger.error(...message);\n      }\n      logger$1.error(PREFIX, error);\n      if (_capture) {\n        captureException(error);\n      } else if (_trace) {\n        // No need for a breadcrumb if `_capture` is enabled since it should be\n        // captured as an exception\n        _addBreadcrumb(error, 'error');\n      }\n    };\n    _logger.infoTick = (...args) => {\n      logger$1.info(PREFIX, ...args);\n      if (_trace) {\n        // Wait a tick here to avoid race conditions for some initial logs\n        // which may be added before replay is initialized\n        setTimeout(() => _addBreadcrumb(args[0]), 0);\n      }\n    };\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      _logger[name] = () => undefined;\n    });\n  }\n  return _logger;\n}\nconst logger = makeReplayLogger();\n\n/** This error indicates that the event buffer size exceeded the limit.. */\nclass EventBufferSizeExceededError extends Error {\n  constructor() {\n    super(`Event buffer exceeded maximum size of ${REPLAY_MAX_EVENT_BUFFER_SIZE}.`);\n  }\n}\n\n/**\n * A basic event buffer that does not do any compression.\n * Used as fallback if the compression worker cannot be loaded or is disabled.\n */\nclass EventBufferArray {\n  /** All the events that are buffered to be sent. */\n\n  /** @inheritdoc */\n\n  /** @inheritdoc */\n\n  constructor() {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n    this.waitForCheckout = false;\n  }\n\n  /** @inheritdoc */\n  get hasEvents() {\n    return this.events.length > 0;\n  }\n\n  /** @inheritdoc */\n  get type() {\n    return 'sync';\n  }\n\n  /** @inheritdoc */\n  destroy() {\n    this.events = [];\n  }\n\n  /** @inheritdoc */\n  async addEvent(event) {\n    const eventSize = JSON.stringify(event).length;\n    this._totalSize += eventSize;\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      throw new EventBufferSizeExceededError();\n    }\n    this.events.push(event);\n  }\n\n  /** @inheritdoc */\n  finish() {\n    return new Promise(resolve => {\n      // Make a copy of the events array reference and immediately clear the\n      // events member so that we do not lose new events while uploading\n      // attachment.\n      const eventsRet = this.events;\n      this.clear();\n      resolve(JSON.stringify(eventsRet));\n    });\n  }\n\n  /** @inheritdoc */\n  clear() {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n  }\n\n  /** @inheritdoc */\n  getEarliestTimestamp() {\n    const timestamp = this.events.map(event => event.timestamp).sort()[0];\n    if (!timestamp) {\n      return null;\n    }\n    return timestampToMs(timestamp);\n  }\n}\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nclass WorkerHandler {\n  constructor(worker) {\n    this._worker = worker;\n    this._id = 0;\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occurred.\n   */\n  ensureReady() {\n    // Ensure we only check once\n    if (this._ensureReadyPromise) {\n      return this._ensureReadyPromise;\n    }\n    this._ensureReadyPromise = new Promise((resolve, reject) => {\n      this._worker.addEventListener('message', ({\n        data\n      }) => {\n        if (data.success) {\n          resolve();\n        } else {\n          reject();\n        }\n      }, {\n        once: true\n      });\n      this._worker.addEventListener('error', error => {\n        reject(error);\n      }, {\n        once: true\n      });\n    });\n    return this._ensureReadyPromise;\n  }\n\n  /**\n   * Destroy the worker.\n   */\n  destroy() {\n    DEBUG_BUILD && logger.info('Destroying compression worker');\n    this._worker.terminate();\n  }\n\n  /**\n   * Post message to worker and wait for response before resolving promise.\n   */\n  postMessage(method, arg) {\n    const id = this._getAndIncrementId();\n    return new Promise((resolve, reject) => {\n      const listener = ({\n        data\n      }) => {\n        const response = data;\n        if (response.method !== method) {\n          return;\n        }\n\n        // There can be multiple listeners for a single method, the id ensures\n        // that the response matches the caller.\n        if (response.id !== id) {\n          return;\n        }\n\n        // At this point, we'll always want to remove listener regardless of result status\n        this._worker.removeEventListener('message', listener);\n        if (!response.success) {\n          // TODO: Do some error handling, not sure what\n          DEBUG_BUILD && logger.error('Error in compression worker: ', response.response);\n          reject(new Error('Error in compression worker'));\n          return;\n        }\n        resolve(response.response);\n      };\n\n      // Note: we can't use `once` option because it's possible it needs to\n      // listen to multiple messages\n      this._worker.addEventListener('message', listener);\n      this._worker.postMessage({\n        id,\n        method,\n        arg\n      });\n    });\n  }\n\n  /** Get the current ID and increment it for the next call. */\n  _getAndIncrementId() {\n    return this._id++;\n  }\n}\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nclass EventBufferCompressionWorker {\n  /** @inheritdoc */\n\n  /** @inheritdoc */\n\n  constructor(worker) {\n    this._worker = new WorkerHandler(worker);\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n    this.waitForCheckout = false;\n  }\n\n  /** @inheritdoc */\n  get hasEvents() {\n    return !!this._earliestTimestamp;\n  }\n\n  /** @inheritdoc */\n  get type() {\n    return 'worker';\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occurred.\n   */\n  ensureReady() {\n    return this._worker.ensureReady();\n  }\n\n  /**\n   * Destroy the event buffer.\n   */\n  destroy() {\n    this._worker.destroy();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfully received and processed by worker.\n   */\n  addEvent(event) {\n    const timestamp = timestampToMs(event.timestamp);\n    if (!this._earliestTimestamp || timestamp < this._earliestTimestamp) {\n      this._earliestTimestamp = timestamp;\n    }\n    const data = JSON.stringify(event);\n    this._totalSize += data.length;\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      return Promise.reject(new EventBufferSizeExceededError());\n    }\n    return this._sendEventToWorker(data);\n  }\n\n  /**\n   * Finish the event buffer and return the compressed data.\n   */\n  finish() {\n    return this._finishRequest();\n  }\n\n  /** @inheritdoc */\n  clear() {\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n\n    // We do not wait on this, as we assume the order of messages is consistent for the worker\n    this._worker.postMessage('clear').then(null, e => {\n      DEBUG_BUILD && logger.exception(e, 'Sending \"clear\" message to worker failed', e);\n    });\n  }\n\n  /** @inheritdoc */\n  getEarliestTimestamp() {\n    return this._earliestTimestamp;\n  }\n\n  /**\n   * Send the event to the worker.\n   */\n  _sendEventToWorker(data) {\n    return this._worker.postMessage('addEvent', data);\n  }\n\n  /**\n   * Finish the request and return the compressed data from the worker.\n   */\n  async _finishRequest() {\n    const response = await this._worker.postMessage('finish');\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    return response;\n  }\n}\n\n/**\n * This proxy will try to use the compression worker, and fall back to use the simple buffer if an error occurs there.\n * This can happen e.g. if the worker cannot be loaded.\n * Exported only for testing.\n */\nclass EventBufferProxy {\n  constructor(worker) {\n    this._fallback = new EventBufferArray();\n    this._compression = new EventBufferCompressionWorker(worker);\n    this._used = this._fallback;\n    this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded();\n  }\n\n  /** @inheritdoc */\n  get waitForCheckout() {\n    return this._used.waitForCheckout;\n  }\n\n  /** @inheritdoc */\n  get type() {\n    return this._used.type;\n  }\n\n  /** @inheritDoc */\n  get hasEvents() {\n    return this._used.hasEvents;\n  }\n\n  /** @inheritdoc */\n  get hasCheckout() {\n    return this._used.hasCheckout;\n  }\n  /** @inheritdoc */\n  set hasCheckout(value) {\n    this._used.hasCheckout = value;\n  }\n\n  /** @inheritdoc */\n  // eslint-disable-next-line @typescript-eslint/adjacent-overload-signatures\n  set waitForCheckout(value) {\n    this._used.waitForCheckout = value;\n  }\n\n  /** @inheritDoc */\n  destroy() {\n    this._fallback.destroy();\n    this._compression.destroy();\n  }\n\n  /** @inheritdoc */\n  clear() {\n    return this._used.clear();\n  }\n\n  /** @inheritdoc */\n  getEarliestTimestamp() {\n    return this._used.getEarliestTimestamp();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfully added.\n   */\n  addEvent(event) {\n    return this._used.addEvent(event);\n  }\n\n  /** @inheritDoc */\n  async finish() {\n    // Ensure the worker is loaded, so the sent event is compressed\n    await this.ensureWorkerIsLoaded();\n    return this._used.finish();\n  }\n\n  /** Ensure the worker has loaded. */\n  ensureWorkerIsLoaded() {\n    return this._ensureWorkerIsLoadedPromise;\n  }\n\n  /** Actually check if the worker has been loaded. */\n  async _ensureWorkerIsLoaded() {\n    try {\n      await this._compression.ensureReady();\n    } catch (error) {\n      // If the worker fails to load, we fall back to the simple buffer.\n      // Nothing more to do from our side here\n      DEBUG_BUILD && logger.exception(error, 'Failed to load the compression worker, falling back to simple buffer');\n      return;\n    }\n\n    // Now we need to switch over the array buffer to the compression worker\n    await this._switchToCompressionWorker();\n  }\n\n  /** Switch the used buffer to the compression worker. */\n  async _switchToCompressionWorker() {\n    const {\n      events,\n      hasCheckout,\n      waitForCheckout\n    } = this._fallback;\n    const addEventPromises = [];\n    for (const event of events) {\n      addEventPromises.push(this._compression.addEvent(event));\n    }\n    this._compression.hasCheckout = hasCheckout;\n    this._compression.waitForCheckout = waitForCheckout;\n\n    // We switch over to the new buffer immediately - any further events will be added\n    // after the previously buffered ones\n    this._used = this._compression;\n\n    // Wait for original events to be re-added before resolving\n    try {\n      await Promise.all(addEventPromises);\n\n      // Can now clear fallback buffer as it's no longer necessary\n      this._fallback.clear();\n    } catch (error) {\n      DEBUG_BUILD && logger.exception(error, 'Failed to add events when switching buffers.');\n    }\n  }\n}\n\n/**\n * Create an event buffer for replays.\n */\nfunction createEventBuffer({\n  useCompression,\n  workerUrl: customWorkerUrl\n}) {\n  if (useCompression &&\n  // eslint-disable-next-line no-restricted-globals\n  window.Worker) {\n    const worker = _loadWorker(customWorkerUrl);\n    if (worker) {\n      return worker;\n    }\n  }\n  DEBUG_BUILD && logger.info('Using simple buffer');\n  return new EventBufferArray();\n}\nfunction _loadWorker(customWorkerUrl) {\n  try {\n    const workerUrl = customWorkerUrl || _getWorkerUrl();\n    if (!workerUrl) {\n      return;\n    }\n    DEBUG_BUILD && logger.info(`Using compression worker${customWorkerUrl ? ` from ${customWorkerUrl}` : ''}`);\n    const worker = new Worker(workerUrl);\n    return new EventBufferProxy(worker);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to create compression worker');\n    // Fall back to use simple event buffer array\n  }\n}\nfunction _getWorkerUrl() {\n  if (typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ === 'undefined' || !__SENTRY_EXCLUDE_REPLAY_WORKER__) {\n    return e();\n  }\n  return '';\n}\n\n/** If sessionStorage is available. */\nfunction hasSessionStorage() {\n  try {\n    // This can throw, e.g. when being accessed in a sandboxed iframe\n    return 'sessionStorage' in WINDOW && !!WINDOW.sessionStorage;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Removes the session from Session Storage and unsets session in replay instance\n */\nfunction clearSession(replay) {\n  deleteSession();\n  replay.session = undefined;\n}\n\n/**\n * Deletes a session from storage\n */\nfunction deleteSession() {\n  if (!hasSessionStorage()) {\n    return;\n  }\n  try {\n    WINDOW.sessionStorage.removeItem(REPLAY_SESSION_KEY);\n  } catch {\n    // Ignore potential SecurityError exceptions\n  }\n}\n\n/**\n * Given a sample rate, returns true if replay should be sampled.\n *\n * 1.0 = 100% sampling\n * 0.0 = 0% sampling\n */\nfunction isSampled(sampleRate) {\n  if (sampleRate === undefined) {\n    return false;\n  }\n\n  // Math.random() returns a number in range of 0 to 1 (inclusive of 0, but not 1)\n  return Math.random() < sampleRate;\n}\n\n/**\n * Get a session with defaults & applied sampling.\n */\nfunction makeSession(session) {\n  const now = Date.now();\n  const id = session.id || uuid4();\n  // Note that this means we cannot set a started/lastActivity of `0`, but this should not be relevant outside of tests.\n  const started = session.started || now;\n  const lastActivity = session.lastActivity || now;\n  const segmentId = session.segmentId || 0;\n  const sampled = session.sampled;\n  const previousSessionId = session.previousSessionId;\n  return {\n    id,\n    started,\n    lastActivity,\n    segmentId,\n    sampled,\n    previousSessionId\n  };\n}\n\n/**\n * Save a session to session storage.\n */\nfunction saveSession(session) {\n  if (!hasSessionStorage()) {\n    return;\n  }\n  try {\n    WINDOW.sessionStorage.setItem(REPLAY_SESSION_KEY, JSON.stringify(session));\n  } catch {\n    // Ignore potential SecurityError exceptions\n  }\n}\n\n/**\n * Get the sampled status for a session based on sample rates & current sampled status.\n */\nfunction getSessionSampleType(sessionSampleRate, allowBuffering) {\n  return isSampled(sessionSampleRate) ? 'session' : allowBuffering ? 'buffer' : false;\n}\n\n/**\n * Create a new session, which in its current implementation is a Sentry event\n * that all replays will be saved to as attachments. Currently, we only expect\n * one of these Sentry events per \"replay session\".\n */\nfunction createSession({\n  sessionSampleRate,\n  allowBuffering,\n  stickySession = false\n}, {\n  previousSessionId\n} = {}) {\n  const sampled = getSessionSampleType(sessionSampleRate, allowBuffering);\n  const session = makeSession({\n    sampled,\n    previousSessionId\n  });\n  if (stickySession) {\n    saveSession(session);\n  }\n  return session;\n}\n\n/**\n * Fetches a session from storage\n */\nfunction fetchSession() {\n  if (!hasSessionStorage()) {\n    return null;\n  }\n  try {\n    // This can throw if cookies are disabled\n    const sessionStringFromStorage = WINDOW.sessionStorage.getItem(REPLAY_SESSION_KEY);\n    if (!sessionStringFromStorage) {\n      return null;\n    }\n    const sessionObj = JSON.parse(sessionStringFromStorage);\n    DEBUG_BUILD && logger.infoTick('Loading existing session');\n    return makeSession(sessionObj);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Given an initial timestamp and an expiry duration, checks to see if current\n * time should be considered as expired.\n */\nfunction isExpired(initialTime, expiry, targetTime = +new Date()) {\n  // Always expired if < 0\n  if (initialTime === null || expiry === undefined || expiry < 0) {\n    return true;\n  }\n\n  // Never expires if == 0\n  if (expiry === 0) {\n    return false;\n  }\n  return initialTime + expiry <= targetTime;\n}\n\n/**\n * Checks to see if session is expired\n */\nfunction isSessionExpired(session, {\n  maxReplayDuration,\n  sessionIdleExpire,\n  targetTime = Date.now()\n}) {\n  return (\n    // First, check that maximum session length has not been exceeded\n    isExpired(session.started, maxReplayDuration, targetTime) ||\n    // check that the idle timeout has not been exceeded (i.e. user has\n    // performed an action within the last `sessionIdleExpire` ms)\n    isExpired(session.lastActivity, sessionIdleExpire, targetTime)\n  );\n}\n\n/** If the session should be refreshed or not. */\nfunction shouldRefreshSession(session, {\n  sessionIdleExpire,\n  maxReplayDuration\n}) {\n  // If not expired, all good, just keep the session\n  if (!isSessionExpired(session, {\n    sessionIdleExpire,\n    maxReplayDuration\n  })) {\n    return false;\n  }\n\n  // If we are buffering & haven't ever flushed yet, always continue\n  if (session.sampled === 'buffer' && session.segmentId === 0) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Get or create a session, when initializing the replay.\n * Returns a session that may be unsampled.\n */\nfunction loadOrCreateSession({\n  sessionIdleExpire,\n  maxReplayDuration,\n  previousSessionId\n}, sessionOptions) {\n  const existingSession = sessionOptions.stickySession && fetchSession();\n\n  // No session exists yet, just create a new one\n  if (!existingSession) {\n    DEBUG_BUILD && logger.infoTick('Creating new session');\n    return createSession(sessionOptions, {\n      previousSessionId\n    });\n  }\n  if (!shouldRefreshSession(existingSession, {\n    sessionIdleExpire,\n    maxReplayDuration\n  })) {\n    return existingSession;\n  }\n  DEBUG_BUILD && logger.infoTick('Session in sessionStorage is expired, creating new one...');\n  return createSession(sessionOptions, {\n    previousSessionId: existingSession.id\n  });\n}\nfunction isCustomEvent(event) {\n  return event.type === EventType.Custom;\n}\n\n/**\n * Add an event to the event buffer.\n * In contrast to `addEvent`, this does not return a promise & does not wait for the adding of the event to succeed/fail.\n * Instead this returns `true` if we tried to add the event, else false.\n * It returns `false` e.g. if we are paused, disabled, or out of the max replay duration.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nfunction addEventSync(replay, event, isCheckout) {\n  if (!shouldAddEvent(replay, event)) {\n    return false;\n  }\n\n  // This should never reject\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  _addEvent(replay, event, isCheckout);\n  return true;\n}\n\n/**\n * Add an event to the event buffer.\n * Resolves to `null` if no event was added, else to `void`.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nfunction addEvent(replay, event, isCheckout) {\n  if (!shouldAddEvent(replay, event)) {\n    return Promise.resolve(null);\n  }\n  return _addEvent(replay, event, isCheckout);\n}\nasync function _addEvent(replay, event, isCheckout) {\n  const {\n    eventBuffer\n  } = replay;\n  if (!eventBuffer || eventBuffer.waitForCheckout && !isCheckout) {\n    return null;\n  }\n  const isBufferMode = replay.recordingMode === 'buffer';\n  try {\n    if (isCheckout && isBufferMode) {\n      eventBuffer.clear();\n    }\n    if (isCheckout) {\n      eventBuffer.hasCheckout = true;\n      eventBuffer.waitForCheckout = false;\n    }\n    const replayOptions = replay.getOptions();\n    const eventAfterPossibleCallback = maybeApplyCallback(event, replayOptions.beforeAddRecordingEvent);\n    if (!eventAfterPossibleCallback) {\n      return;\n    }\n    return await eventBuffer.addEvent(eventAfterPossibleCallback);\n  } catch (error) {\n    const isExceeded = error && error instanceof EventBufferSizeExceededError;\n    const reason = isExceeded ? 'addEventSizeExceeded' : 'addEvent';\n    if (isExceeded && isBufferMode) {\n      // Clear buffer and wait for next checkout\n      eventBuffer.clear();\n      eventBuffer.waitForCheckout = true;\n      return null;\n    }\n    replay.handleException(error);\n    await replay.stop({\n      reason\n    });\n    const client = getClient();\n    if (client) {\n      client.recordDroppedEvent('internal_sdk_error', 'replay');\n    }\n  }\n}\n\n/** Exported only for tests. */\nfunction shouldAddEvent(replay, event) {\n  if (!replay.eventBuffer || replay.isPaused() || !replay.isEnabled()) {\n    return false;\n  }\n  const timestampInMs = timestampToMs(event.timestamp);\n\n  // Throw out events that happen more than 5 minutes ago. This can happen if\n  // page has been left open and idle for a long period of time and user\n  // comes back to trigger a new session. The performance entries rely on\n  // `performance.timeOrigin`, which is when the page first opened.\n  if (timestampInMs + replay.timeouts.sessionIdlePause < Date.now()) {\n    return false;\n  }\n\n  // Throw out events that are +60min from the initial timestamp\n  if (timestampInMs > replay.getContext().initialTimestamp + replay.getOptions().maxReplayDuration) {\n    DEBUG_BUILD && logger.infoTick(`Skipping event with timestamp ${timestampInMs} because it is after maxReplayDuration`);\n    return false;\n  }\n  return true;\n}\nfunction maybeApplyCallback(event, callback) {\n  try {\n    if (typeof callback === 'function' && isCustomEvent(event)) {\n      return callback(event);\n    }\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'An error occurred in the `beforeAddRecordingEvent` callback, skipping the event...');\n    return null;\n  }\n  return event;\n}\n\n/** If the event is an error event */\nfunction isErrorEvent(event) {\n  return !event.type;\n}\n\n/** If the event is a transaction event */\nfunction isTransactionEvent(event) {\n  return event.type === 'transaction';\n}\n\n/** If the event is an replay event */\nfunction isReplayEvent(event) {\n  return event.type === 'replay_event';\n}\n\n/** If the event is a feedback event */\nfunction isFeedbackEvent(event) {\n  return event.type === 'feedback';\n}\n\n/**\n * Returns a listener to be added to `client.on('afterSendErrorEvent, listener)`.\n */\nfunction handleAfterSendEvent(replay) {\n  return (event, sendResponse) => {\n    if (!replay.isEnabled() || !isErrorEvent(event) && !isTransactionEvent(event)) {\n      return;\n    }\n    const statusCode = sendResponse?.statusCode;\n\n    // We only want to do stuff on successful error sending, otherwise you get error replays without errors attached\n    // If not using the base transport, we allow `undefined` response (as a custom transport may not implement this correctly yet)\n    // If we do use the base transport, we skip if we encountered an non-OK status code\n    if (!statusCode || statusCode < 200 || statusCode >= 300) {\n      return;\n    }\n    if (isTransactionEvent(event)) {\n      handleTransactionEvent(replay, event);\n      return;\n    }\n    handleErrorEvent(replay, event);\n  };\n}\nfunction handleTransactionEvent(replay, event) {\n  const replayContext = replay.getContext();\n\n  // Collect traceIds in _context regardless of `recordingMode`\n  // In error mode, _context gets cleared on every checkout\n  // We limit to max. 100 transactions linked\n  if (event.contexts?.trace?.trace_id && replayContext.traceIds.size < 100) {\n    replayContext.traceIds.add(event.contexts.trace.trace_id);\n  }\n}\nfunction handleErrorEvent(replay, event) {\n  const replayContext = replay.getContext();\n\n  // Add error to list of errorIds of replay. This is ok to do even if not\n  // sampled because context will get reset at next checkout.\n  // XXX: There is also a race condition where it's possible to capture an\n  // error to Sentry before Replay SDK has loaded, but response returns after\n  // it was loaded, and this gets called.\n  // We limit to max. 100 errors linked\n  if (event.event_id && replayContext.errorIds.size < 100) {\n    replayContext.errorIds.add(event.event_id);\n  }\n\n  // If error event is tagged with replay id it means it was sampled (when in buffer mode)\n  // Need to be very careful that this does not cause an infinite loop\n  if (replay.recordingMode !== 'buffer' || !event.tags || !event.tags.replayId) {\n    return;\n  }\n  const {\n    beforeErrorSampling\n  } = replay.getOptions();\n  if (typeof beforeErrorSampling === 'function' && !beforeErrorSampling(event)) {\n    return;\n  }\n  setTimeout$3(async () => {\n    try {\n      // Capture current event buffer as new replay\n      await replay.sendBufferedReplayOrFlush();\n    } catch (err) {\n      replay.handleException(err);\n    }\n  });\n}\n\n/**\n * Returns a listener to be added to `client.on('afterSendErrorEvent, listener)`.\n */\nfunction handleBeforeSendEvent(replay) {\n  return event => {\n    if (!replay.isEnabled() || !isErrorEvent(event)) {\n      return;\n    }\n    handleHydrationError(replay, event);\n  };\n}\nfunction handleHydrationError(replay, event) {\n  const exceptionValue = event.exception?.values?.[0]?.value;\n  if (typeof exceptionValue !== 'string') {\n    return;\n  }\n  if (\n  // Only matches errors in production builds of react-dom\n  // Example https://reactjs.org/docs/error-decoder.html?invariant=423\n  // With newer React versions, the messages changed to a different website https://react.dev/errors/418\n  exceptionValue.match(/(reactjs\\.org\\/docs\\/error-decoder\\.html\\?invariant=|react\\.dev\\/errors\\/)(418|419|422|423|425)/) ||\n  // Development builds of react-dom\n  // Error 1: Hydration failed because the initial UI does not match what was rendered on the server.\n  // Error 2: Text content does not match server-rendered HTML. Warning: Text content did not match.\n  exceptionValue.match(/(does not match server-rendered HTML|Hydration failed because)/i)) {\n    const breadcrumb = createBreadcrumb({\n      category: 'replay.hydrate-error',\n      data: {\n        url: getLocationHref()\n      }\n    });\n    addBreadcrumbEvent(replay, breadcrumb);\n  }\n}\n\n/**\n * Handle breadcrumbs that Sentry captures, and make sure to capture relevant breadcrumbs to Replay as well.\n */\nfunction handleBreadcrumbs(replay) {\n  const client = getClient();\n  if (!client) {\n    return;\n  }\n  client.on('beforeAddBreadcrumb', breadcrumb => beforeAddBreadcrumb(replay, breadcrumb));\n}\nfunction beforeAddBreadcrumb(replay, breadcrumb) {\n  if (!replay.isEnabled() || !isBreadcrumbWithCategory(breadcrumb)) {\n    return;\n  }\n  const result = normalizeBreadcrumb(breadcrumb);\n  if (result) {\n    addBreadcrumbEvent(replay, result);\n  }\n}\n\n/** Exported only for tests. */\nfunction normalizeBreadcrumb(breadcrumb) {\n  if (!isBreadcrumbWithCategory(breadcrumb) || [\n  // fetch & xhr are handled separately,in handleNetworkBreadcrumbs\n  'fetch', 'xhr',\n  // These two are breadcrumbs for emitted sentry events, we don't care about them\n  'sentry.event', 'sentry.transaction'].includes(breadcrumb.category) ||\n  // We capture UI breadcrumbs separately\n  breadcrumb.category.startsWith('ui.')) {\n    return null;\n  }\n  if (breadcrumb.category === 'console') {\n    return normalizeConsoleBreadcrumb(breadcrumb);\n  }\n  return createBreadcrumb(breadcrumb);\n}\n\n/** exported for tests only */\nfunction normalizeConsoleBreadcrumb(breadcrumb) {\n  const args = breadcrumb.data?.arguments;\n  if (!Array.isArray(args) || args.length === 0) {\n    return createBreadcrumb(breadcrumb);\n  }\n  let isTruncated = false;\n\n  // Avoid giant args captures\n  const normalizedArgs = args.map(arg => {\n    if (!arg) {\n      return arg;\n    }\n    if (typeof arg === 'string') {\n      if (arg.length > CONSOLE_ARG_MAX_SIZE) {\n        isTruncated = true;\n        return `${arg.slice(0, CONSOLE_ARG_MAX_SIZE)}…`;\n      }\n      return arg;\n    }\n    if (typeof arg === 'object') {\n      try {\n        const normalizedArg = normalize(arg, 7);\n        const stringified = JSON.stringify(normalizedArg);\n        if (stringified.length > CONSOLE_ARG_MAX_SIZE) {\n          isTruncated = true;\n          // We use the pretty printed JSON string here as a base\n          return `${JSON.stringify(normalizedArg, null, 2).slice(0, CONSOLE_ARG_MAX_SIZE)}…`;\n        }\n        return normalizedArg;\n      } catch {\n        // fall back to default\n      }\n    }\n    return arg;\n  });\n  return createBreadcrumb({\n    ...breadcrumb,\n    data: {\n      ...breadcrumb.data,\n      arguments: normalizedArgs,\n      ...(isTruncated ? {\n        _meta: {\n          warnings: ['CONSOLE_ARG_TRUNCATED']\n        }\n      } : {})\n    }\n  });\n}\nfunction isBreadcrumbWithCategory(breadcrumb) {\n  return !!breadcrumb.category;\n}\n\n/**\n * Returns true if we think the given event is an error originating inside of rrweb.\n */\nfunction isRrwebError(event, hint) {\n  if (event.type || !event.exception || !event.exception.values || !event.exception.values.length) {\n    return false;\n  }\n\n  // @ts-expect-error this may be set by rrweb when it finds errors\n  if (hint.originalException?.__rrweb__) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Reset the `replay_id` field on the DSC.\n */\nfunction resetReplayIdOnDynamicSamplingContext() {\n  // Reset DSC on the current scope, if there is one\n  const dsc = getCurrentScope().getPropagationContext().dsc;\n  if (dsc) {\n    delete dsc.replay_id;\n  }\n\n  // Clear it from frozen DSC on the active span\n  const activeSpan = getActiveSpan();\n  if (activeSpan) {\n    const dsc = getDynamicSamplingContextFromSpan(activeSpan);\n    delete dsc.replay_id;\n  }\n}\n\n/**\n * Add a feedback breadcrumb event to replay.\n */\nfunction addFeedbackBreadcrumb(replay, event) {\n  replay.triggerUserActivity();\n  replay.addUpdate(() => {\n    if (!event.timestamp) {\n      // Ignore events that don't have timestamps (this shouldn't happen, more of a typing issue)\n      // Return true here so that we don't flush\n      return true;\n    }\n\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: event.timestamp * 1000,\n      data: {\n        tag: 'breadcrumb',\n        payload: {\n          timestamp: event.timestamp,\n          type: 'default',\n          category: 'sentry.feedback',\n          data: {\n            feedbackId: event.event_id\n          }\n        }\n      }\n    });\n    return false;\n  });\n}\n\n/**\n * Determine if event should be sampled (only applies in buffer mode).\n * When an event is captured by `handleGlobalEvent`, when in buffer mode\n * we determine if we want to sample the error or not.\n */\nfunction shouldSampleForBufferEvent(replay, event) {\n  if (replay.recordingMode !== 'buffer') {\n    return false;\n  }\n\n  // ignore this error because otherwise we could loop indefinitely with\n  // trying to capture replay and failing\n  if (event.message === UNABLE_TO_SEND_REPLAY) {\n    return false;\n  }\n\n  // Require the event to be an error event & to have an exception\n  if (!event.exception || event.type) {\n    return false;\n  }\n  return isSampled(replay.getOptions().errorSampleRate);\n}\n\n/**\n * Returns a listener to be added to `addEventProcessor(listener)`.\n */\nfunction handleGlobalEventListener(replay) {\n  return Object.assign((event, hint) => {\n    // Do nothing if replay has been disabled or paused\n    if (!replay.isEnabled() || replay.isPaused()) {\n      return event;\n    }\n    if (isReplayEvent(event)) {\n      // Replays have separate set of breadcrumbs, do not include breadcrumbs\n      // from core SDK\n      delete event.breadcrumbs;\n      return event;\n    }\n\n    // We only want to handle errors, transactions, and feedbacks, nothing else\n    if (!isErrorEvent(event) && !isTransactionEvent(event) && !isFeedbackEvent(event)) {\n      return event;\n    }\n\n    // Ensure we do not add replay_id if the session is expired\n    const isSessionActive = replay.checkAndHandleExpiredSession();\n    if (!isSessionActive) {\n      // prevent exceeding replay durations by removing the expired replayId from the DSC\n      resetReplayIdOnDynamicSamplingContext();\n      return event;\n    }\n    if (isFeedbackEvent(event)) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      replay.flush();\n      event.contexts.feedback.replay_id = replay.getSessionId();\n      // Add a replay breadcrumb for this piece of feedback\n      addFeedbackBreadcrumb(replay, event);\n      return event;\n    }\n\n    // Unless `captureExceptions` is enabled, we want to ignore errors coming from rrweb\n    // As there can be a bunch of stuff going wrong in internals there, that we don't want to bubble up to users\n    if (isRrwebError(event, hint) && !replay.getOptions()._experiments.captureExceptions) {\n      DEBUG_BUILD && logger.log('Ignoring error from rrweb internals', event);\n      return null;\n    }\n\n    // When in buffer mode, we decide to sample here.\n    // Later, in `handleAfterSendEvent`, if the replayId is set, we know that we sampled\n    // And convert the buffer session to a full session\n    const isErrorEventSampled = shouldSampleForBufferEvent(replay, event);\n\n    // Tag errors if it has been sampled in buffer mode, or if it is session mode\n    // Only tag transactions if in session mode\n    const shouldTagReplayId = isErrorEventSampled || replay.recordingMode === 'session';\n    if (shouldTagReplayId) {\n      event.tags = {\n        ...event.tags,\n        replayId: replay.getSessionId()\n      };\n    }\n    return event;\n  }, {\n    id: 'Replay'\n  });\n}\n\n/**\n * Create a \"span\" for each performance entry.\n */\nfunction createPerformanceSpans(replay, entries) {\n  return entries.map(({\n    type,\n    start,\n    end,\n    name,\n    data\n  }) => {\n    const response = replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: start,\n      data: {\n        tag: 'performanceSpan',\n        payload: {\n          op: type,\n          description: name,\n          startTimestamp: start,\n          endTimestamp: end,\n          data\n        }\n      }\n    });\n\n    // If response is a string, it means its either THROTTLED or SKIPPED\n    return typeof response === 'string' ? Promise.resolve(null) : response;\n  });\n}\nfunction handleHistory(handlerData) {\n  const {\n    from,\n    to\n  } = handlerData;\n  const now = Date.now() / 1000;\n  return {\n    type: 'navigation.push',\n    start: now,\n    end: now,\n    name: to,\n    data: {\n      previous: from\n    }\n  };\n}\n\n/**\n * Returns a listener to be added to `addHistoryInstrumentationHandler(listener)`.\n */\nfunction handleHistorySpanListener(replay) {\n  return handlerData => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n    const result = handleHistory(handlerData);\n    if (result === null) {\n      return;\n    }\n\n    // Need to collect visited URLs\n    replay.getContext().urls.push(result.name);\n    replay.triggerUserActivity();\n    replay.addUpdate(() => {\n      createPerformanceSpans(replay, [result]);\n      // Returning false to flush\n      return false;\n    });\n  };\n}\n\n/**\n * Check whether a given request URL should be filtered out. This is so we\n * don't log Sentry ingest requests.\n */\nfunction shouldFilterRequest(replay, url) {\n  // If we enabled the `traceInternals` experiment, we want to trace everything\n  if (DEBUG_BUILD && replay.getOptions()._experiments.traceInternals) {\n    return false;\n  }\n  return isSentryRequestUrl(url, getClient());\n}\n\n/** Add a performance entry breadcrumb */\nfunction addNetworkBreadcrumb(replay, result) {\n  if (!replay.isEnabled()) {\n    return;\n  }\n  if (result === null) {\n    return;\n  }\n  if (shouldFilterRequest(replay, result.name)) {\n    return;\n  }\n  replay.addUpdate(() => {\n    createPerformanceSpans(replay, [result]);\n    // Returning true will cause `addUpdate` to not flush\n    // We do not want network requests to cause a flush. This will prevent\n    // recurring/polling requests from keeping the replay session alive.\n    return true;\n  });\n}\n\n/** Get the size of a body. */\nfunction getBodySize(body) {\n  if (!body) {\n    return undefined;\n  }\n  const textEncoder = new TextEncoder();\n  try {\n    if (typeof body === 'string') {\n      return textEncoder.encode(body).length;\n    }\n    if (body instanceof URLSearchParams) {\n      return textEncoder.encode(body.toString()).length;\n    }\n    if (body instanceof FormData) {\n      const formDataStr = serializeFormData(body);\n      return textEncoder.encode(formDataStr).length;\n    }\n    if (body instanceof Blob) {\n      return body.size;\n    }\n    if (body instanceof ArrayBuffer) {\n      return body.byteLength;\n    }\n\n    // Currently unhandled types: ArrayBufferView, ReadableStream\n  } catch {\n    // just return undefined\n  }\n  return undefined;\n}\n\n/** Convert a Content-Length header to number/undefined.  */\nfunction parseContentLengthHeader(header) {\n  if (!header) {\n    return undefined;\n  }\n  const size = parseInt(header, 10);\n  return isNaN(size) ? undefined : size;\n}\n\n/** Merge a warning into an existing network request/response. */\nfunction mergeWarning(info, warning) {\n  if (!info) {\n    return {\n      headers: {},\n      size: undefined,\n      _meta: {\n        warnings: [warning]\n      }\n    };\n  }\n  const newMeta = {\n    ...info._meta\n  };\n  const existingWarnings = newMeta.warnings || [];\n  newMeta.warnings = [...existingWarnings, warning];\n  info._meta = newMeta;\n  return info;\n}\n\n/** Convert ReplayNetworkRequestData to a PerformanceEntry. */\nfunction makeNetworkReplayBreadcrumb(type, data) {\n  if (!data) {\n    return null;\n  }\n  const {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request,\n    response\n  } = data;\n  const result = {\n    type,\n    start: startTimestamp / 1000,\n    end: endTimestamp / 1000,\n    name: url,\n    data: {\n      method,\n      statusCode,\n      request,\n      response\n    }\n  };\n  return result;\n}\n\n/** Build the request or response part of a replay network breadcrumb that was skipped. */\nfunction buildSkippedNetworkRequestOrResponse(bodySize) {\n  return {\n    headers: {},\n    size: bodySize,\n    _meta: {\n      warnings: ['URL_SKIPPED']\n    }\n  };\n}\n\n/** Build the request or response part of a replay network breadcrumb. */\nfunction buildNetworkRequestOrResponse(headers, bodySize, body) {\n  if (!bodySize && Object.keys(headers).length === 0) {\n    return undefined;\n  }\n  if (!bodySize) {\n    return {\n      headers\n    };\n  }\n  if (!body) {\n    return {\n      headers,\n      size: bodySize\n    };\n  }\n  const info = {\n    headers,\n    size: bodySize\n  };\n  const {\n    body: normalizedBody,\n    warnings\n  } = normalizeNetworkBody(body);\n  info.body = normalizedBody;\n  if (warnings?.length) {\n    info._meta = {\n      warnings\n    };\n  }\n  return info;\n}\n\n/** Filter a set of headers */\nfunction getAllowedHeaders(headers, allowedHeaders) {\n  return Object.entries(headers).reduce((filteredHeaders, [key, value]) => {\n    const normalizedKey = key.toLowerCase();\n    // Avoid putting empty strings into the headers\n    if (allowedHeaders.includes(normalizedKey) && headers[key]) {\n      filteredHeaders[normalizedKey] = value;\n    }\n    return filteredHeaders;\n  }, {});\n}\nfunction normalizeNetworkBody(body) {\n  if (!body || typeof body !== 'string') {\n    return {\n      body\n    };\n  }\n  const exceedsSizeLimit = body.length > NETWORK_BODY_MAX_SIZE;\n  const isProbablyJson = _strIsProbablyJson(body);\n  if (exceedsSizeLimit) {\n    const truncatedBody = body.slice(0, NETWORK_BODY_MAX_SIZE);\n    if (isProbablyJson) {\n      return {\n        body: truncatedBody,\n        warnings: ['MAYBE_JSON_TRUNCATED']\n      };\n    }\n    return {\n      body: `${truncatedBody}…`,\n      warnings: ['TEXT_TRUNCATED']\n    };\n  }\n  if (isProbablyJson) {\n    try {\n      const jsonBody = JSON.parse(body);\n      return {\n        body: jsonBody\n      };\n    } catch {\n      // fall back to just send the body as string\n    }\n  }\n  return {\n    body\n  };\n}\nfunction _strIsProbablyJson(str) {\n  const first = str[0];\n  const last = str[str.length - 1];\n\n  // Simple check: If this does not start & end with {} or [], it's not JSON\n  return first === '[' && last === ']' || first === '{' && last === '}';\n}\n\n/** Match an URL against a list of strings/Regex. */\nfunction urlMatches(url, urls) {\n  const fullUrl = getFullUrl(url);\n  return stringMatchesSomePattern(fullUrl, urls);\n}\n\n/** exported for tests */\nfunction getFullUrl(url, baseURI = WINDOW.document.baseURI) {\n  // Short circuit for common cases:\n  if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith(WINDOW.location.origin)) {\n    return url;\n  }\n  const fixedUrl = new URL(url, baseURI);\n\n  // If these do not match, we are not dealing with a relative URL, so just return it\n  if (fixedUrl.origin !== new URL(baseURI).origin) {\n    return url;\n  }\n  const fullUrl = fixedUrl.href;\n\n  // Remove trailing slashes, if they don't match the original URL\n  if (!url.endsWith('/') && fullUrl.endsWith('/')) {\n    return fullUrl.slice(0, -1);\n  }\n  return fullUrl;\n}\n\n/**\n * Capture a fetch breadcrumb to a replay.\n * This adds additional data (where appropriate).\n */\nasync function captureFetchBreadcrumbToReplay(breadcrumb, hint, options) {\n  try {\n    const data = await _prepareFetchData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb('resource.fetch', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to capture fetch breadcrumb');\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nfunction enrichFetchBreadcrumb(breadcrumb, hint) {\n  const {\n    input,\n    response\n  } = hint;\n  const body = input ? getFetchRequestArgBody(input) : undefined;\n  const reqSize = getBodySize(body);\n  const resSize = response ? parseContentLengthHeader(response.headers.get('content-length')) : undefined;\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\nasync function _prepareFetchData(breadcrumb, hint, options) {\n  const now = Date.now();\n  const {\n    startTimestamp = now,\n    endTimestamp = now\n  } = hint;\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize\n  } = breadcrumb.data;\n  const captureDetails = urlMatches(url, options.networkDetailAllowUrls) && !urlMatches(url, options.networkDetailDenyUrls);\n  const request = captureDetails ? _getRequestInfo(options, hint.input, requestBodySize) : buildSkippedNetworkRequestOrResponse(requestBodySize);\n  const response = await _getResponseInfo(captureDetails, options, hint.response, responseBodySize);\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request,\n    response\n  };\n}\nfunction _getRequestInfo({\n  networkCaptureBodies,\n  networkRequestHeaders\n}, input, requestBodySize) {\n  const headers = input ? getRequestHeaders(input, networkRequestHeaders) : {};\n  if (!networkCaptureBodies) {\n    return buildNetworkRequestOrResponse(headers, requestBodySize, undefined);\n  }\n\n  // We only want to transmit string or string-like bodies\n  const requestBody = getFetchRequestArgBody(input);\n  const [bodyStr, warning] = getBodyString(requestBody, logger);\n  const data = buildNetworkRequestOrResponse(headers, requestBodySize, bodyStr);\n  if (warning) {\n    return mergeWarning(data, warning);\n  }\n  return data;\n}\n\n/** Exported only for tests. */\nasync function _getResponseInfo(captureDetails, {\n  networkCaptureBodies,\n  networkResponseHeaders\n}, response, responseBodySize) {\n  if (!captureDetails && responseBodySize !== undefined) {\n    return buildSkippedNetworkRequestOrResponse(responseBodySize);\n  }\n  const headers = response ? getAllHeaders(response.headers, networkResponseHeaders) : {};\n  if (!response || !networkCaptureBodies && responseBodySize !== undefined) {\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n  const [bodyText, warning] = await _parseFetchResponseBody(response);\n  const result = getResponseData(bodyText, {\n    networkCaptureBodies,\n    responseBodySize,\n    captureDetails,\n    headers\n  });\n  if (warning) {\n    return mergeWarning(result, warning);\n  }\n  return result;\n}\nfunction getResponseData(bodyText, {\n  networkCaptureBodies,\n  responseBodySize,\n  captureDetails,\n  headers\n}) {\n  try {\n    const size = bodyText?.length && responseBodySize === undefined ? getBodySize(bodyText) : responseBodySize;\n    if (!captureDetails) {\n      return buildSkippedNetworkRequestOrResponse(size);\n    }\n    if (networkCaptureBodies) {\n      return buildNetworkRequestOrResponse(headers, size, bodyText);\n    }\n    return buildNetworkRequestOrResponse(headers, size, undefined);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to serialize response body');\n    // fallback\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n}\nasync function _parseFetchResponseBody(response) {\n  const res = _tryCloneResponse(response);\n  if (!res) {\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n  try {\n    const text = await _tryGetResponseText(res);\n    return [text];\n  } catch (error) {\n    if (error instanceof Error && error.message.indexOf('Timeout') > -1) {\n      DEBUG_BUILD && logger.warn('Parsing text body from response timed out');\n      return [undefined, 'BODY_PARSE_TIMEOUT'];\n    }\n    DEBUG_BUILD && logger.exception(error, 'Failed to get text body from response');\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n}\nfunction getAllHeaders(headers, allowedHeaders) {\n  const allHeaders = {};\n  allowedHeaders.forEach(header => {\n    if (headers.get(header)) {\n      allHeaders[header] = headers.get(header);\n    }\n  });\n  return allHeaders;\n}\nfunction getRequestHeaders(fetchArgs, allowedHeaders) {\n  if (fetchArgs.length === 1 && typeof fetchArgs[0] !== 'string') {\n    return getHeadersFromOptions(fetchArgs[0], allowedHeaders);\n  }\n  if (fetchArgs.length === 2) {\n    return getHeadersFromOptions(fetchArgs[1], allowedHeaders);\n  }\n  return {};\n}\nfunction getHeadersFromOptions(input, allowedHeaders) {\n  if (!input) {\n    return {};\n  }\n  const headers = input.headers;\n  if (!headers) {\n    return {};\n  }\n  if (headers instanceof Headers) {\n    return getAllHeaders(headers, allowedHeaders);\n  }\n\n  // We do not support this, as it is not really documented (anymore?)\n  if (Array.isArray(headers)) {\n    return {};\n  }\n  return getAllowedHeaders(headers, allowedHeaders);\n}\nfunction _tryCloneResponse(response) {\n  try {\n    // We have to clone this, as the body can only be read once\n    return response.clone();\n  } catch (error) {\n    // this can throw if the response was already consumed before\n    DEBUG_BUILD && logger.exception(error, 'Failed to clone response body');\n  }\n}\n\n/**\n * Get the response body of a fetch request, or timeout after 500ms.\n * Fetch can return a streaming body, that may not resolve (or not for a long time).\n * If that happens, we rather abort after a short time than keep waiting for this.\n */\nfunction _tryGetResponseText(response) {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout$3(() => reject(new Error('Timeout while trying to read response body')), 500);\n    _getResponseText(response).then(txt => resolve(txt), reason => reject(reason)).finally(() => clearTimeout(timeout));\n  });\n}\nasync function _getResponseText(response) {\n  // Force this to be a promise, just to be safe\n  // eslint-disable-next-line no-return-await\n  return await response.text();\n}\n\n/**\n * Capture an XHR breadcrumb to a replay.\n * This adds additional data (where appropriate).\n */\nasync function captureXhrBreadcrumbToReplay(breadcrumb, hint, options) {\n  try {\n    const data = _prepareXhrData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb('resource.xhr', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to capture xhr breadcrumb');\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nfunction enrichXhrBreadcrumb(breadcrumb, hint) {\n  const {\n    xhr,\n    input\n  } = hint;\n  if (!xhr) {\n    return;\n  }\n  const reqSize = getBodySize(input);\n  const resSize = xhr.getResponseHeader('content-length') ? parseContentLengthHeader(xhr.getResponseHeader('content-length')) : _getBodySize(xhr.response, xhr.responseType);\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\nfunction _prepareXhrData(breadcrumb, hint, options) {\n  const now = Date.now();\n  const {\n    startTimestamp = now,\n    endTimestamp = now,\n    input,\n    xhr\n  } = hint;\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize\n  } = breadcrumb.data;\n  if (!url) {\n    return null;\n  }\n  if (!xhr || !urlMatches(url, options.networkDetailAllowUrls) || urlMatches(url, options.networkDetailDenyUrls)) {\n    const request = buildSkippedNetworkRequestOrResponse(requestBodySize);\n    const response = buildSkippedNetworkRequestOrResponse(responseBodySize);\n    return {\n      startTimestamp,\n      endTimestamp,\n      url,\n      method,\n      statusCode,\n      request,\n      response\n    };\n  }\n  const xhrInfo = xhr[SENTRY_XHR_DATA_KEY];\n  const networkRequestHeaders = xhrInfo ? getAllowedHeaders(xhrInfo.request_headers, options.networkRequestHeaders) : {};\n  const networkResponseHeaders = getAllowedHeaders(getResponseHeaders(xhr), options.networkResponseHeaders);\n  const [requestBody, requestWarning] = options.networkCaptureBodies ? getBodyString(input, logger) : [undefined];\n  const [responseBody, responseWarning] = options.networkCaptureBodies ? _getXhrResponseBody(xhr) : [undefined];\n  const request = buildNetworkRequestOrResponse(networkRequestHeaders, requestBodySize, requestBody);\n  const response = buildNetworkRequestOrResponse(networkResponseHeaders, responseBodySize, responseBody);\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request: requestWarning ? mergeWarning(request, requestWarning) : request,\n    response: responseWarning ? mergeWarning(response, responseWarning) : response\n  };\n}\nfunction getResponseHeaders(xhr) {\n  const headers = xhr.getAllResponseHeaders();\n  if (!headers) {\n    return {};\n  }\n  return headers.split('\\r\\n').reduce((acc, line) => {\n    const [key, value] = line.split(': ');\n    if (value) {\n      acc[key.toLowerCase()] = value;\n    }\n    return acc;\n  }, {});\n}\nfunction _getXhrResponseBody(xhr) {\n  // We collect errors that happen, but only log them if we can't get any response body\n  const errors = [];\n  try {\n    return [xhr.responseText];\n  } catch (e) {\n    errors.push(e);\n  }\n\n  // Try to manually parse the response body, if responseText fails\n  try {\n    return _parseXhrResponse(xhr.response, xhr.responseType);\n  } catch (e) {\n    errors.push(e);\n  }\n  DEBUG_BUILD && logger.warn('Failed to get xhr response body', ...errors);\n  return [undefined];\n}\n\n/**\n * Get the string representation of the XHR response.\n * Based on MDN, these are the possible types of the response:\n * string\n * ArrayBuffer\n * Blob\n * Document\n * POJO\n *\n * Exported only for tests.\n */\nfunction _parseXhrResponse(body, responseType) {\n  try {\n    if (typeof body === 'string') {\n      return [body];\n    }\n    if (body instanceof Document) {\n      return [body.body.outerHTML];\n    }\n    if (responseType === 'json' && body && typeof body === 'object') {\n      return [JSON.stringify(body)];\n    }\n    if (!body) {\n      return [undefined];\n    }\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to serialize body', body);\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n  DEBUG_BUILD && logger.info('Skipping network body because of body type', body);\n  return [undefined, 'UNPARSEABLE_BODY_TYPE'];\n}\nfunction _getBodySize(body, responseType) {\n  try {\n    const bodyStr = responseType === 'json' && body && typeof body === 'object' ? JSON.stringify(body) : body;\n    return getBodySize(bodyStr);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * This method does two things:\n * - It enriches the regular XHR/fetch breadcrumbs with request/response size data\n * - It captures the XHR/fetch breadcrumbs to the replay\n *   (enriching it with further data that is _not_ added to the regular breadcrumbs)\n */\nfunction handleNetworkBreadcrumbs(replay) {\n  const client = getClient();\n  try {\n    const {\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders\n    } = replay.getOptions();\n    const options = {\n      replay,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders\n    };\n    if (client) {\n      client.on('beforeAddBreadcrumb', (breadcrumb, hint) => beforeAddNetworkBreadcrumb(options, breadcrumb, hint));\n    }\n  } catch {\n    // Do nothing\n  }\n}\n\n/** just exported for tests */\nfunction beforeAddNetworkBreadcrumb(options, breadcrumb, hint) {\n  if (!breadcrumb.data) {\n    return;\n  }\n  try {\n    if (_isXhrBreadcrumb(breadcrumb) && _isXhrHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichXhrBreadcrumb(breadcrumb, hint);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureXhrBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n    if (_isFetchBreadcrumb(breadcrumb) && _isFetchHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichFetchBreadcrumb(breadcrumb, hint);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureFetchBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n  } catch (e) {\n    DEBUG_BUILD && logger.exception(e, 'Error when enriching network breadcrumb');\n  }\n}\nfunction _isXhrBreadcrumb(breadcrumb) {\n  return breadcrumb.category === 'xhr';\n}\nfunction _isFetchBreadcrumb(breadcrumb) {\n  return breadcrumb.category === 'fetch';\n}\nfunction _isXhrHint(hint) {\n  return hint?.xhr;\n}\nfunction _isFetchHint(hint) {\n  return hint?.response;\n}\n\n/**\n * Add global listeners that cannot be removed.\n */\nfunction addGlobalListeners(replay, {\n  autoFlushOnFeedback\n}) {\n  // Listeners from core SDK //\n  const client = getClient();\n  addClickKeypressInstrumentationHandler(handleDomListener(replay));\n  addHistoryInstrumentationHandler(handleHistorySpanListener(replay));\n  handleBreadcrumbs(replay);\n  handleNetworkBreadcrumbs(replay);\n\n  // Tag all (non replay) events that get sent to Sentry with the current\n  // replay ID so that we can reference them later in the UI\n  const eventProcessor = handleGlobalEventListener(replay);\n  addEventProcessor(eventProcessor);\n\n  // If a custom client has no hooks yet, we continue to use the \"old\" implementation\n  if (client) {\n    client.on('beforeSendEvent', handleBeforeSendEvent(replay));\n    client.on('afterSendEvent', handleAfterSendEvent(replay));\n    client.on('createDsc', dsc => {\n      const replayId = replay.getSessionId();\n      // We do not want to set the DSC when in buffer mode, as that means the replay has not been sent (yet)\n      if (replayId && replay.isEnabled() && replay.recordingMode === 'session') {\n        // Ensure to check that the session is still active - it could have expired in the meanwhile\n        const isSessionActive = replay.checkAndHandleExpiredSession();\n        if (isSessionActive) {\n          dsc.replay_id = replayId;\n        }\n      }\n    });\n    client.on('spanStart', span => {\n      replay.lastActiveSpan = span;\n    });\n\n    // We may be missing the initial spanStart due to timing issues,\n    // so we capture it on finish again.\n    client.on('spanEnd', span => {\n      replay.lastActiveSpan = span;\n    });\n\n    // We want to attach the replay id to the feedback event\n    client.on('beforeSendFeedback', async (feedbackEvent, options) => {\n      const replayId = replay.getSessionId();\n      if (options?.includeReplay && replay.isEnabled() && replayId && feedbackEvent.contexts?.feedback) {\n        // In case the feedback is sent via API and not through our widget, we want to flush replay\n        if (feedbackEvent.contexts.feedback.source === 'api' && autoFlushOnFeedback) {\n          await replay.flush();\n        }\n        feedbackEvent.contexts.feedback.replay_id = replayId;\n      }\n    });\n    if (autoFlushOnFeedback) {\n      client.on('openFeedbackWidget', async () => {\n        await replay.flush();\n      });\n    }\n  }\n}\n\n/**\n * Create a \"span\" for the total amount of memory being used by JS objects\n * (including v8 internal objects).\n */\nasync function addMemoryEntry(replay) {\n  // window.performance.memory is a non-standard API and doesn't work on all browsers, so we try-catch this\n  try {\n    return Promise.all(createPerformanceSpans(replay, [\n    // @ts-expect-error memory doesn't exist on type Performance as the API is non-standard (we check that it exists above)\n    createMemoryEntry(WINDOW.performance.memory)]));\n  } catch (error) {\n    // Do nothing\n    return [];\n  }\n}\nfunction createMemoryEntry(memoryEntry) {\n  const {\n    jsHeapSizeLimit,\n    totalJSHeapSize,\n    usedJSHeapSize\n  } = memoryEntry;\n  // we don't want to use `getAbsoluteTime` because it adds the event time to the\n  // time origin, so we get the current timestamp instead\n  const time = Date.now() / 1000;\n  return {\n    type: 'memory',\n    name: 'memory',\n    start: time,\n    end: time,\n    data: {\n      memory: {\n        jsHeapSizeLimit,\n        totalJSHeapSize,\n        usedJSHeapSize\n      }\n    }\n  };\n}\n\n/**\n * Heavily simplified debounce function based on lodash.debounce.\n *\n * This function takes a callback function (@param fun) and delays its invocation\n * by @param wait milliseconds. Optionally, a maxWait can be specified in @param options,\n * which ensures that the callback is invoked at least once after the specified max. wait time.\n *\n * @param func the function whose invocation is to be debounced\n * @param wait the minimum time until the function is invoked after it was called once\n * @param options the options object, which can contain the `maxWait` property\n *\n * @returns the debounced version of the function, which needs to be called at least once to start the\n *          debouncing process. Subsequent calls will reset the debouncing timer and, in case @paramfunc\n *          was already invoked in the meantime, return @param func's return value.\n *          The debounced function has two additional properties:\n *          - `flush`: Invokes the debounced function immediately and returns its return value\n *          - `cancel`: Cancels the debouncing process and resets the debouncing timer\n */\nfunction debounce(func, wait, options) {\n  let callbackReturnValue;\n  let timerId;\n  let maxTimerId;\n  const maxWait = options?.maxWait ? Math.max(options.maxWait, wait) : 0;\n  function invokeFunc() {\n    cancelTimers();\n    callbackReturnValue = func();\n    return callbackReturnValue;\n  }\n  function cancelTimers() {\n    timerId !== undefined && clearTimeout(timerId);\n    maxTimerId !== undefined && clearTimeout(maxTimerId);\n    timerId = maxTimerId = undefined;\n  }\n  function flush() {\n    if (timerId !== undefined || maxTimerId !== undefined) {\n      return invokeFunc();\n    }\n    return callbackReturnValue;\n  }\n  function debounced() {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout$3(invokeFunc, wait);\n    if (maxWait && maxTimerId === undefined) {\n      maxTimerId = setTimeout$3(invokeFunc, maxWait);\n    }\n    return callbackReturnValue;\n  }\n  debounced.cancel = cancelTimers;\n  debounced.flush = flush;\n  return debounced;\n}\nconst NAVIGATOR = GLOBAL_OBJ.navigator;\n\n/**\n *  Disable sampling mousemove events on iOS browsers as this can cause blocking the main thread\n *  https://github.com/getsentry/sentry-javascript/issues/14534\n */\nfunction getRecordingSamplingOptions() {\n  if (/iPhone|iPad|iPod/i.test(NAVIGATOR?.userAgent ?? '') || /Macintosh/i.test(NAVIGATOR?.userAgent ?? '') && NAVIGATOR?.maxTouchPoints && NAVIGATOR?.maxTouchPoints > 1) {\n    return {\n      sampling: {\n        mousemove: false\n      }\n    };\n  }\n  return {};\n}\n\n/**\n * Handler for recording events.\n *\n * Adds to event buffer, and has varying flushing behaviors if the event was a checkout.\n */\nfunction getHandleRecordingEmit(replay) {\n  let hadFirstEvent = false;\n  return (event, _isCheckout) => {\n    // If this is false, it means session is expired, create and a new session and wait for checkout\n    if (!replay.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && logger.warn('Received replay event after session expired.');\n      return;\n    }\n\n    // `_isCheckout` is only set when the checkout is due to `checkoutEveryNms`\n    // We also want to treat the first event as a checkout, so we handle this specifically here\n    const isCheckout = _isCheckout || !hadFirstEvent;\n    hadFirstEvent = true;\n    if (replay.clickDetector) {\n      updateClickDetectorForRecordingEvent(replay.clickDetector, event);\n    }\n\n    // The handler returns `true` if we do not want to trigger debounced flush, `false` if we want to debounce flush.\n    replay.addUpdate(() => {\n      // The session is always started immediately on pageload/init, but for\n      // error-only replays, it should reflect the most recent checkout\n      // when an error occurs. Clear any state that happens before this current\n      // checkout. This needs to happen before `addEvent()` which updates state\n      // dependent on this reset.\n      if (replay.recordingMode === 'buffer' && isCheckout) {\n        replay.setInitialState();\n      }\n\n      // If the event is not added (e.g. due to being paused, disabled, or out of the max replay duration),\n      // Skip all further steps\n      if (!addEventSync(replay, event, isCheckout)) {\n        // Return true to skip scheduling a debounced flush\n        return true;\n      }\n\n      // Different behavior for full snapshots (type=2), ignore other event types\n      // See https://github.com/rrweb-io/rrweb/blob/d8f9290ca496712aa1e7d472549480c4e7876594/packages/rrweb/src/types.ts#L16\n      if (!isCheckout) {\n        return false;\n      }\n      const session = replay.session;\n\n      // Additionally, create a meta event that will capture certain SDK settings.\n      // In order to handle buffer mode, this needs to either be done when we\n      // receive checkout events or at flush time. We have an experimental mode\n      // to perform multiple checkouts a session (the idea is to improve\n      // seeking during playback), so also only include if segmentId is 0\n      // (handled in `addSettingsEvent`).\n      //\n      // `isCheckout` is always true, but want to be explicit that it should\n      // only be added for checkouts\n      addSettingsEvent(replay, isCheckout);\n\n      // When in buffer mode, make sure we adjust the session started date to the current earliest event of the buffer\n      // this should usually be the timestamp of the checkout event, but to be safe...\n      if (replay.recordingMode === 'buffer' && session && replay.eventBuffer) {\n        const earliestEvent = replay.eventBuffer.getEarliestTimestamp();\n        if (earliestEvent) {\n          DEBUG_BUILD && logger.info(`Updating session start time to earliest event in buffer to ${new Date(earliestEvent)}`);\n          session.started = earliestEvent;\n          if (replay.getOptions().stickySession) {\n            saveSession(session);\n          }\n        }\n      }\n\n      // If there is a previousSessionId after a full snapshot occurs, then\n      // the replay session was started due to session expiration. The new session\n      // is started before triggering a new checkout and contains the id\n      // of the previous session. Do not immediately flush in this case\n      // to avoid capturing only the checkout and instead the replay will\n      // be captured if they perform any follow-up actions.\n      if (session?.previousSessionId) {\n        return true;\n      }\n      if (replay.recordingMode === 'session') {\n        // If the full snapshot is due to an initial load, we will not have\n        // a previous session ID. In this case, we want to buffer events\n        // for a set amount of time before flushing. This can help avoid\n        // capturing replays of users that immediately close the window.\n\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        void replay.flush();\n      }\n      return true;\n    });\n  };\n}\n\n/**\n * Exported for tests\n */\nfunction createOptionsEvent(replay) {\n  const options = replay.getOptions();\n  return {\n    type: EventType.Custom,\n    timestamp: Date.now(),\n    data: {\n      tag: 'options',\n      payload: {\n        shouldRecordCanvas: replay.isRecordingCanvas(),\n        sessionSampleRate: options.sessionSampleRate,\n        errorSampleRate: options.errorSampleRate,\n        useCompressionOption: options.useCompression,\n        blockAllMedia: options.blockAllMedia,\n        maskAllText: options.maskAllText,\n        maskAllInputs: options.maskAllInputs,\n        useCompression: replay.eventBuffer ? replay.eventBuffer.type === 'worker' : false,\n        networkDetailHasUrls: options.networkDetailAllowUrls.length > 0,\n        networkCaptureBodies: options.networkCaptureBodies,\n        networkRequestHasHeaders: options.networkRequestHeaders.length > 0,\n        networkResponseHasHeaders: options.networkResponseHeaders.length > 0\n      }\n    }\n  };\n}\n\n/**\n * Add a \"meta\" event that contains a simplified view on current configuration\n * options. This should only be included on the first segment of a recording.\n */\nfunction addSettingsEvent(replay, isCheckout) {\n  // Only need to add this event when sending the first segment\n  if (!isCheckout || !replay.session || replay.session.segmentId !== 0) {\n    return;\n  }\n  addEventSync(replay, createOptionsEvent(replay), false);\n}\n\n/**\n * Create a replay envelope ready to be sent.\n * This includes both the replay event, as well as the recording data.\n */\nfunction createReplayEnvelope(replayEvent, recordingData, dsn, tunnel) {\n  return createEnvelope(createEventEnvelopeHeaders(replayEvent, getSdkMetadataForEnvelopeHeader(replayEvent), tunnel, dsn), [[{\n    type: 'replay_event'\n  }, replayEvent], [{\n    type: 'replay_recording',\n    // If string then we need to encode to UTF8, otherwise will have\n    // wrong size. TextEncoder has similar browser support to\n    // MutationObserver, although it does not accept IE11.\n    length: typeof recordingData === 'string' ? new TextEncoder().encode(recordingData).length : recordingData.length\n  }, recordingData]]);\n}\n\n/**\n * Prepare the recording data ready to be sent.\n */\nfunction prepareRecordingData({\n  recordingData,\n  headers\n}) {\n  let payloadWithSequence;\n\n  // XXX: newline is needed to separate sequence id from events\n  const replayHeaders = `${JSON.stringify(headers)}\n`;\n  if (typeof recordingData === 'string') {\n    payloadWithSequence = `${replayHeaders}${recordingData}`;\n  } else {\n    const enc = new TextEncoder();\n    // XXX: newline is needed to separate sequence id from events\n    const sequence = enc.encode(replayHeaders);\n    // Merge the two Uint8Arrays\n    payloadWithSequence = new Uint8Array(sequence.length + recordingData.length);\n    payloadWithSequence.set(sequence);\n    payloadWithSequence.set(recordingData, sequence.length);\n  }\n  return payloadWithSequence;\n}\n\n/**\n * Prepare a replay event & enrich it with the SDK metadata.\n */\nasync function prepareReplayEvent({\n  client,\n  scope,\n  replayId: event_id,\n  event\n}) {\n  const integrations = typeof client['_integrations'] === 'object' && client['_integrations'] !== null && !Array.isArray(client['_integrations']) ? Object.keys(client['_integrations']) : undefined;\n  const eventHint = {\n    event_id,\n    integrations\n  };\n  client.emit('preprocessEvent', event, eventHint);\n  const preparedEvent = await prepareEvent(client.getOptions(), event, eventHint, scope, client, getIsolationScope());\n\n  // If e.g. a global event processor returned null\n  if (!preparedEvent) {\n    return null;\n  }\n  client.emit('postprocessEvent', preparedEvent, eventHint);\n\n  // This normally happens in browser client \"_prepareEvent\"\n  // but since we do not use this private method from the client, but rather the plain import\n  // we need to do this manually.\n  preparedEvent.platform = preparedEvent.platform || 'javascript';\n\n  // extract the SDK name because `client._prepareEvent` doesn't add it to the event\n  const metadata = client.getSdkMetadata();\n  const {\n    name,\n    version\n  } = metadata?.sdk || {};\n  preparedEvent.sdk = {\n    ...preparedEvent.sdk,\n    name: name || 'sentry.javascript.unknown',\n    version: version || '0.0.0'\n  };\n  return preparedEvent;\n}\n\n/**\n * Send replay attachment using `fetch()`\n */\nasync function sendReplayRequest({\n  recordingData,\n  replayId,\n  segmentId: segment_id,\n  eventContext,\n  timestamp,\n  session\n}) {\n  const preparedRecordingData = prepareRecordingData({\n    recordingData,\n    headers: {\n      segment_id\n    }\n  });\n  const {\n    urls,\n    errorIds,\n    traceIds,\n    initialTimestamp\n  } = eventContext;\n  const client = getClient();\n  const scope = getCurrentScope();\n  const transport = client?.getTransport();\n  const dsn = client?.getDsn();\n  if (!client || !transport || !dsn || !session.sampled) {\n    return resolvedSyncPromise({});\n  }\n  const baseEvent = {\n    type: REPLAY_EVENT_NAME,\n    replay_start_timestamp: initialTimestamp / 1000,\n    timestamp: timestamp / 1000,\n    error_ids: errorIds,\n    trace_ids: traceIds,\n    urls,\n    replay_id: replayId,\n    segment_id,\n    replay_type: session.sampled\n  };\n  const replayEvent = await prepareReplayEvent({\n    scope,\n    client,\n    replayId,\n    event: baseEvent\n  });\n  if (!replayEvent) {\n    // Taken from baseclient's `_processEvent` method, where this is handled for errors/transactions\n    client.recordDroppedEvent('event_processor', 'replay');\n    DEBUG_BUILD && logger.info('An event processor returned `null`, will not send event.');\n    return resolvedSyncPromise({});\n  }\n\n  /*\n  For reference, the fully built event looks something like this:\n  {\n      \"type\": \"replay_event\",\n      \"timestamp\": 1670837008.634,\n      \"error_ids\": [\n          \"errorId\"\n      ],\n      \"trace_ids\": [\n          \"traceId\"\n      ],\n      \"urls\": [\n          \"https://example.com\"\n      ],\n      \"replay_id\": \"eventId\",\n      \"segment_id\": 3,\n      \"replay_type\": \"error\",\n      \"platform\": \"javascript\",\n      \"event_id\": \"eventId\",\n      \"environment\": \"production\",\n      \"sdk\": {\n          \"integrations\": [\n              \"BrowserTracing\",\n              \"Replay\"\n          ],\n          \"name\": \"sentry.javascript.browser\",\n          \"version\": \"7.25.0\"\n      },\n      \"sdkProcessingMetadata\": {},\n      \"contexts\": {\n      },\n  }\n  */\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete replayEvent.sdkProcessingMetadata;\n  const envelope = createReplayEnvelope(replayEvent, preparedRecordingData, dsn, client.getOptions().tunnel);\n  let response;\n  try {\n    response = await transport.send(envelope);\n  } catch (err) {\n    const error = new Error(UNABLE_TO_SEND_REPLAY);\n    try {\n      // In case browsers don't allow this property to be writable\n      // @ts-expect-error This needs lib es2022 and newer\n      error.cause = err;\n    } catch {\n      // nothing to do\n    }\n    throw error;\n  }\n\n  // If the status code is invalid, we want to immediately stop & not retry\n  if (typeof response.statusCode === 'number' && (response.statusCode < 200 || response.statusCode >= 300)) {\n    throw new TransportStatusCodeError(response.statusCode);\n  }\n  const rateLimits = updateRateLimits({}, response);\n  if (isRateLimited(rateLimits, 'replay')) {\n    throw new RateLimitError(rateLimits);\n  }\n  return response;\n}\n\n/**\n * This error indicates that the transport returned an invalid status code.\n */\nclass TransportStatusCodeError extends Error {\n  constructor(statusCode) {\n    super(`Transport returned status code ${statusCode}`);\n  }\n}\n\n/**\n * This error indicates that we hit a rate limit API error.\n */\nclass RateLimitError extends Error {\n  constructor(rateLimits) {\n    super('Rate limit hit');\n    this.rateLimits = rateLimits;\n  }\n}\n\n/**\n * Finalize and send the current replay event to Sentry\n */\nasync function sendReplay(replayData, retryConfig = {\n  count: 0,\n  interval: RETRY_BASE_INTERVAL\n}) {\n  const {\n    recordingData,\n    onError\n  } = replayData;\n\n  // short circuit if there's no events to upload (this shouldn't happen as _runFlush makes this check)\n  if (!recordingData.length) {\n    return;\n  }\n  try {\n    await sendReplayRequest(replayData);\n    return true;\n  } catch (err) {\n    if (err instanceof TransportStatusCodeError || err instanceof RateLimitError) {\n      throw err;\n    }\n\n    // Capture error for every failed replay\n    setContext('Replays', {\n      _retryCount: retryConfig.count\n    });\n    if (onError) {\n      onError(err);\n    }\n\n    // If an error happened here, it's likely that uploading the attachment\n    // failed, we'll can retry with the same events payload\n    if (retryConfig.count >= RETRY_MAX_COUNT) {\n      const error = new Error(`${UNABLE_TO_SEND_REPLAY} - max retries exceeded`);\n      try {\n        // In case browsers don't allow this property to be writable\n        // @ts-expect-error This needs lib es2022 and newer\n        error.cause = err;\n      } catch {\n        // nothing to do\n      }\n      throw error;\n    }\n\n    // will retry in intervals of 5, 10, 30\n    retryConfig.interval *= ++retryConfig.count;\n    return new Promise((resolve, reject) => {\n      setTimeout$3(async () => {\n        try {\n          await sendReplay(replayData, retryConfig);\n          resolve(true);\n        } catch (err) {\n          reject(err);\n        }\n      }, retryConfig.interval);\n    });\n  }\n}\nconst THROTTLED = '__THROTTLED';\nconst SKIPPED = '__SKIPPED';\n\n/**\n * Create a throttled function off a given function.\n * When calling the throttled function, it will call the original function only\n * if it hasn't been called more than `maxCount` times in the last `durationSeconds`.\n *\n * Returns `THROTTLED` if throttled for the first time, after that `SKIPPED`,\n * or else the return value of the original function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction throttle(fn, maxCount, durationSeconds) {\n  const counter = new Map();\n  const _cleanup = now => {\n    const threshold = now - durationSeconds;\n    counter.forEach((_value, key) => {\n      if (key < threshold) {\n        counter.delete(key);\n      }\n    });\n  };\n  const _getTotalCount = () => {\n    return [...counter.values()].reduce((a, b) => a + b, 0);\n  };\n  let isThrottled = false;\n  return (...rest) => {\n    // Date in second-precision, which we use as basis for the throttling\n    const now = Math.floor(Date.now() / 1000);\n\n    // First, make sure to delete any old entries\n    _cleanup(now);\n\n    // If already over limit, do nothing\n    if (_getTotalCount() >= maxCount) {\n      const wasThrottled = isThrottled;\n      isThrottled = true;\n      return wasThrottled ? SKIPPED : THROTTLED;\n    }\n    isThrottled = false;\n    const count = counter.get(now) || 0;\n    counter.set(now, count + 1);\n    return fn(...rest);\n  };\n}\n\n/* eslint-disable max-lines */ // TODO: We might want to split this file up\n\n/**\n * The main replay container class, which holds all the state and methods for recording and sending replays.\n */\nclass ReplayContainer {\n  /**\n   * Recording can happen in one of two modes:\n   *   - session: Record the whole session, sending it continuously\n   *   - buffer: Always keep the last 60s of recording, requires:\n   *     - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n   *     - or calling `flush()` to send the replay\n   */\n\n  /**\n   * The current or last active span.\n   * This is only available when performance is enabled.\n   */\n\n  /**\n   * These are here so we can overwrite them in tests etc.\n   * @hidden\n   */\n\n  /** The replay has to be manually started, because no sample rate (neither session or error) was provided. */\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n\n  /**\n   * Timestamp of the last user activity. This lives across sessions.\n   */\n\n  /**\n   * Is the integration currently active?\n   */\n\n  /**\n   * Paused is a state where:\n   * - DOM Recording is not listening at all\n   * - Nothing will be added to event buffer (e.g. core SDK events)\n   */\n\n  /**\n   * Have we attached listeners to the core SDK?\n   * Note we have to track this as there is no way to remove instrumentation handlers.\n   */\n\n  /**\n   * Function to stop recording\n   */\n\n  /**\n   * Internal use for canvas recording options\n   */\n\n  /**\n   * Handle when visibility of the page content changes. Opening a new tab will\n   * cause the state to change to hidden because of content of current page will\n   * be hidden. Likewise, moving a different window to cover the contents of the\n   * page will also trigger a change to a hidden state.\n   */\n\n  /**\n   * Handle when page is blurred\n   */\n\n  /**\n   * Handle when page is focused\n   */\n\n  /** Ensure page remains active when a key is pressed. */\n\n  constructor({\n    options,\n    recordingOptions\n  }) {\n    this.eventBuffer = null;\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n    this.recordingMode = 'session';\n    this.timeouts = {\n      sessionIdlePause: SESSION_IDLE_PAUSE_DURATION,\n      sessionIdleExpire: SESSION_IDLE_EXPIRE_DURATION\n    };\n    this._lastActivity = Date.now();\n    this._isEnabled = false;\n    this._isPaused = false;\n    this._requiresManualStart = false;\n    this._hasInitializedCoreListeners = false;\n    this._context = {\n      errorIds: new Set(),\n      traceIds: new Set(),\n      urls: [],\n      initialTimestamp: Date.now(),\n      initialUrl: ''\n    };\n    this._recordingOptions = recordingOptions;\n    this._options = options;\n    this._debouncedFlush = debounce(() => this._flush(), this._options.flushMinDelay, {\n      maxWait: this._options.flushMaxDelay\n    });\n    this._throttledAddEvent = throttle((event, isCheckout) => addEvent(this, event, isCheckout),\n    // Max 300 events...\n    300,\n    // ... per 5s\n    5);\n    const {\n      slowClickTimeout,\n      slowClickIgnoreSelectors\n    } = this.getOptions();\n    const slowClickConfig = slowClickTimeout ? {\n      threshold: Math.min(SLOW_CLICK_THRESHOLD, slowClickTimeout),\n      timeout: slowClickTimeout,\n      scrollTimeout: SLOW_CLICK_SCROLL_TIMEOUT,\n      ignoreSelector: slowClickIgnoreSelectors ? slowClickIgnoreSelectors.join(',') : ''\n    } : undefined;\n    if (slowClickConfig) {\n      this.clickDetector = new ClickDetector(this, slowClickConfig);\n    }\n\n    // Configure replay logger w/ experimental options\n    if (DEBUG_BUILD) {\n      const experiments = options._experiments;\n      logger.setConfig({\n        captureExceptions: !!experiments.captureExceptions,\n        traceInternals: !!experiments.traceInternals\n      });\n    }\n\n    // We set these handler properties as class properties, to make binding/unbinding them easier\n    this._handleVisibilityChange = () => {\n      if (WINDOW.document.visibilityState === 'visible') {\n        this._doChangeToForegroundTasks();\n      } else {\n        this._doChangeToBackgroundTasks();\n      }\n    };\n\n    /**\n     * Handle when page is blurred\n     */\n    this._handleWindowBlur = () => {\n      const breadcrumb = createBreadcrumb({\n        category: 'ui.blur'\n      });\n\n      // Do not count blur as a user action -- it's part of the process of them\n      // leaving the page\n      this._doChangeToBackgroundTasks(breadcrumb);\n    };\n    this._handleWindowFocus = () => {\n      const breadcrumb = createBreadcrumb({\n        category: 'ui.focus'\n      });\n\n      // Do not count focus as a user action -- instead wait until they focus and\n      // interactive with page\n      this._doChangeToForegroundTasks(breadcrumb);\n    };\n\n    /** Ensure page remains active when a key is pressed. */\n    this._handleKeyboardEvent = event => {\n      handleKeyboardEvent(this, event);\n    };\n  }\n\n  /** Get the event context. */\n  getContext() {\n    return this._context;\n  }\n\n  /** If recording is currently enabled. */\n  isEnabled() {\n    return this._isEnabled;\n  }\n\n  /** If recording is currently paused. */\n  isPaused() {\n    return this._isPaused;\n  }\n\n  /**\n   * Determine if canvas recording is enabled\n   */\n  isRecordingCanvas() {\n    return Boolean(this._canvas);\n  }\n\n  /** Get the replay integration options. */\n  getOptions() {\n    return this._options;\n  }\n\n  /** A wrapper to conditionally capture exceptions. */\n  handleException(error) {\n    DEBUG_BUILD && logger.exception(error);\n    if (this._options.onError) {\n      this._options.onError(error);\n    }\n  }\n\n  /**\n   * Initializes the plugin based on sampling configuration. Should not be\n   * called outside of constructor.\n   */\n  initializeSampling(previousSessionId) {\n    const {\n      errorSampleRate,\n      sessionSampleRate\n    } = this._options;\n\n    // If neither sample rate is > 0, then do nothing - user will need to call one of\n    // `start()` or `startBuffering` themselves.\n    const requiresManualStart = errorSampleRate <= 0 && sessionSampleRate <= 0;\n    this._requiresManualStart = requiresManualStart;\n    if (requiresManualStart) {\n      return;\n    }\n\n    // Otherwise if there is _any_ sample rate set, try to load an existing\n    // session, or create a new one.\n    this._initializeSessionForSampling(previousSessionId);\n    if (!this.session) {\n      // This should not happen, something wrong has occurred\n      DEBUG_BUILD && logger.exception(new Error('Unable to initialize and create session'));\n      return;\n    }\n    if (this.session.sampled === false) {\n      // This should only occur if `errorSampleRate` is 0 and was unsampled for\n      // session-based replay. In this case there is nothing to do.\n      return;\n    }\n\n    // If segmentId > 0, it means we've previously already captured this session\n    // In this case, we still want to continue in `session` recording mode\n    this.recordingMode = this.session.sampled === 'buffer' && this.session.segmentId === 0 ? 'buffer' : 'session';\n    DEBUG_BUILD && logger.infoTick(`Starting replay in ${this.recordingMode} mode`);\n    this._initializeRecording();\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will log a message if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * _performanceObserver, Recording, Sentry SDK, etc)\n   */\n  start() {\n    if (this._isEnabled && this.recordingMode === 'session') {\n      DEBUG_BUILD && logger.info('Recording is already in progress');\n      return;\n    }\n    if (this._isEnabled && this.recordingMode === 'buffer') {\n      DEBUG_BUILD && logger.info('Buffering is in progress, call `flush()` to save the replay');\n      return;\n    }\n    DEBUG_BUILD && logger.infoTick('Starting replay in session mode');\n\n    // Required as user activity is initially set in\n    // constructor, so if `start()` is called after\n    // session idle expiration, a replay will not be\n    // created due to an idle timeout.\n    this._updateUserActivity();\n    const session = loadOrCreateSession({\n      maxReplayDuration: this._options.maxReplayDuration,\n      sessionIdleExpire: this.timeouts.sessionIdleExpire\n    }, {\n      stickySession: this._options.stickySession,\n      // This is intentional: create a new session-based replay when calling `start()`\n      sessionSampleRate: 1,\n      allowBuffering: false\n    });\n    this.session = session;\n    this._initializeRecording();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, an error occurs.\n   */\n  startBuffering() {\n    if (this._isEnabled) {\n      DEBUG_BUILD && logger.info('Buffering is in progress, call `flush()` to save the replay');\n      return;\n    }\n    DEBUG_BUILD && logger.infoTick('Starting replay in buffer mode');\n    const session = loadOrCreateSession({\n      sessionIdleExpire: this.timeouts.sessionIdleExpire,\n      maxReplayDuration: this._options.maxReplayDuration\n    }, {\n      stickySession: this._options.stickySession,\n      sessionSampleRate: 0,\n      allowBuffering: true\n    });\n    this.session = session;\n    this.recordingMode = 'buffer';\n    this._initializeRecording();\n  }\n\n  /**\n   * Start recording.\n   *\n   * Note that this will cause a new DOM checkout\n   */\n  startRecording() {\n    try {\n      const canvasOptions = this._canvas;\n      this._stopRecording = record({\n        ...this._recordingOptions,\n        // When running in error sampling mode, we need to overwrite `checkoutEveryNms`\n        // Without this, it would record forever, until an error happens, which we don't want\n        // instead, we'll always keep the last 60 seconds of replay before an error happened\n        ...(this.recordingMode === 'buffer' ? {\n          checkoutEveryNms: BUFFER_CHECKOUT_TIME\n        } :\n        // Otherwise, use experimental option w/ min checkout time of 6 minutes\n        // This is to improve playback seeking as there could potentially be\n        // less mutations to process in the worse cases.\n        //\n        // checkout by \"N\" events is probably ideal, but means we have less\n        // control about the number of checkouts we make (which generally\n        // increases replay size)\n        this._options._experiments.continuousCheckout && {\n          // Minimum checkout time is 6 minutes\n          checkoutEveryNms: Math.max(360000, this._options._experiments.continuousCheckout)\n        }),\n        emit: getHandleRecordingEmit(this),\n        ...getRecordingSamplingOptions(),\n        onMutation: this._onMutationHandler.bind(this),\n        ...(canvasOptions ? {\n          recordCanvas: canvasOptions.recordCanvas,\n          getCanvasManager: canvasOptions.getCanvasManager,\n          sampling: canvasOptions.sampling,\n          dataURLOptions: canvasOptions.dataURLOptions\n        } : {})\n      });\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Stops the recording, if it was running.\n   *\n   * Returns true if it was previously stopped, or is now stopped,\n   * otherwise false.\n   */\n  stopRecording() {\n    try {\n      if (this._stopRecording) {\n        this._stopRecording();\n        this._stopRecording = undefined;\n      }\n      return true;\n    } catch (err) {\n      this.handleException(err);\n      return false;\n    }\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n  async stop({\n    forceFlush = false,\n    reason\n  } = {}) {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    // We can't move `_isEnabled` after awaiting a flush, otherwise we can\n    // enter into an infinite loop when `stop()` is called while flushing.\n    this._isEnabled = false;\n    try {\n      DEBUG_BUILD && logger.info(`Stopping Replay${reason ? ` triggered by ${reason}` : ''}`);\n      resetReplayIdOnDynamicSamplingContext();\n      this._removeListeners();\n      this.stopRecording();\n      this._debouncedFlush.cancel();\n      // See comment above re: `_isEnabled`, we \"force\" a flush, ignoring the\n      // `_isEnabled` state of the plugin since it was disabled above.\n      if (forceFlush) {\n        await this._flush({\n          force: true\n        });\n      }\n\n      // After flush, destroy event buffer\n      this.eventBuffer?.destroy();\n      this.eventBuffer = null;\n\n      // Clear session from session storage, note this means if a new session\n      // is started after, it will not have `previousSessionId`\n      clearSession(this);\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Pause some replay functionality. See comments for `_isPaused`.\n   * This differs from stop as this only stops DOM recording, it is\n   * not as thorough of a shutdown as `stop()`.\n   */\n  pause() {\n    if (this._isPaused) {\n      return;\n    }\n    this._isPaused = true;\n    this.stopRecording();\n    DEBUG_BUILD && logger.info('Pausing replay');\n  }\n\n  /**\n   * Resumes recording, see notes for `pause().\n   *\n   * Note that calling `startRecording()` here will cause a\n   * new DOM checkout.`\n   */\n  resume() {\n    if (!this._isPaused || !this._checkSession()) {\n      return;\n    }\n    this._isPaused = false;\n    this.startRecording();\n    DEBUG_BUILD && logger.info('Resuming replay');\n  }\n\n  /**\n   * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a \"session\"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n  async sendBufferedReplayOrFlush({\n    continueRecording = true\n  } = {}) {\n    if (this.recordingMode === 'session') {\n      return this.flushImmediate();\n    }\n    const activityTime = Date.now();\n    DEBUG_BUILD && logger.info('Converting buffer to session');\n\n    // Allow flush to complete before resuming as a session recording, otherwise\n    // the checkout from `startRecording` may be included in the payload.\n    // Prefer to keep the error replay as a separate (and smaller) segment\n    // than the session replay.\n    await this.flushImmediate();\n    const hasStoppedRecording = this.stopRecording();\n    if (!continueRecording || !hasStoppedRecording) {\n      return;\n    }\n\n    // To avoid race conditions where this is called multiple times, we check here again that we are still buffering\n    if (this.recordingMode === 'session') {\n      return;\n    }\n\n    // Re-start recording in session-mode\n    this.recordingMode = 'session';\n\n    // Once this session ends, we do not want to refresh it\n    if (this.session) {\n      this._updateUserActivity(activityTime);\n      this._updateSessionActivity(activityTime);\n      this._maybeSaveSession();\n    }\n    this.startRecording();\n  }\n\n  /**\n   * We want to batch uploads of replay events. Save events only if\n   * `<flushMinDelay>` milliseconds have elapsed since the last event\n   * *OR* if `<flushMaxDelay>` milliseconds have elapsed.\n   *\n   * Accepts a callback to perform side-effects and returns true to stop batch\n   * processing and hand back control to caller.\n   */\n  addUpdate(cb) {\n    // We need to always run `cb` (e.g. in the case of `this.recordingMode == 'buffer'`)\n    const cbResult = cb();\n\n    // If this option is turned on then we will only want to call `flush`\n    // explicitly\n    if (this.recordingMode === 'buffer') {\n      return;\n    }\n\n    // If callback is true, we do not want to continue with flushing -- the\n    // caller will need to handle it.\n    if (cbResult === true) {\n      return;\n    }\n\n    // addUpdate is called quite frequently - use _debouncedFlush so that it\n    // respects the flush delays and does not flush immediately\n    this._debouncedFlush();\n  }\n\n  /**\n   * Updates the user activity timestamp and resumes recording. This should be\n   * called in an event handler for a user action that we consider as the user\n   * being \"active\" (e.g. a mouse click).\n   */\n  triggerUserActivity() {\n    this._updateUserActivity();\n\n    // This case means that recording was once stopped due to inactivity.\n    // Ensure that recording is resumed.\n    if (!this._stopRecording) {\n      // Create a new session, otherwise when the user action is flushed, it\n      // will get rejected due to an expired session.\n      if (!this._checkSession()) {\n        return;\n      }\n\n      // Note: This will cause a new DOM checkout\n      this.resume();\n      return;\n    }\n\n    // Otherwise... recording was never suspended, continue as normalish\n    this.checkAndHandleExpiredSession();\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Updates the user activity timestamp *without* resuming\n   * recording. Some user events (e.g. keydown) can be create\n   * low-value replays that only contain the keypress as a\n   * breadcrumb. Instead this would require other events to\n   * create a new replay after a session has expired.\n   */\n  updateUserActivity() {\n    this._updateUserActivity();\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Only flush if `this.recordingMode === 'session'`\n   */\n  conditionalFlush() {\n    if (this.recordingMode === 'buffer') {\n      return Promise.resolve();\n    }\n    return this.flushImmediate();\n  }\n\n  /**\n   * Flush using debounce flush\n   */\n  flush() {\n    return this._debouncedFlush();\n  }\n\n  /**\n   * Always flush via `_debouncedFlush` so that we do not have flushes triggered\n   * from calling both `flush` and `_debouncedFlush`. Otherwise, there could be\n   * cases of multiple flushes happening closely together.\n   */\n  flushImmediate() {\n    this._debouncedFlush();\n    // `.flush` is provided by the debounced function, analogously to lodash.debounce\n    return this._debouncedFlush.flush();\n  }\n\n  /**\n   * Cancels queued up flushes.\n   */\n  cancelFlush() {\n    this._debouncedFlush.cancel();\n  }\n\n  /** Get the current session (=replay) ID */\n  getSessionId() {\n    return this.session?.id;\n  }\n\n  /**\n   * Checks if recording should be stopped due to user inactivity. Otherwise\n   * check if session is expired and create a new session if so. Triggers a new\n   * full snapshot on new session.\n   *\n   * Returns true if session is not expired, false otherwise.\n   * @hidden\n   */\n  checkAndHandleExpiredSession() {\n    // Prevent starting a new session if the last user activity is older than\n    // SESSION_IDLE_PAUSE_DURATION. Otherwise non-user activity can trigger a new\n    // session+recording. This creates noisy replays that do not have much\n    // content in them.\n    if (this._lastActivity && isExpired(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && this.session.sampled === 'session') {\n      // Pause recording only for session-based replays. Otherwise, resuming\n      // will create a new replay and will conflict with users who only choose\n      // to record error-based replays only. (e.g. the resumed replay will not\n      // contain a reference to an error)\n      this.pause();\n      return;\n    }\n\n    // --- There is recent user activity --- //\n    // This will create a new session if expired, based on expiry length\n    if (!this._checkSession()) {\n      // Check session handles the refreshing itself\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Capture some initial state that can change throughout the lifespan of the\n   * replay. This is required because otherwise they would be captured at the\n   * first flush.\n   */\n  setInitialState() {\n    const urlPath = `${WINDOW.location.pathname}${WINDOW.location.hash}${WINDOW.location.search}`;\n    const url = `${WINDOW.location.origin}${urlPath}`;\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    // Reset _context as well\n    this._clearContext();\n    this._context.initialUrl = url;\n    this._context.initialTimestamp = Date.now();\n    this._context.urls.push(url);\n  }\n\n  /**\n   * Add a breadcrumb event, that may be throttled.\n   * If it was throttled, we add a custom breadcrumb to indicate that.\n   */\n  throttledAddEvent(event, isCheckout) {\n    const res = this._throttledAddEvent(event, isCheckout);\n\n    // If this is THROTTLED, it means we have throttled the event for the first time\n    // In this case, we want to add a breadcrumb indicating that something was skipped\n    if (res === THROTTLED) {\n      const breadcrumb = createBreadcrumb({\n        category: 'replay.throttled'\n      });\n      this.addUpdate(() => {\n        // Return `false` if the event _was_ added, as that means we schedule a flush\n        return !addEventSync(this, {\n          type: ReplayEventTypeCustom,\n          timestamp: breadcrumb.timestamp || 0,\n          data: {\n            tag: 'breadcrumb',\n            payload: breadcrumb,\n            metric: true\n          }\n        });\n      });\n    }\n    return res;\n  }\n\n  /**\n   * This will get the parametrized route name of the current page.\n   * This is only available if performance is enabled, and if an instrumented router is used.\n   */\n  getCurrentRoute() {\n    const lastActiveSpan = this.lastActiveSpan || getActiveSpan();\n    const lastRootSpan = lastActiveSpan && getRootSpan(lastActiveSpan);\n    const attributes = lastRootSpan && spanToJSON(lastRootSpan).data || {};\n    const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n    if (!lastRootSpan || !source || !['route', 'custom'].includes(source)) {\n      return undefined;\n    }\n    return spanToJSON(lastRootSpan).description;\n  }\n\n  /**\n   * Initialize and start all listeners to varying events (DOM,\n   * Performance Observer, Recording, Sentry SDK, etc)\n   */\n  _initializeRecording() {\n    this.setInitialState();\n\n    // this method is generally called on page load or manually - in both cases\n    // we should treat it as an activity\n    this._updateSessionActivity();\n    this.eventBuffer = createEventBuffer({\n      useCompression: this._options.useCompression,\n      workerUrl: this._options.workerUrl\n    });\n    this._removeListeners();\n    this._addListeners();\n\n    // Need to set as enabled before we start recording, as `record()` can trigger a flush with a new checkout\n    this._isEnabled = true;\n    this._isPaused = false;\n    this.startRecording();\n  }\n\n  /**\n   * Loads (or refreshes) the current session.\n   */\n  _initializeSessionForSampling(previousSessionId) {\n    // Whenever there is _any_ error sample rate, we always allow buffering\n    // Because we decide on sampling when an error occurs, we need to buffer at all times if sampling for errors\n    const allowBuffering = this._options.errorSampleRate > 0;\n    const session = loadOrCreateSession({\n      sessionIdleExpire: this.timeouts.sessionIdleExpire,\n      maxReplayDuration: this._options.maxReplayDuration,\n      previousSessionId\n    }, {\n      stickySession: this._options.stickySession,\n      sessionSampleRate: this._options.sessionSampleRate,\n      allowBuffering\n    });\n    this.session = session;\n  }\n\n  /**\n   * Checks and potentially refreshes the current session.\n   * Returns false if session is not recorded.\n   */\n  _checkSession() {\n    // If there is no session yet, we do not want to refresh anything\n    // This should generally not happen, but to be safe....\n    if (!this.session) {\n      return false;\n    }\n    const currentSession = this.session;\n    if (shouldRefreshSession(currentSession, {\n      sessionIdleExpire: this.timeouts.sessionIdleExpire,\n      maxReplayDuration: this._options.maxReplayDuration\n    })) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._refreshSession(currentSession);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Refresh a session with a new one.\n   * This stops the current session (without forcing a flush, as that would never work since we are expired),\n   * and then does a new sampling based on the refreshed session.\n   */\n  async _refreshSession(session) {\n    if (!this._isEnabled) {\n      return;\n    }\n    await this.stop({\n      reason: 'refresh session'\n    });\n    this.initializeSampling(session.id);\n  }\n\n  /**\n   * Adds listeners to record events for the replay\n   */\n  _addListeners() {\n    try {\n      WINDOW.document.addEventListener('visibilitychange', this._handleVisibilityChange);\n      WINDOW.addEventListener('blur', this._handleWindowBlur);\n      WINDOW.addEventListener('focus', this._handleWindowFocus);\n      WINDOW.addEventListener('keydown', this._handleKeyboardEvent);\n      if (this.clickDetector) {\n        this.clickDetector.addListeners();\n      }\n\n      // There is no way to remove these listeners, so ensure they are only added once\n      if (!this._hasInitializedCoreListeners) {\n        addGlobalListeners(this, {\n          autoFlushOnFeedback: this._options._experiments.autoFlushOnFeedback\n        });\n        this._hasInitializedCoreListeners = true;\n      }\n    } catch (err) {\n      this.handleException(err);\n    }\n    this._performanceCleanupCallback = setupPerformanceObserver(this);\n  }\n\n  /**\n   * Cleans up listeners that were created in `_addListeners`\n   */\n  _removeListeners() {\n    try {\n      WINDOW.document.removeEventListener('visibilitychange', this._handleVisibilityChange);\n      WINDOW.removeEventListener('blur', this._handleWindowBlur);\n      WINDOW.removeEventListener('focus', this._handleWindowFocus);\n      WINDOW.removeEventListener('keydown', this._handleKeyboardEvent);\n      if (this.clickDetector) {\n        this.clickDetector.removeListeners();\n      }\n      if (this._performanceCleanupCallback) {\n        this._performanceCleanupCallback();\n      }\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Tasks to run when we consider a page to be hidden (via blurring and/or visibility)\n   */\n  _doChangeToBackgroundTasks(breadcrumb) {\n    if (!this.session) {\n      return;\n    }\n    const expired = isSessionExpired(this.session, {\n      maxReplayDuration: this._options.maxReplayDuration,\n      sessionIdleExpire: this.timeouts.sessionIdleExpire\n    });\n    if (expired) {\n      return;\n    }\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Send replay when the page/tab becomes hidden. There is no reason to send\n    // replay if it becomes visible, since no actions we care about were done\n    // while it was hidden\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    void this.conditionalFlush();\n  }\n\n  /**\n   * Tasks to run when we consider a page to be visible (via focus and/or visibility)\n   */\n  _doChangeToForegroundTasks(breadcrumb) {\n    if (!this.session) {\n      return;\n    }\n    const isSessionActive = this.checkAndHandleExpiredSession();\n    if (!isSessionActive) {\n      // If the user has come back to the page within SESSION_IDLE_PAUSE_DURATION\n      // ms, we will re-use the existing session, otherwise create a new\n      // session\n      DEBUG_BUILD && logger.info('Document has become active, but session has expired');\n      return;\n    }\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n  }\n\n  /**\n   * Update user activity (across session lifespans)\n   */\n  _updateUserActivity(_lastActivity = Date.now()) {\n    this._lastActivity = _lastActivity;\n  }\n\n  /**\n   * Updates the session's last activity timestamp\n   */\n  _updateSessionActivity(_lastActivity = Date.now()) {\n    if (this.session) {\n      this.session.lastActivity = _lastActivity;\n      this._maybeSaveSession();\n    }\n  }\n\n  /**\n   * Helper to create (and buffer) a replay breadcrumb from a core SDK breadcrumb\n   */\n  _createCustomBreadcrumb(breadcrumb) {\n    this.addUpdate(() => {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.throttledAddEvent({\n        type: EventType.Custom,\n        timestamp: breadcrumb.timestamp || 0,\n        data: {\n          tag: 'breadcrumb',\n          payload: breadcrumb\n        }\n      });\n    });\n  }\n\n  /**\n   * Observed performance events are added to `this.performanceEntries`. These\n   * are included in the replay event before it is finished and sent to Sentry.\n   */\n  _addPerformanceEntries() {\n    let performanceEntries = createPerformanceEntries(this.performanceEntries).concat(this.replayPerformanceEntries);\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    // If we are manually starting, we want to ensure we only include performance entries\n    // that are after the initial timestamp\n    // The reason for this is that we may have performance entries from the page load, but may decide to start\n    // the replay later on, in which case we do not want to include these entries.\n    // without this, manually started replays can have events long before the actual replay recording starts,\n    // which messes with the timeline etc.\n    if (this._requiresManualStart) {\n      const initialTimestampInSeconds = this._context.initialTimestamp / 1000;\n      performanceEntries = performanceEntries.filter(entry => entry.start >= initialTimestampInSeconds);\n    }\n    return Promise.all(createPerformanceSpans(this, performanceEntries));\n  }\n\n  /**\n   * Clear _context\n   */\n  _clearContext() {\n    // XXX: `initialTimestamp` and `initialUrl` do not get cleared\n    this._context.errorIds.clear();\n    this._context.traceIds.clear();\n    this._context.urls = [];\n  }\n\n  /** Update the initial timestamp based on the buffer content. */\n  _updateInitialTimestampFromEventBuffer() {\n    const {\n      session,\n      eventBuffer\n    } = this;\n    // If replay was started manually (=no sample rate was given),\n    // We do not want to back-port the initial timestamp\n    if (!session || !eventBuffer || this._requiresManualStart) {\n      return;\n    }\n\n    // we only ever update this on the initial segment\n    if (session.segmentId) {\n      return;\n    }\n    const earliestEvent = eventBuffer.getEarliestTimestamp();\n    if (earliestEvent && earliestEvent < this._context.initialTimestamp) {\n      this._context.initialTimestamp = earliestEvent;\n    }\n  }\n\n  /**\n   * Return and clear _context\n   */\n  _popEventContext() {\n    const _context = {\n      initialTimestamp: this._context.initialTimestamp,\n      initialUrl: this._context.initialUrl,\n      errorIds: Array.from(this._context.errorIds),\n      traceIds: Array.from(this._context.traceIds),\n      urls: this._context.urls\n    };\n    this._clearContext();\n    return _context;\n  }\n\n  /**\n   * Flushes replay event buffer to Sentry.\n   *\n   * Performance events are only added right before flushing - this is\n   * due to the buffered performance observer events.\n   *\n   * Should never be called directly, only by `flush`\n   */\n  async _runFlush() {\n    const replayId = this.getSessionId();\n    if (!this.session || !this.eventBuffer || !replayId) {\n      DEBUG_BUILD && logger.error('No session or eventBuffer found to flush.');\n      return;\n    }\n    await this._addPerformanceEntries();\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer?.hasEvents) {\n      return;\n    }\n\n    // Only attach memory event if eventBuffer is not empty\n    await addMemoryEntry(this);\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer) {\n      return;\n    }\n\n    // if this changed in the meanwhile, e.g. because the session was refreshed or similar, we abort here\n    if (replayId !== this.getSessionId()) {\n      return;\n    }\n    try {\n      // This uses the data from the eventBuffer, so we need to call this before `finish()\n      this._updateInitialTimestampFromEventBuffer();\n      const timestamp = Date.now();\n\n      // Check total duration again, to avoid sending outdated stuff\n      // We leave 30s wiggle room to accommodate late flushing etc.\n      // This _could_ happen when the browser is suspended during flushing, in which case we just want to stop\n      if (timestamp - this._context.initialTimestamp > this._options.maxReplayDuration + 30000) {\n        throw new Error('Session is too long, not sending replay');\n      }\n      const eventContext = this._popEventContext();\n      // Always increment segmentId regardless of outcome of sending replay\n      const segmentId = this.session.segmentId++;\n      this._maybeSaveSession();\n\n      // Note this empties the event buffer regardless of outcome of sending replay\n      const recordingData = await this.eventBuffer.finish();\n      await sendReplay({\n        replayId,\n        recordingData,\n        segmentId,\n        eventContext,\n        session: this.session,\n        timestamp,\n        onError: err => this.handleException(err)\n      });\n    } catch (err) {\n      this.handleException(err);\n\n      // This means we retried 3 times and all of them failed,\n      // or we ran into a problem we don't want to retry, like rate limiting.\n      // In this case, we want to completely stop the replay - otherwise, we may get inconsistent segments\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({\n        reason: 'sendReplay'\n      });\n      const client = getClient();\n      if (client) {\n        const dropReason = err instanceof RateLimitError ? 'ratelimit_backoff' : 'send_error';\n        client.recordDroppedEvent(dropReason, 'replay');\n      }\n    }\n  }\n\n  /**\n   * Flush recording data to Sentry. Creates a lock so that only a single flush\n   * can be active at a time. Do not call this directly.\n   */\n  async _flush({\n    force = false\n  } = {}) {\n    if (!this._isEnabled && !force) {\n      // This can happen if e.g. the replay was stopped because of exceeding the retry limit\n      return;\n    }\n    if (!this.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && logger.error('Attempting to finish replay event after session expired.');\n      return;\n    }\n    if (!this.session) {\n      // should never happen, as we would have bailed out before\n      return;\n    }\n    const start = this.session.started;\n    const now = Date.now();\n    const duration = now - start;\n\n    // A flush is about to happen, cancel any queued flushes\n    this._debouncedFlush.cancel();\n\n    // If session is too short, or too long (allow some wiggle room over maxReplayDuration), do not send it\n    // This _should_ not happen, but it may happen if flush is triggered due to a page activity change or similar\n    const tooShort = duration < this._options.minReplayDuration;\n    const tooLong = duration > this._options.maxReplayDuration + 5000;\n    if (tooShort || tooLong) {\n      DEBUG_BUILD && logger.info(`Session duration (${Math.floor(duration / 1000)}s) is too ${tooShort ? 'short' : 'long'}, not sending replay.`);\n      if (tooShort) {\n        this._debouncedFlush();\n      }\n      return;\n    }\n    const eventBuffer = this.eventBuffer;\n    if (eventBuffer && this.session.segmentId === 0 && !eventBuffer.hasCheckout) {\n      DEBUG_BUILD && logger.info('Flushing initial segment without checkout.');\n      // TODO FN: Evaluate if we want to stop here, or remove this again?\n    }\n    const _flushInProgress = !!this._flushLock;\n\n    // this._flushLock acts as a lock so that future calls to `_flush()` will\n    // be blocked until current flush is finished (i.e. this promise resolves)\n    if (!this._flushLock) {\n      this._flushLock = this._runFlush();\n    }\n    try {\n      await this._flushLock;\n    } catch (err) {\n      this.handleException(err);\n    } finally {\n      this._flushLock = undefined;\n      if (_flushInProgress) {\n        // Wait for previous flush to finish, then call the debounced\n        // `_flush()`. It's possible there are other flush requests queued and\n        // waiting for it to resolve. We want to reduce all outstanding\n        // requests (as well as any new flush requests that occur within a\n        // second of the locked flush completing) into a single flush.\n        this._debouncedFlush();\n      }\n    }\n  }\n\n  /** Save the session, if it is sticky */\n  _maybeSaveSession() {\n    if (this.session && this._options.stickySession) {\n      saveSession(this.session);\n    }\n  }\n\n  /** Handler for rrweb.record.onMutation */\n  _onMutationHandler(mutations) {\n    const count = mutations.length;\n    const mutationLimit = this._options.mutationLimit;\n    const mutationBreadcrumbLimit = this._options.mutationBreadcrumbLimit;\n    const overMutationLimit = mutationLimit && count > mutationLimit;\n\n    // Create a breadcrumb if a lot of mutations happen at the same time\n    // We can show this in the UI as an information with potential performance improvements\n    if (count > mutationBreadcrumbLimit || overMutationLimit) {\n      const breadcrumb = createBreadcrumb({\n        category: 'replay.mutations',\n        data: {\n          count,\n          limit: overMutationLimit\n        }\n      });\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Stop replay if over the mutation limit\n    if (overMutationLimit) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({\n        reason: 'mutationLimit',\n        forceFlush: this.recordingMode === 'session'\n      });\n      return false;\n    }\n\n    // `true` means we use the regular mutation handling by rrweb\n    return true;\n  }\n}\nfunction getOption(selectors, defaultSelectors) {\n  return [...selectors,\n  // sentry defaults\n  ...defaultSelectors].join(',');\n}\n\n/**\n * Returns privacy related configuration for use in rrweb\n */\nfunction getPrivacyOptions({\n  mask,\n  unmask,\n  block,\n  unblock,\n  ignore\n}) {\n  const defaultBlockedElements = ['base', 'iframe[srcdoc]:not([src])'];\n  const maskSelector = getOption(mask, ['.sentry-mask', '[data-sentry-mask]']);\n  const unmaskSelector = getOption(unmask, []);\n  const options = {\n    // We are making the decision to make text and input selectors the same\n    maskTextSelector: maskSelector,\n    unmaskTextSelector: unmaskSelector,\n    blockSelector: getOption(block, ['.sentry-block', '[data-sentry-block]', ...defaultBlockedElements]),\n    unblockSelector: getOption(unblock, []),\n    ignoreSelector: getOption(ignore, ['.sentry-ignore', '[data-sentry-ignore]', 'input[type=\"file\"]'])\n  };\n  return options;\n}\n\n/**\n * Masks an attribute if necessary, otherwise return attribute value as-is.\n */\nfunction maskAttribute({\n  el,\n  key,\n  maskAttributes,\n  maskAllText,\n  privacyOptions,\n  value\n}) {\n  // We only mask attributes if `maskAllText` is true\n  if (!maskAllText) {\n    return value;\n  }\n\n  // unmaskTextSelector takes precedence\n  if (privacyOptions.unmaskTextSelector && el.matches(privacyOptions.unmaskTextSelector)) {\n    return value;\n  }\n  if (maskAttributes.includes(key) ||\n  // Need to mask `value` attribute for `<input>` if it's a button-like\n  // type\n  key === 'value' && el.tagName === 'INPUT' && ['submit', 'button'].includes(el.getAttribute('type') || '')) {\n    return value.replace(/[\\S]/g, '*');\n  }\n  return value;\n}\nconst MEDIA_SELECTORS = 'img,image,svg,video,object,picture,embed,map,audio,link[rel=\"icon\"],link[rel=\"apple-touch-icon\"]';\nconst DEFAULT_NETWORK_HEADERS = ['content-length', 'content-type', 'accept'];\nlet _initialized = false;\n\n/**\n * Sentry integration for [Session Replay](https://sentry.io/for/session-replay/).\n *\n * See the [Replay documentation](https://docs.sentry.io/platforms/javascript/guides/session-replay/) for more information.\n *\n * @example\n *\n * ```\n * Sentry.init({\n *   dsn: '__DSN__',\n *   integrations: [Sentry.replayIntegration()],\n * });\n * ```\n */\nconst replayIntegration = options => {\n  return new Replay(options);\n};\n\n/**\n * Replay integration\n */\nclass Replay {\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n\n  /**\n   * Initial options passed to the replay integration, merged with default values.\n   * Note: `sessionSampleRate` and `errorSampleRate` are not required here, as they\n   * can only be finally set when setupOnce() is called.\n   *\n   * @private\n   */\n\n  constructor({\n    flushMinDelay = DEFAULT_FLUSH_MIN_DELAY,\n    flushMaxDelay = DEFAULT_FLUSH_MAX_DELAY,\n    minReplayDuration = MIN_REPLAY_DURATION,\n    maxReplayDuration = MAX_REPLAY_DURATION,\n    stickySession = true,\n    useCompression = true,\n    workerUrl,\n    _experiments = {},\n    maskAllText = true,\n    maskAllInputs = true,\n    blockAllMedia = true,\n    mutationBreadcrumbLimit = 750,\n    mutationLimit = 10000,\n    slowClickTimeout = 7000,\n    slowClickIgnoreSelectors = [],\n    networkDetailAllowUrls = [],\n    networkDetailDenyUrls = [],\n    networkCaptureBodies = true,\n    networkRequestHeaders = [],\n    networkResponseHeaders = [],\n    mask = [],\n    maskAttributes = ['title', 'placeholder'],\n    unmask = [],\n    block = [],\n    unblock = [],\n    ignore = [],\n    maskFn,\n    beforeAddRecordingEvent,\n    beforeErrorSampling,\n    onError\n  } = {}) {\n    this.name = 'Replay';\n    const privacyOptions = getPrivacyOptions({\n      mask,\n      unmask,\n      block,\n      unblock,\n      ignore\n    });\n    this._recordingOptions = {\n      maskAllInputs,\n      maskAllText,\n      maskInputOptions: {\n        password: true\n      },\n      maskTextFn: maskFn,\n      maskInputFn: maskFn,\n      maskAttributeFn: (key, value, el) => maskAttribute({\n        maskAttributes,\n        maskAllText,\n        privacyOptions,\n        key,\n        value,\n        el\n      }),\n      ...privacyOptions,\n      // Our defaults\n      slimDOMOptions: 'all',\n      inlineStylesheet: true,\n      // Disable inline images as it will increase segment/replay size\n      inlineImages: false,\n      // collect fonts, but be aware that `sentry.io` needs to be an allowed\n      // origin for playback\n      collectFonts: true,\n      errorHandler: err => {\n        try {\n          err.__rrweb__ = true;\n        } catch (error) {\n          // ignore errors here\n          // this can happen if the error is frozen or does not allow mutation for other reasons\n        }\n      },\n      // experimental support for recording iframes from different origins\n      recordCrossOriginIframes: Boolean(_experiments.recordCrossOriginIframes)\n    };\n    this._initialOptions = {\n      flushMinDelay,\n      flushMaxDelay,\n      minReplayDuration: Math.min(minReplayDuration, MIN_REPLAY_DURATION_LIMIT),\n      maxReplayDuration: Math.min(maxReplayDuration, MAX_REPLAY_DURATION),\n      stickySession,\n      useCompression,\n      workerUrl,\n      blockAllMedia,\n      maskAllInputs,\n      maskAllText,\n      mutationBreadcrumbLimit,\n      mutationLimit,\n      slowClickTimeout,\n      slowClickIgnoreSelectors,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders: _getMergedNetworkHeaders(networkRequestHeaders),\n      networkResponseHeaders: _getMergedNetworkHeaders(networkResponseHeaders),\n      beforeAddRecordingEvent,\n      beforeErrorSampling,\n      onError,\n      _experiments\n    };\n    if (this._initialOptions.blockAllMedia) {\n      // `blockAllMedia` is a more user friendly option to configure blocking\n      // embedded media elements\n      this._recordingOptions.blockSelector = !this._recordingOptions.blockSelector ? MEDIA_SELECTORS : `${this._recordingOptions.blockSelector},${MEDIA_SELECTORS}`;\n    }\n    if (this._isInitialized && isBrowser()) {\n      throw new Error('Multiple Sentry Session Replay instances are not supported');\n    }\n    this._isInitialized = true;\n  }\n\n  /** If replay has already been initialized */\n  get _isInitialized() {\n    return _initialized;\n  }\n\n  /** Update _isInitialized */\n  set _isInitialized(value) {\n    _initialized = value;\n  }\n\n  /**\n   * Setup and initialize replay container\n   */\n  afterAllSetup(client) {\n    if (!isBrowser() || this._replay) {\n      return;\n    }\n    this._setup(client);\n    this._initialize(client);\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will log a message if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * PerformanceObserver, Recording, Sentry SDK, etc)\n   */\n  start() {\n    if (!this._replay) {\n      return;\n    }\n    this._replay.start();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, until an error occurs.\n   */\n  startBuffering() {\n    if (!this._replay) {\n      return;\n    }\n    this._replay.startBuffering();\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n  stop() {\n    if (!this._replay) {\n      return Promise.resolve();\n    }\n    return this._replay.stop({\n      forceFlush: this._replay.recordingMode === 'session'\n    });\n  }\n\n  /**\n   * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n   * If replay is not enabled, a new session replay is started.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a \"session\"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n  flush(options) {\n    if (!this._replay) {\n      return Promise.resolve();\n    }\n\n    // assuming a session should be recorded in this case\n    if (!this._replay.isEnabled()) {\n      this._replay.start();\n      return Promise.resolve();\n    }\n    return this._replay.sendBufferedReplayOrFlush(options);\n  }\n\n  /**\n   * Get the current session ID.\n   */\n  getReplayId() {\n    if (!this._replay?.isEnabled()) {\n      return;\n    }\n    return this._replay.getSessionId();\n  }\n\n  /**\n   * Get the current recording mode. This can be either `session` or `buffer`.\n   *\n   * `session`: Recording the whole session, sending it continuously\n   * `buffer`: Always keeping the last 60s of recording, requires:\n   *   - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n   *   - or calling `flush()` to send the replay\n   */\n  getRecordingMode() {\n    if (!this._replay?.isEnabled()) {\n      return;\n    }\n    return this._replay.recordingMode;\n  }\n\n  /**\n   * Initializes replay.\n   */\n  _initialize(client) {\n    if (!this._replay) {\n      return;\n    }\n    this._maybeLoadFromReplayCanvasIntegration(client);\n    this._replay.initializeSampling();\n  }\n\n  /** Setup the integration. */\n  _setup(client) {\n    // Client is not available in constructor, so we need to wait until setupOnce\n    const finalOptions = loadReplayOptionsFromClient(this._initialOptions, client);\n    this._replay = new ReplayContainer({\n      options: finalOptions,\n      recordingOptions: this._recordingOptions\n    });\n  }\n\n  /** Get canvas options from ReplayCanvas integration, if it is also added. */\n  _maybeLoadFromReplayCanvasIntegration(client) {\n    // To save bundle size, we skip checking for stuff here\n    // and instead just try-catch everything - as generally this should all be defined\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    try {\n      const canvasIntegration = client.getIntegrationByName('ReplayCanvas');\n      if (!canvasIntegration) {\n        return;\n      }\n      this._replay['_canvas'] = canvasIntegration.getOptions();\n    } catch {\n      // ignore errors here\n    }\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n  }\n}\n\n/** Parse Replay-related options from SDK options */\nfunction loadReplayOptionsFromClient(initialOptions, client) {\n  const opt = client.getOptions();\n  const finalOptions = {\n    sessionSampleRate: 0,\n    errorSampleRate: 0,\n    ...initialOptions\n  };\n  const replaysSessionSampleRate = parseSampleRate(opt.replaysSessionSampleRate);\n  const replaysOnErrorSampleRate = parseSampleRate(opt.replaysOnErrorSampleRate);\n  if (replaysSessionSampleRate == null && replaysOnErrorSampleRate == null) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.');\n    });\n  }\n  if (replaysSessionSampleRate != null) {\n    finalOptions.sessionSampleRate = replaysSessionSampleRate;\n  }\n  if (replaysOnErrorSampleRate != null) {\n    finalOptions.errorSampleRate = replaysOnErrorSampleRate;\n  }\n  return finalOptions;\n}\nfunction _getMergedNetworkHeaders(headers) {\n  return [...DEFAULT_NETWORK_HEADERS, ...headers.map(header => header.toLowerCase())];\n}\n\n/**\n * This is a small utility to get a type-safe instance of the Replay integration.\n */\nfunction getReplay() {\n  const client = getClient();\n  return client?.getIntegrationByName('Replay');\n}\nexport { getReplay, replayIntegration };","map":{"version":3,"names":["WINDOW","GLOBAL_OBJ","REPLAY_SESSION_KEY","REPLAY_EVENT_NAME","UNABLE_TO_SEND_REPLAY","SESSION_IDLE_PAUSE_DURATION","SESSION_IDLE_EXPIRE_DURATION","DEFAULT_FLUSH_MIN_DELAY","DEFAULT_FLUSH_MAX_DELAY","BUFFER_CHECKOUT_TIME","RETRY_BASE_INTERVAL","RETRY_MAX_COUNT","NETWORK_BODY_MAX_SIZE","CONSOLE_ARG_MAX_SIZE","SLOW_CLICK_THRESHOLD","SLOW_CLICK_SCROLL_TIMEOUT","REPLAY_MAX_EVENT_BUFFER_SIZE","MIN_REPLAY_DURATION","MIN_REPLAY_DURATION_LIMIT","MAX_REPLAY_DURATION","__defProp$1","Object","defineProperty","__defNormalProp$1","obj","key","value","enumerable","configurable","writable","__publicField$1","NodeType$2","NodeType2","isElement$1","isElement","n2","nodeType","ELEMENT_NODE","isShadowRoot","host","Boolean","shadowRoot","isNativeShadowDom","prototype","toString","call","fixBrowserCompatibilityIssuesInCSS","cssText","includes","replace","escapeImportStatement","rule","split","length","statement","JSON","stringify","href","layerName","push","supportsText","media","mediaText","join","stringifyStylesheet","s2","rules2","rules","cssRules","Array","from","stringifyRule","error","fixAllCssProperty","styles","i2","style","styleDeclaration","attribute","isImportant","getPropertyPriority","getPropertyValue","selectorText","importStringified","isCSSImportRule","styleSheet","isCSSStyleRule","needsSafariColonFix","needsAllFix","fixSafariColons","cssStringified","regex","Mirror","constructor","Map","WeakMap","getId","id","getMeta","getNode","idNodeMap","get","getIds","keys","nodeMetaMap","removeNodeFromMap","delete","childNodes","forEach","childNode","has","hasNode","node","add","meta","set","oldNode","reset","createMirror$2","shouldMaskInput","maskInputOptions","tagName","type","toLowerCase","maskInputValue","isMasked","element","maskInputFn","text","repeat","str","toUpperCase","ORIGINAL_ATTRIBUTE_NAME","is2DCanvasBlank","canvas","ctx","getContext","chunkSize","x","width","y","height","getImageData","originalGetImageData","pixelBuffer","Uint32Array","Math","min","data","buffer","some","pixel","getInputType","hasAttribute","getInputValue","el","getAttribute","extractFileExtension","path","baseURL","url","URL","window","location","err","match","pathname","cachedImplementations$1","getImplementation$1","name","cached","document2","document","impl","createElement","sandbox","hidden","head","appendChild","contentWindow","removeChild","e2","bind","setTimeout$2","rest","clearTimeout$1","getIframeContentDocument","iframe","contentDocument","_id","tagNameRegex","RegExp","IGNORED_NODE","genId","getValidTagName$1","HTMLFormElement","processedTagName","test","extractOrigin","origin","indexOf","slice","canvasService","canvasCtx","URL_IN_CSS_REF","URL_PROTOCOL_MATCH","URL_WWW_MATCH","DATA_URI","absoluteToStylesheet","quote1","path1","quote2","path2","path3","filePath","maybeQuote","stack","parts","pop","part","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","getAbsoluteSrcsetString","doc","attributeValue","trim","pos","collectCharacters","regEx","chars2","exec","substring","output","absoluteToDoc","descriptorsStr","inParens","c2","charAt","cachedDocument","getHref","isSVGElement","ownerSVGElement","customHref","a2","startsWith","setAttribute","transformAttribute","maskAttributeFn","ignoreAttribute","_value","_isBlockedElement","blockClass","blockSelector","unblockSelector","matches","classList","contains","eIndex","className","elementClassMatchesRegex","distanceToMatch","matchPredicate","limit","Infinity","distance","parentNode","createMatchPredicate","selector","needMaskingText","maskTextClass","maskTextSelector","unmaskTextClass","unmaskTextSelector","maskAllText","parentElement","autocomplete","disallowedAutocompleteValues","maskDistance","unmaskDistance","onceIframeLoaded","iframeEl","listener","iframeLoadTimeout","win","fired","readyState","timer","addEventListener","blankUrl","src","onceStylesheetLoaded","link","styleSheetLoadTimeout","styleSheetLoaded","sheet","serializeNode","options","mirror","mirror2","inlineStylesheet","maskTextFn","dataURLOptions","inlineImages","recordCanvas","keepIframeSrcFn","newlyAddedElement","rootId","getRootId","DOCUMENT_NODE","compatMode","Document","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","serializeElementNode","TEXT_NODE","serializeTextNode","CDATA_SECTION_NODE","CDATA","textContent","COMMENT_NODE","Comment","docId","parentTagName","isStyle","isScript","isTextarea","nextSibling","previousSibling","console","warn","forceMask","textarea","isInputMasked","Text","needBlock","attributes2","len","attributes","attr","stylesheet","styleSheets","find","rel","crossorigin","_cssText","innerText","checked","selected","__context","rr_dataURL","toDataURL","quality","canvasDataURL","blankCanvas","blankCanvasDataURL","image","imageSrc","currentSrc","priorCrossOrigin","crossOrigin","recordInlineImage","removeEventListener","naturalWidth","naturalHeight","drawImage","complete","removeAttribute","rr_mediaState","paused","rr_mediaCurrentTime","currentTime","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","getBoundingClientRect","class","rr_width","rr_height","rr_src","isCustomElement","customElements","Element","isSVG","isCustom","lowerIfExists","maybeAttr","slimDOMExcluded","sn","slimDOMOptions","comment","script","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","serializeNodeWithId","skipChild","onSerialize","onIframeLoad","onStylesheetLoad","stylesheetLoadTimeout","preserveWhiteSpace","_serializedNode","serializedNode2","assign","recordChild","isShadowHost","headWhitespace","bypassOptions","childN","serializedChildNode","isShadow","iframeDoc","serializedIframeNode","serializedLinkNode","snapshot","maskAllInputs","slimDOM","color","date","email","month","number","range","search","tel","time","week","select","on","fn","target","capture","passive","DEPARTED_MIRROR_ACCESS_WARNING","_mirror","map","Proxy","Reflect","prop","receiver","throttle$1","throttle","func","wait","timeout","previous","args","now","Date","leading","remaining","context","clearTimeout$2","apply","trailing","setTimeout$1","hookSetter","d","isRevoked","original","getOwnPropertyDescriptor","patch","source","replacement","wrapped","defineProperties","__rrweb_original__","nowTimestamp","getTime","getWindowScroll","left","scrollingElement","pageXOffset","documentElement","body","top","pageYOffset","getWindowHeight","innerHeight","clientHeight","getWindowWidth","innerWidth","clientWidth","closestElementOfNode","isBlocked","checkAncestors","blockedPredicate","isUnblocked","blockDistance","unblockDistance","isSerialized","isIgnored","isAncestorRemoved","legacy_isTouchEvent","event","changedTouches","polyfill$1","NodeList","DOMTokenList","Node","TypeError","isSerializedIframe","nodeName","isSerializedStylesheet","hasShadowRoot","StyleSheetMirror","styleIDMap","idStyleMap","newId","getStyle","generateId","getShadowHost","shadowHost","getRootNode","DOCUMENT_FRAGMENT_NODE","getRootShadowHost","rootShadowHost","shadowHostInDom","ownerDocument","inDom","cachedImplementations","getImplementation","onRequestAnimationFrame","clearTimeout","EventType","EventType2","IncrementalSource","IncrementalSource2","MouseInteractions","MouseInteractions2","PointerTypes","PointerTypes2","MediaInteractions","MediaInteractions2","getIFrameContentDocument","getIFrameContentWindow","isNodeInLinkedList","DoubleLinkedList","tail","position","Error","current","index","next","addNode","__ln","removeNode","moveKey","parentId","MutationBuffer","frozen","locked","texts","attributeMap","removes","mapRemoves","movedMap","addedSet","Set","movedSet","droppedSet","processMutations","mutations","processMutation","emit","adds","addedIds","addList","getNextId","ns","nextId","pushAdd","currentN","iframeManager","addIframe","stylesheetManager","trackLinkElement","shadowDomManager","addShadowRoot","childSn","attachIframe","canvasManager","addWindow","observeAttachShadow","attachLinkElement","shift","isParentRemoved","isAncestorInSet","candidate","tailNode","_node","unhandledNode","parentId2","payload","filter","diffAsStr","styleDiff","unchangedAsStr","_unchangedStyles","mutationCb","m","oldValue","attributeName","item","unattachedDoc","implementation","createHTMLDocument","old","pname","newValue","newPriority","addedNodes","genAdds","removedNodes","nodeId","deepDelete","processedNodeManager","inOtherBuffer","targetId","init","freeze","unfreeze","isFrozen","lock","unlock","addsSet","_isParentRemoved","r2","size","_isAncestorInSet","errorHandler","registerErrorHandler","handler","unregisterErrorHandler","callbackWrapper","cb","rrwebWrapped","mutationBuffers","getEventTarget","composedPath","initMutationObserver","rootEl","mutationBuffer","mutationObserverCtor","MutationObserver","__rrMutationObserver","angularZoneSymbol","Zone","__symbol__","observer","onMutation","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","initMoveObserver","mousemoveCb","sampling","mousemove","threshold","callbackThreshold","mousemoveCallback","positions","timeBaseline","wrappedCb","totalOffset","p","timeOffset","updatePosition","evt","clientX","clientY","DragEvent","Drag","MouseEvent","MouseMove","TouchMove","handlers","h","initMouseInteractionObserver","mouseInteractionCb","mouseInteraction","disableMap","currentPointerType","getHandler","eventKey","pointerType","thisEventKey","Mouse","Touch","Pen","MouseDown","MouseUp","Click","Number","isNaN","endsWith","eventName","PointerEvent","TouchStart","TouchEnd","initScrollObserver","scrollCb","defaultView","scrollLeftTop","scroll","initViewportResizeObserver","viewportResizeCb","lastH","lastW","updateDimension","INPUT_TAGS","lastInputValueMap","initInputObserver","inputCb","ignoreClass","ignoreSelector","userTriggeredOnInput","eventHandler","userTriggered","isTrusted","isChecked","cbWithDedup","querySelectorAll","el2","text2","v2","lastInputValue","events","input","currentWindow","propertyDescriptor","HTMLInputElement","hookProperties","HTMLSelectElement","HTMLTextAreaElement","HTMLOptionElement","getNestedCSSRulePositions","recurse","childRule","hasNestedCSSRule","parentRule","CSSGroupingRule","CSSMediaRule","CSSSupportsRule","CSSConditionRule","unshift","parentStyleSheet","getIdAndStyleId","styleMirror","styleId","ownerNode","initStyleSheetObserver","styleSheetRuleCb","CSSStyleSheet","insertRule","thisArg","argumentsList","deleteRule","replaceSync","supportedNestedCSSRuleTypes","canMonkeyPatchNestedCSSRule","unmodifiedFunctions","entries","typeKey","initAdoptedStyleSheetObserver","hostId","patchTarget","ShadowRoot","originalPropertyDescriptor","sheets","result","adoptStyleSheets","initStyleDeclarationObserver","styleDeclarationCb","ignoreCSSAttributes","setProperty","CSSStyleDeclaration","priority","removeProperty","remove","initMediaInteractionObserver","mediaInteractionCb","volume","muted","playbackRate","Play","Pause","Seeked","VolumeChange","RateChange","initFontObserver","fontCb","fontMap","originalFontFace","FontFace","FontFace2","family","descriptors","fontFace","fontSource","Uint8Array","restoreHandler","fonts","initSelectionObserver","param","selectionCb","collapsed","updateSelection","selection","getSelection","isCollapsed","ranges","count","rangeCount","getRangeAt","startContainer","startOffset","endContainer","endOffset","blocked","start","end","initCustomElementObserver","customElementCb","define","initObservers","o2","_hooks","mutationObserver","recordDOM","mousemoveHandler","mouseInteractionHandler","scrollHandler","viewportResizeHandler","inputHandler","mediaInteractionHandler","styleSheetObserver","adoptedStyleSheetObserver","styleDeclarationObserver","fontObserver","collectFonts","selectionObserver","customElementObserver","pluginHandlers","plugin","plugins","callback","b","disconnect","CrossOriginIframeMirror","generateIdFn","iframeIdToRemoteIdMap","iframeRemoteIdToIdMap","remoteId","idToRemoteMap","remoteToIdMap","idToRemoteIdMap","getIdToRemoteIdMap","remoteIdToIdMap","getRemoteIdToIdMap","getRemoteId","getRemoteIds","ids","IframeManagerNoop","crossOriginIframeMirror","crossOriginIframeRootIdMap","addLoadListener","IframeManager","iframes","crossOriginIframeMap","wrappedEmit","recordCrossOriginIframes","crossOriginIframeStyleMirror","handleMessage","loadListener","isAttachIframe","adoptedStyleSheets","message","crossOriginMessageEvent","iframeSourceWindow","transformedEvent","transformCrossOriginEvent","isCheckout","FullSnapshot","replaceIdOnNode","patchRootIdOnNode","timestamp","IncrementalSnapshot","Mutation","Meta","Load","DomContentLoaded","Plugin","Custom","replaceIds","ViewportResize","MediaInteraction","MouseInteraction","Scroll","CanvasMutation","Input","StyleSheetRule","StyleDeclaration","replaceStyleIds","Font","Selection","AdoptedStyleSheet","iframeMirror","isArray","child","ShadowDomManagerNoop","ShadowDomManager","shadowDoms","WeakSet","restoreHandlers","patchAttachShadow","iframeElement","iframeWindow","manager","option","resetShadowRoots","chars","lookup","i$1","charCodeAt","CanvasManagerNoop","StylesheetManager","trackedLinkElements","adoptedStyleSheetCb","linkEl","trackStylesheetInLinkElement","adoptedStyleSheetData","styleIds","CSSRule","_linkEl","ProcessedNodeManager","nodeMap","active","thisBuffer","buffers","destroy","_takeFullSnapshot","cleanFrame","debug","record","checkoutEveryNms","checkoutEveryNth","_maskInputOptions","_slimDOMOptions","maxCanvasSize","packFn","mousemoveWait","recordAfter","errorHandler2","getCanvasManager","inEmittingFrame","parent","passEmitsToParent","radio","checkbox","lastFullSnapshotEvent","incrementalSnapshotCount","eventProcessor","buf","postMessage","exceedCount","exceedTime","takeFullSnapshot2","wrappedMutationEmit","wrappedScrollEmit","wrappedCanvasMutationEmit","wrappedAdoptedStyleSheetEmit","__RRWEB_EXCLUDE_IFRAME__","getMirror","nodeMirror","_getCanvasManager","__RRWEB_EXCLUDE_SHADOW_DOM__","initialOffset","canvasMutationCb","CustomElement","takeFullSnapshot","getCanvasManagerFn","n","t2","NotStarted","Running","Stopped","ReplayEventTypeIncrementalSnapshot","ReplayEventTypeCustom","timestampToMs","isMs","timestampToS","addBreadcrumbEvent","replay","breadcrumb","category","triggerUserActivity","checkAndHandleExpiredSession","addUpdate","throttledAddEvent","tag","normalize","INTERACTIVE_SELECTOR","getClosestInteractive","closestInteractive","closest","getClickTargetNode","getTargetNode","isEventWithTarget","onWindowOpen","monkeyPatchWindowOpen","splice","fill","originalWindowOpen","e","IncrementalMutationSources","handleClick","clickDetector","clickBreadcrumb","ClickDetector","slowClickConfig","_addBreadcrumbEvent","_lastMutation","_lastScroll","_clicks","_timeout","_threshold","_scrollTimeout","scrollTimeout","_replay","_ignoreSelector","addListeners","cleanupWindowOpen","nowInSeconds","_teardown","removeListeners","_checkClickTimeout","ignoreElement","isClickBreadcrumb","newClick","clickCount","click","abs","_scheduleCheckClicks","registerMutation","registerScroll","registerClick","_handleMultiClick","_getClicks","_checkClicks","timedOutClicks","mutationAfter","undefined","scrollAfter","_generateBreadcrumbs","hadScroll","hadMutation","isSlowClick","timeAfterClickMs","endReason","route","getCurrentRoute","metric","setTimeout$3","SLOW_CLICK_TAGS","updateClickDetectorForRecordingEvent","isIncrementalEvent","isIncrementalMouseInteraction","HTMLElement","createBreadcrumb","NodeType","ATTRIBUTES_TO_RECORD","getAttributesToRecord","normalizedKey","handleDomListener","handlerData","isEnabled","handleDom","isClick","altKey","metaKey","ctrlKey","shiftKey","getBaseDomBreadcrumb","getDomTarget","htmlTreeAsString","maxStringLength","handleKeyboardEvent","updateUserActivity","getKeyboardBreadcrumb","isInputElement","hasModifierKey","isCharacterKey","baseBreadcrumb","isContentEditable","ENTRY_TYPES","resource","createResourceEntry","paint","createPaintEntry","navigation","createNavigationEntry","webVitalHandler","getter","replayPerformanceEntries","createPerformanceEntries","createPerformanceEntry","entry","entryType","getAbsoluteTime","browserPerformanceTimeOrigin","performance","timeOrigin","duration","startTime","decodedBodySize","domComplete","encodedBodySize","domContentLoadedEventStart","domContentLoadedEventEnd","domInteractive","loadEventStart","loadEventEnd","redirectCount","transferSize","initiatorType","responseEnd","responseStatus","statusCode","getLargestContentfulPaint","lastEntry","getWebVital","isLayoutShift","sources","getCumulativeLayoutShift","layoutShifts","nodes","nodeIds","getFirstInputDelay","getInteractionToNextPaint","attributions","rating","setupPerformanceObserver","addPerformanceEntry","performanceEntries","onEntries","clearCallbacks","addPerformanceInstrumentationHandler","addLcpInstrumentationHandler","addClsInstrumentationHandler","addFidInstrumentationHandler","addInpInstrumentationHandler","clearCallback","DEBUG_BUILD","__SENTRY_DEBUG__","r","Blob","createObjectURL","CONSOLE_LEVELS","PREFIX","_addBreadcrumb","level","addBreadcrumb","logger","makeReplayLogger","_capture","_trace","_logger","exception","infoTick","setConfig","opts","captureExceptions","traceInternals","logger$1","severityLevelFromString","captureException","info","setTimeout","EventBufferSizeExceededError","EventBufferArray","_totalSize","hasCheckout","waitForCheckout","hasEvents","addEvent","eventSize","finish","Promise","resolve","eventsRet","clear","getEarliestTimestamp","sort","WorkerHandler","worker","_worker","ensureReady","_ensureReadyPromise","reject","success","once","terminate","method","arg","_getAndIncrementId","response","EventBufferCompressionWorker","_earliestTimestamp","_sendEventToWorker","_finishRequest","then","EventBufferProxy","_fallback","_compression","_used","_ensureWorkerIsLoadedPromise","_ensureWorkerIsLoaded","ensureWorkerIsLoaded","_switchToCompressionWorker","addEventPromises","all","createEventBuffer","useCompression","workerUrl","customWorkerUrl","Worker","_loadWorker","_getWorkerUrl","__SENTRY_EXCLUDE_REPLAY_WORKER__","hasSessionStorage","sessionStorage","clearSession","deleteSession","session","removeItem","isSampled","sampleRate","random","makeSession","uuid4","started","lastActivity","segmentId","sampled","previousSessionId","saveSession","setItem","getSessionSampleType","sessionSampleRate","allowBuffering","createSession","stickySession","fetchSession","sessionStringFromStorage","getItem","sessionObj","parse","isExpired","initialTime","expiry","targetTime","isSessionExpired","maxReplayDuration","sessionIdleExpire","shouldRefreshSession","loadOrCreateSession","sessionOptions","existingSession","isCustomEvent","addEventSync","shouldAddEvent","_addEvent","eventBuffer","isBufferMode","recordingMode","replayOptions","getOptions","eventAfterPossibleCallback","maybeApplyCallback","beforeAddRecordingEvent","isExceeded","reason","handleException","stop","client","getClient","recordDroppedEvent","isPaused","timestampInMs","timeouts","sessionIdlePause","initialTimestamp","isErrorEvent","isTransactionEvent","isReplayEvent","isFeedbackEvent","handleAfterSendEvent","sendResponse","handleTransactionEvent","handleErrorEvent","replayContext","contexts","trace","trace_id","traceIds","event_id","errorIds","tags","replayId","beforeErrorSampling","sendBufferedReplayOrFlush","handleBeforeSendEvent","handleHydrationError","exceptionValue","values","getLocationHref","handleBreadcrumbs","beforeAddBreadcrumb","isBreadcrumbWithCategory","normalizeBreadcrumb","normalizeConsoleBreadcrumb","arguments","isTruncated","normalizedArgs","normalizedArg","stringified","_meta","warnings","isRrwebError","hint","originalException","__rrweb__","resetReplayIdOnDynamicSamplingContext","dsc","getCurrentScope","getPropagationContext","replay_id","activeSpan","getActiveSpan","getDynamicSamplingContextFromSpan","addFeedbackBreadcrumb","feedbackId","shouldSampleForBufferEvent","errorSampleRate","handleGlobalEventListener","breadcrumbs","isSessionActive","flush","feedback","getSessionId","_experiments","log","isErrorEventSampled","shouldTagReplayId","createPerformanceSpans","op","description","startTimestamp","endTimestamp","handleHistory","to","handleHistorySpanListener","urls","shouldFilterRequest","isSentryRequestUrl","addNetworkBreadcrumb","getBodySize","textEncoder","TextEncoder","encode","URLSearchParams","FormData","formDataStr","serializeFormData","ArrayBuffer","byteLength","parseContentLengthHeader","header","parseInt","mergeWarning","warning","headers","newMeta","existingWarnings","makeNetworkReplayBreadcrumb","request","buildSkippedNetworkRequestOrResponse","bodySize","buildNetworkRequestOrResponse","normalizedBody","normalizeNetworkBody","getAllowedHeaders","allowedHeaders","reduce","filteredHeaders","exceedsSizeLimit","isProbablyJson","_strIsProbablyJson","truncatedBody","jsonBody","first","last","urlMatches","fullUrl","getFullUrl","stringMatchesSomePattern","baseURI","fixedUrl","captureFetchBreadcrumbToReplay","_prepareFetchData","enrichFetchBreadcrumb","getFetchRequestArgBody","reqSize","resSize","request_body_size","response_body_size","status_code","requestBodySize","responseBodySize","captureDetails","networkDetailAllowUrls","networkDetailDenyUrls","_getRequestInfo","_getResponseInfo","networkCaptureBodies","networkRequestHeaders","getRequestHeaders","requestBody","bodyStr","getBodyString","networkResponseHeaders","getAllHeaders","bodyText","_parseFetchResponseBody","getResponseData","res","_tryCloneResponse","_tryGetResponseText","allHeaders","fetchArgs","getHeadersFromOptions","Headers","clone","_getResponseText","txt","finally","captureXhrBreadcrumbToReplay","_prepareXhrData","enrichXhrBreadcrumb","xhr","getResponseHeader","_getBodySize","responseType","xhrInfo","SENTRY_XHR_DATA_KEY","request_headers","getResponseHeaders","requestWarning","responseBody","responseWarning","_getXhrResponseBody","getAllResponseHeaders","acc","line","errors","responseText","_parseXhrResponse","outerHTML","handleNetworkBreadcrumbs","beforeAddNetworkBreadcrumb","_isXhrBreadcrumb","_isXhrHint","_isFetchBreadcrumb","_isFetchHint","addGlobalListeners","autoFlushOnFeedback","addClickKeypressInstrumentationHandler","addHistoryInstrumentationHandler","addEventProcessor","span","lastActiveSpan","feedbackEvent","includeReplay","addMemoryEntry","createMemoryEntry","memory","memoryEntry","jsHeapSizeLimit","totalJSHeapSize","usedJSHeapSize","debounce","callbackReturnValue","timerId","maxTimerId","maxWait","max","invokeFunc","cancelTimers","debounced","cancel","NAVIGATOR","navigator","getRecordingSamplingOptions","userAgent","maxTouchPoints","getHandleRecordingEmit","hadFirstEvent","_isCheckout","setInitialState","addSettingsEvent","earliestEvent","createOptionsEvent","shouldRecordCanvas","isRecordingCanvas","useCompressionOption","blockAllMedia","networkDetailHasUrls","networkRequestHasHeaders","networkResponseHasHeaders","createReplayEnvelope","replayEvent","recordingData","dsn","tunnel","createEnvelope","createEventEnvelopeHeaders","getSdkMetadataForEnvelopeHeader","prepareRecordingData","payloadWithSequence","replayHeaders","enc","sequence","prepareReplayEvent","scope","integrations","eventHint","preparedEvent","prepareEvent","getIsolationScope","platform","metadata","getSdkMetadata","version","sdk","sendReplayRequest","segment_id","eventContext","preparedRecordingData","transport","getTransport","getDsn","resolvedSyncPromise","baseEvent","replay_start_timestamp","error_ids","trace_ids","replay_type","sdkProcessingMetadata","envelope","send","cause","TransportStatusCodeError","rateLimits","updateRateLimits","isRateLimited","RateLimitError","sendReplay","replayData","retryConfig","interval","onError","setContext","_retryCount","THROTTLED","SKIPPED","maxCount","durationSeconds","counter","_cleanup","_getTotalCount","a","isThrottled","floor","wasThrottled","ReplayContainer","recordingOptions","_lastActivity","_isEnabled","_isPaused","_requiresManualStart","_hasInitializedCoreListeners","_context","initialUrl","_recordingOptions","_options","_debouncedFlush","_flush","flushMinDelay","flushMaxDelay","_throttledAddEvent","slowClickTimeout","slowClickIgnoreSelectors","experiments","_handleVisibilityChange","visibilityState","_doChangeToForegroundTasks","_doChangeToBackgroundTasks","_handleWindowBlur","_handleWindowFocus","_handleKeyboardEvent","_canvas","initializeSampling","requiresManualStart","_initializeSessionForSampling","_initializeRecording","_updateUserActivity","startBuffering","startRecording","canvasOptions","_stopRecording","continuousCheckout","_onMutationHandler","stopRecording","forceFlush","_removeListeners","force","pause","resume","_checkSession","continueRecording","flushImmediate","activityTime","hasStoppedRecording","_updateSessionActivity","_maybeSaveSession","cbResult","conditionalFlush","cancelFlush","urlPath","hash","_clearContext","lastRootSpan","getRootSpan","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","_addListeners","currentSession","_refreshSession","_performanceCleanupCallback","expired","_createCustomBreadcrumb","_addPerformanceEntries","concat","initialTimestampInSeconds","_updateInitialTimestampFromEventBuffer","_popEventContext","_runFlush","dropReason","tooShort","minReplayDuration","tooLong","_flushInProgress","_flushLock","mutationLimit","mutationBreadcrumbLimit","overMutationLimit","getOption","selectors","defaultSelectors","getPrivacyOptions","mask","unmask","block","unblock","ignore","defaultBlockedElements","maskSelector","unmaskSelector","maskAttribute","maskAttributes","privacyOptions","MEDIA_SELECTORS","DEFAULT_NETWORK_HEADERS","_initialized","replayIntegration","Replay","maskFn","password","_initialOptions","_getMergedNetworkHeaders","_isInitialized","isBrowser","afterAllSetup","_setup","_initialize","getReplayId","getRecordingMode","_maybeLoadFromReplayCanvasIntegration","finalOptions","loadReplayOptionsFromClient","canvasIntegration","getIntegrationByName","initialOptions","opt","replaysSessionSampleRate","parseSampleRate","replaysOnErrorSampleRate","consoleSandbox","getReplay"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\constants.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\node_modules\\@sentry-internal\\rrweb\\dist\\rrweb.js","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\types\\rrweb.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\timestamp.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\util\\addBreadcrumbEvent.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\util\\domUtils.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\util\\onWindowOpen.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\handleClick.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\createBreadcrumb.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\node_modules\\@sentry-internal\\rrweb-snapshot\\dist\\rrweb-snapshot.js","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\util\\getAttributesToRecord.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\handleDom.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\handleKeyboardEvent.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\createPerformanceEntries.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\performanceObserver.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\debug-build.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay-worker\\build\\esm\\worker.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay-worker\\build\\esm\\index.js","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\logger.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\eventBuffer\\error.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\eventBuffer\\EventBufferArray.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\eventBuffer\\WorkerHandler.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\eventBuffer\\EventBufferCompressionWorker.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\eventBuffer\\EventBufferProxy.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\eventBuffer\\index.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\hasSessionStorage.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\session\\clearSession.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\isSampled.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\session\\Session.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\session\\saveSession.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\session\\createSession.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\session\\fetchSession.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\isExpired.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\isSessionExpired.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\session\\shouldRefreshSession.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\session\\loadOrCreateSession.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\addEvent.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\eventUtils.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\handleAfterSendEvent.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\handleBeforeSendEvent.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\handleBreadcrumbs.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\isRrwebError.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\resetReplayIdOnDynamicSamplingContext.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\util\\addFeedbackBreadcrumb.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\util\\shouldSampleForBufferEvent.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\handleGlobalEvent.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\createPerformanceSpans.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\handleHistory.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\shouldFilterRequest.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\util\\addNetworkBreadcrumb.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\util\\networkUtils.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\util\\fetchUtils.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\util\\xhrUtils.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\coreHandlers\\handleNetworkBreadcrumbs.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\addGlobalListeners.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\addMemoryEntry.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\debounce.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\getRecordingSamplingOptions.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\handleRecordingEmit.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\createReplayEnvelope.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\prepareRecordingData.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\prepareReplayEvent.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\sendReplayRequest.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\sendReplay.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\throttle.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\replay.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\getPrivacyOptions.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\maskAttribute.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\integration.ts","C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\replay\\src\\util\\getReplay.ts"],"sourcesContent":["import { GLOBAL_OBJ } from '@sentry/core';\n\n// exporting a separate copy of `WINDOW` rather than exporting the one from `@sentry/browser`\n// prevents the browser package from being bundled in the CDN bundle, and avoids a\n// circular dependency between the browser and replay packages should `@sentry/browser` import\n// from `@sentry/replay` in the future\nexport const WINDOW = GLOBAL_OBJ as typeof GLOBAL_OBJ & Window;\n\nexport const REPLAY_SESSION_KEY = 'sentryReplaySession';\nexport const REPLAY_EVENT_NAME = 'replay_event';\nexport const RECORDING_EVENT_NAME = 'replay_recording';\nexport const UNABLE_TO_SEND_REPLAY = 'Unable to send Replay';\n\n// The idle limit for a session after which recording is paused.\nexport const SESSION_IDLE_PAUSE_DURATION = 300_000; // 5 minutes in ms\n\n// The idle limit for a session after which the session expires.\nexport const SESSION_IDLE_EXPIRE_DURATION = 900_000; // 15 minutes in ms\n\n/** Default flush delays */\nexport const DEFAULT_FLUSH_MIN_DELAY = 5_000;\n// XXX: Temp fix for our debounce logic where `maxWait` would never occur if it\n// was the same as `wait`\nexport const DEFAULT_FLUSH_MAX_DELAY = 5_500;\n\n/* How long to wait for error checkouts */\nexport const BUFFER_CHECKOUT_TIME = 60_000;\n\nexport const RETRY_BASE_INTERVAL = 5000;\nexport const RETRY_MAX_COUNT = 3;\n\n/* The max (uncompressed) size in bytes of a network body. Any body larger than this will be truncated. */\nexport const NETWORK_BODY_MAX_SIZE = 150_000;\n\n/* The max size of a single console arg that is captured. Any arg larger than this will be truncated. */\nexport const CONSOLE_ARG_MAX_SIZE = 5_000;\n\n/* Min. time to wait before we consider something a slow click. */\nexport const SLOW_CLICK_THRESHOLD = 3_000;\n/* For scroll actions after a click, we only look for a very short time period to detect programmatic scrolling. */\nexport const SLOW_CLICK_SCROLL_TIMEOUT = 300;\n\n/** When encountering a total segment size exceeding this size, stop the replay (as we cannot properly ingest it). */\nexport const REPLAY_MAX_EVENT_BUFFER_SIZE = 20_000_000; // ~20MB\n\n/** Replays must be min. 5s long before we send them. */\nexport const MIN_REPLAY_DURATION = 4_999;\n/* The max. allowed value that the minReplayDuration can be set to. */\nexport const MIN_REPLAY_DURATION_LIMIT = 15_000;\n\n/** The max. length of a replay. */\nexport const MAX_REPLAY_DURATION = 3_600_000; // 60 minutes in ms;\n\n/** Default attributes to be ignored when `maskAllText` is enabled */\nexport const DEFAULT_IGNORED_ATTRIBUTES = ['title', 'placeholder'];\n","var __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar NodeType$2 = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType$2 || {});\nfunction isElement(n2) {\n  return n2.nodeType === n2.ELEMENT_NODE;\n}\nfunction isShadowRoot(n2) {\n  const host = n2?.host;\n  return Boolean(host?.shadowRoot === n2);\n}\nfunction isNativeShadowDom(shadowRoot) {\n  return Object.prototype.toString.call(shadowRoot) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n  if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n    cssText = cssText.replace(\n      /\\sbackground-clip:\\s*text;/g,\n      \" -webkit-background-clip: text; background-clip: text;\"\n    );\n  }\n  return cssText;\n}\nfunction escapeImportStatement(rule) {\n  const { cssText } = rule;\n  if (cssText.split('\"').length < 3) return cssText;\n  const statement = [\"@import\", `url(${JSON.stringify(rule.href)})`];\n  if (rule.layerName === \"\") {\n    statement.push(`layer`);\n  } else if (rule.layerName) {\n    statement.push(`layer(${rule.layerName})`);\n  }\n  if (rule.supportsText) {\n    statement.push(`supports(${rule.supportsText})`);\n  }\n  if (rule.media.length) {\n    statement.push(rule.media.mediaText);\n  }\n  return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s2) {\n  try {\n    const rules2 = s2.rules || s2.cssRules;\n    return rules2 ? fixBrowserCompatibilityIssuesInCSS(\n      Array.from(rules2, stringifyRule).join(\"\")\n    ) : null;\n  } catch (error) {\n    return null;\n  }\n}\nfunction fixAllCssProperty(rule) {\n  let styles = \"\";\n  for (let i2 = 0; i2 < rule.style.length; i2++) {\n    const styleDeclaration = rule.style;\n    const attribute = styleDeclaration[i2];\n    const isImportant = styleDeclaration.getPropertyPriority(attribute);\n    styles += `${attribute}:${styleDeclaration.getPropertyValue(attribute)}${isImportant ? ` !important` : \"\"};`;\n  }\n  return `${rule.selectorText} { ${styles} }`;\n}\nfunction stringifyRule(rule) {\n  let importStringified;\n  if (isCSSImportRule(rule)) {\n    try {\n      importStringified = // for same-origin stylesheets,\n      // we can access the imported stylesheet rules directly\n      stringifyStylesheet(rule.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement\n      escapeImportStatement(rule);\n    } catch (error) {\n    }\n  } else if (isCSSStyleRule(rule)) {\n    let cssText = rule.cssText;\n    const needsSafariColonFix = rule.selectorText.includes(\":\");\n    const needsAllFix = typeof rule.style[\"all\"] === \"string\" && rule.style[\"all\"];\n    if (needsAllFix) {\n      cssText = fixAllCssProperty(rule);\n    }\n    if (needsSafariColonFix) {\n      cssText = fixSafariColons(cssText);\n    }\n    if (needsSafariColonFix || needsAllFix) {\n      return cssText;\n    }\n  }\n  return importStringified || rule.cssText;\n}\nfunction fixSafariColons(cssStringified) {\n  const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n  return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule) {\n  return \"styleSheet\" in rule;\n}\nfunction isCSSStyleRule(rule) {\n  return \"selectorText\" in rule;\n}\nclass Mirror {\n  constructor() {\n    __publicField$1(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField$1(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach(\n        (childNode) => this.removeNodeFromMap(childNode)\n      );\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n}\nfunction createMirror$2() {\n  return new Mirror();\n}\nfunction shouldMaskInput({\n  maskInputOptions,\n  tagName,\n  type\n}) {\n  if (tagName === \"OPTION\") {\n    tagName = \"SELECT\";\n  }\n  return Boolean(\n    maskInputOptions[tagName.toLowerCase()] || type && maskInputOptions[type] || type === \"password\" || // Default to \"text\" option for inputs without a \"type\" attribute defined\n    tagName === \"INPUT\" && !type && maskInputOptions[\"text\"]\n  );\n}\nfunction maskInputValue({\n  isMasked,\n  element,\n  value,\n  maskInputFn\n}) {\n  let text = value || \"\";\n  if (!isMasked) {\n    return text;\n  }\n  if (maskInputFn) {\n    text = maskInputFn(text, element);\n  }\n  return \"*\".repeat(text.length);\n}\nfunction toLowerCase(str) {\n  return str.toLowerCase();\n}\nfunction toUpperCase(str) {\n  return str.toUpperCase();\n}\nconst ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return true;\n  const chunkSize = 50;\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData;\n      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n      const pixelBuffer = new Uint32Array(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y)\n        ).data.buffer\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\nfunction isNodeMetaEqual(a2, b) {\n  if (!a2 || !b || a2.type !== b.type) return false;\n  if (a2.type === NodeType$2.Document)\n    return a2.compatMode === b.compatMode;\n  else if (a2.type === NodeType$2.DocumentType)\n    return a2.name === b.name && a2.publicId === b.publicId && a2.systemId === b.systemId;\n  else if (a2.type === NodeType$2.Comment || a2.type === NodeType$2.Text || a2.type === NodeType$2.CDATA)\n    return a2.textContent === b.textContent;\n  else if (a2.type === NodeType$2.Element)\n    return a2.tagName === b.tagName && JSON.stringify(a2.attributes) === JSON.stringify(b.attributes) && a2.isSVG === b.isSVG && a2.needBlock === b.needBlock;\n  return false;\n}\nfunction getInputType(element) {\n  const type = element.type;\n  return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    toLowerCase(type)\n  ) : null;\n}\nfunction getInputValue(el, tagName, type) {\n  if (tagName === \"INPUT\" && (type === \"radio\" || type === \"checkbox\")) {\n    return el.getAttribute(\"value\") || \"\";\n  }\n  return el.value;\n}\nfunction extractFileExtension(path, baseURL) {\n  let url;\n  try {\n    url = new URL(path, baseURL ?? window.location.href);\n  } catch (err) {\n    return null;\n  }\n  const regex = /\\.([0-9a-z]+)(?:$)/i;\n  const match = url.pathname.match(regex);\n  return match?.[1] ?? null;\n}\nconst cachedImplementations$1 = {};\nfunction getImplementation$1(name) {\n  const cached = cachedImplementations$1[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations$1[name] = impl.bind(\n    window\n  );\n}\nfunction setTimeout$2(...rest) {\n  return getImplementation$1(\"setTimeout\")(...rest);\n}\nfunction clearTimeout$1(...rest) {\n  return getImplementation$1(\"clearTimeout\")(...rest);\n}\nfunction getIframeContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {\n  }\n}\nlet _id = 1;\nconst tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nconst IGNORED_NODE = -2;\nfunction genId() {\n  return _id++;\n}\nfunction getValidTagName$1(element) {\n  if (element instanceof HTMLFormElement) {\n    return \"form\";\n  }\n  const processedTagName = toLowerCase(element.tagName);\n  if (tagNameRegex.test(processedTagName)) {\n    return \"div\";\n  }\n  return processedTagName;\n}\nfunction extractOrigin(url) {\n  let origin = \"\";\n  if (url.indexOf(\"//\") > -1) {\n    origin = url.split(\"/\").slice(0, 3).join(\"/\");\n  } else {\n    origin = url.split(\"/\")[0];\n  }\n  origin = origin.split(\"?\")[0];\n  return origin;\n}\nlet canvasService;\nlet canvasCtx;\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n  return (cssText || \"\").replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || \"\";\n      if (!filePath) {\n        return origin;\n      }\n      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === \"/\") {\n        return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\n      }\n      const stack = href.split(\"/\");\n      const parts = filePath.split(\"/\");\n      stack.pop();\n      for (const part of parts) {\n        if (part === \".\") {\n          continue;\n        } else if (part === \"..\") {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join(\"/\")}${maybeQuote})`;\n    }\n  );\n}\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n  if (attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  let pos = 0;\n  function collectCharacters(regEx) {\n    let chars2;\n    const match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars2 = match[0];\n      pos += chars2.length;\n      return chars2;\n    }\n    return \"\";\n  }\n  const output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === \",\") {\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      output.push(url);\n    } else {\n      let descriptorsStr = \"\";\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        const c2 = attributeValue.charAt(pos);\n        if (c2 === \"\") {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c2 === \",\") {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break;\n          } else if (c2 === \"(\") {\n            inParens = true;\n          }\n        } else {\n          if (c2 === \")\") {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c2;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(\", \");\n}\nconst cachedDocument = /* @__PURE__ */ new WeakMap();\nfunction absoluteToDoc(doc, attributeValue) {\n  if (!attributeValue || attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  return getHref(doc, attributeValue);\n}\nfunction isSVGElement(el) {\n  return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref(doc, customHref) {\n  let a2 = cachedDocument.get(doc);\n  if (!a2) {\n    a2 = doc.createElement(\"a\");\n    cachedDocument.set(doc, a2);\n  }\n  if (!customHref) {\n    customHref = \"\";\n  } else if (customHref.startsWith(\"blob:\") || customHref.startsWith(\"data:\")) {\n    return customHref;\n  }\n  a2.setAttribute(\"href\", customHref);\n  return a2.href;\n}\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn) {\n  if (!value) {\n    return value;\n  }\n  if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"srcset\") {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === \"style\") {\n    return absoluteToStylesheet(value, getHref(doc));\n  } else if (tagName === \"object\" && name === \"data\") {\n    return absoluteToDoc(doc, value);\n  }\n  if (typeof maskAttributeFn === \"function\") {\n    return maskAttributeFn(name, value, element);\n  }\n  return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n  return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\n  try {\n    if (unblockSelector && element.matches(unblockSelector)) {\n      return false;\n    }\n    if (typeof blockClass === \"string\") {\n      if (element.classList.contains(blockClass)) {\n        return true;\n      }\n    } else {\n      for (let eIndex = element.classList.length; eIndex--; ) {\n        const className = element.classList[eIndex];\n        if (blockClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (blockSelector) {\n      return element.matches(blockSelector);\n    }\n  } catch (e2) {\n  }\n  return false;\n}\nfunction elementClassMatchesRegex(el, regex) {\n  for (let eIndex = el.classList.length; eIndex--; ) {\n    const className = el.classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\n  if (!node) return -1;\n  if (node.nodeType !== node.ELEMENT_NODE) return -1;\n  if (distance > limit) return -1;\n  if (matchPredicate(node)) return distance;\n  return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\n}\nfunction createMatchPredicate(className, selector) {\n  return (node) => {\n    const el = node;\n    if (el === null) return false;\n    try {\n      if (className) {\n        if (typeof className === \"string\") {\n          if (el.matches(`.${className}`)) return true;\n        } else if (elementClassMatchesRegex(el, className)) {\n          return true;\n        }\n      }\n      if (selector && el.matches(selector)) return true;\n      return false;\n    } catch {\n      return false;\n    }\n  };\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    if (el === null) return false;\n    if (el.tagName === \"INPUT\") {\n      const autocomplete = el.getAttribute(\"autocomplete\");\n      const disallowedAutocompleteValues = [\n        \"current-password\",\n        \"new-password\",\n        \"cc-number\",\n        \"cc-exp\",\n        \"cc-exp-month\",\n        \"cc-exp-year\",\n        \"cc-csc\"\n      ];\n      if (disallowedAutocompleteValues.includes(autocomplete)) {\n        return true;\n      }\n    }\n    let maskDistance = -1;\n    let unmaskDistance = -1;\n    if (maskAllText) {\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector)\n      );\n      if (unmaskDistance < 0) {\n        return true;\n      }\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector),\n        unmaskDistance >= 0 ? unmaskDistance : Infinity\n      );\n    } else {\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector)\n      );\n      if (maskDistance < 0) {\n        return false;\n      }\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector),\n        maskDistance >= 0 ? maskDistance : Infinity\n      );\n    }\n    return maskDistance >= 0 ? unmaskDistance >= 0 ? maskDistance <= unmaskDistance : true : unmaskDistance >= 0 ? false : !!maskAllText;\n  } catch (e2) {\n  }\n  return !!maskAllText;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  let fired = false;\n  let readyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== \"complete\") {\n    const timer = setTimeout$2(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener(\"load\", () => {\n      clearTimeout$1(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  const blankUrl = \"about:blank\";\n  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n    setTimeout$2(listener, 0);\n    return iframeEl.addEventListener(\"load\", listener);\n  }\n  iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n  let fired = false;\n  let styleSheetLoaded;\n  try {\n    styleSheetLoaded = link.sheet;\n  } catch (error) {\n    return;\n  }\n  if (styleSheetLoaded) return;\n  const timer = setTimeout$2(() => {\n    if (!fired) {\n      listener();\n      fired = true;\n    }\n  }, styleSheetLoadTimeout);\n  link.addEventListener(\"load\", () => {\n    clearTimeout$1(timer);\n    fired = true;\n    listener();\n  });\n}\nfunction serializeNode(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskAttributeFn,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false\n  } = options;\n  const rootId = getRootId(doc, mirror2);\n  switch (n2.nodeType) {\n    case n2.DOCUMENT_NODE:\n      if (n2.compatMode !== \"CSS1Compat\") {\n        return {\n          type: NodeType$2.Document,\n          childNodes: [],\n          compatMode: n2.compatMode\n          // probably \"BackCompat\"\n        };\n      } else {\n        return {\n          type: NodeType$2.Document,\n          childNodes: []\n        };\n      }\n    case n2.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType$2.DocumentType,\n        name: n2.name,\n        publicId: n2.publicId,\n        systemId: n2.systemId,\n        rootId\n      };\n    case n2.ELEMENT_NODE:\n      return serializeElementNode(n2, {\n        doc,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        inlineStylesheet,\n        maskAttributeFn,\n        maskInputOptions,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement,\n        rootId,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector\n      });\n    case n2.TEXT_NODE:\n      return serializeTextNode(n2, {\n        doc,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        maskTextFn,\n        maskInputOptions,\n        maskInputFn,\n        rootId\n      });\n    case n2.CDATA_SECTION_NODE:\n      return {\n        type: NodeType$2.CDATA,\n        textContent: \"\",\n        rootId\n      };\n    case n2.COMMENT_NODE:\n      return {\n        type: NodeType$2.Comment,\n        textContent: n2.textContent || \"\",\n        rootId\n      };\n    default:\n      return false;\n  }\n}\nfunction getRootId(doc, mirror2) {\n  if (!mirror2.hasNode(doc)) return void 0;\n  const docId = mirror2.getId(doc);\n  return docId === 1 ? void 0 : docId;\n}\nfunction serializeTextNode(n2, options) {\n  const {\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    maskTextFn,\n    maskInputOptions,\n    maskInputFn,\n    rootId\n  } = options;\n  const parentTagName = n2.parentNode && n2.parentNode.tagName;\n  let textContent = n2.textContent;\n  const isStyle = parentTagName === \"STYLE\" ? true : void 0;\n  const isScript = parentTagName === \"SCRIPT\" ? true : void 0;\n  const isTextarea = parentTagName === \"TEXTAREA\" ? true : void 0;\n  if (isStyle && textContent) {\n    try {\n      if (n2.nextSibling || n2.previousSibling) {\n      } else if (n2.parentNode.sheet?.cssRules) {\n        textContent = stringifyStylesheet(\n          n2.parentNode.sheet\n        );\n      }\n    } catch (err) {\n      console.warn(\n        `Cannot get CSS styles from text's parentNode. Error: ${err}`,\n        n2\n      );\n    }\n    textContent = absoluteToStylesheet(textContent, getHref(options.doc));\n  }\n  if (isScript) {\n    textContent = \"SCRIPT_PLACEHOLDER\";\n  }\n  const forceMask = needMaskingText(\n    n2,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextClass,\n    unmaskTextSelector,\n    maskAllText\n  );\n  if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\n    textContent = maskTextFn ? maskTextFn(textContent, n2.parentElement) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\n    textContent = maskInputFn ? maskInputFn(textContent, n2.parentNode) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (parentTagName === \"OPTION\" && textContent) {\n    const isInputMasked = shouldMaskInput({\n      type: null,\n      tagName: parentTagName,\n      maskInputOptions\n    });\n    textContent = maskInputValue({\n      isMasked: needMaskingText(\n        n2,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        isInputMasked\n      ),\n      element: n2,\n      value: textContent,\n      maskInputFn\n    });\n  }\n  return {\n    type: NodeType$2.Text,\n    textContent: textContent || \"\",\n    isStyle,\n    rootId\n  };\n}\nfunction serializeElementNode(n2, options) {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    rootId,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector\n  } = options;\n  const needBlock = _isBlockedElement(\n    n2,\n    blockClass,\n    blockSelector,\n    unblockSelector\n  );\n  const tagName = getValidTagName$1(n2);\n  let attributes2 = {};\n  const len = n2.attributes.length;\n  for (let i2 = 0; i2 < len; i2++) {\n    const attr = n2.attributes[i2];\n    if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\n      attributes2[attr.name] = transformAttribute(\n        doc,\n        tagName,\n        toLowerCase(attr.name),\n        attr.value,\n        n2,\n        maskAttributeFn\n      );\n    }\n  }\n  if (tagName === \"link\" && inlineStylesheet) {\n    const stylesheet = Array.from(doc.styleSheets).find((s2) => {\n      return s2.href === n2.href;\n    });\n    let cssText = null;\n    if (stylesheet) {\n      cssText = stringifyStylesheet(stylesheet);\n    }\n    if (cssText) {\n      attributes2.rel = null;\n      attributes2.href = null;\n      attributes2.crossorigin = null;\n      attributes2._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n    }\n  }\n  if (tagName === \"style\" && n2.sheet && // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n  !(n2.innerText || n2.textContent || \"\").trim().length) {\n    const cssText = stringifyStylesheet(\n      n2.sheet\n    );\n    if (cssText) {\n      attributes2._cssText = absoluteToStylesheet(cssText, getHref(doc));\n    }\n  }\n  if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\" || tagName === \"option\") {\n    const el = n2;\n    const type = getInputType(el);\n    const value = getInputValue(el, toUpperCase(tagName), type);\n    const checked = el.checked;\n    if (type !== \"submit\" && type !== \"button\" && value) {\n      const forceMask = needMaskingText(\n        el,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        shouldMaskInput({\n          type,\n          tagName: toUpperCase(tagName),\n          maskInputOptions\n        })\n      );\n      attributes2.value = maskInputValue({\n        isMasked: forceMask,\n        element: el,\n        value,\n        maskInputFn\n      });\n    }\n    if (checked) {\n      attributes2.checked = checked;\n    }\n  }\n  if (tagName === \"option\") {\n    if (n2.selected && !maskInputOptions[\"select\"]) {\n      attributes2.selected = true;\n    } else {\n      delete attributes2.selected;\n    }\n  }\n  if (tagName === \"canvas\" && recordCanvas) {\n    if (n2.__context === \"2d\") {\n      if (!is2DCanvasBlank(n2)) {\n        attributes2.rr_dataURL = n2.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      }\n    } else if (!(\"__context\" in n2)) {\n      const canvasDataURL = n2.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      const blankCanvas = doc.createElement(\"canvas\");\n      blankCanvas.width = n2.width;\n      blankCanvas.height = n2.height;\n      const blankCanvasDataURL = blankCanvas.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      if (canvasDataURL !== blankCanvasDataURL) {\n        attributes2.rr_dataURL = canvasDataURL;\n      }\n    }\n  }\n  if (tagName === \"img\" && inlineImages) {\n    if (!canvasService) {\n      canvasService = doc.createElement(\"canvas\");\n      canvasCtx = canvasService.getContext(\"2d\");\n    }\n    const image = n2;\n    const imageSrc = image.currentSrc || image.getAttribute(\"src\") || \"<unknown-src>\";\n    const priorCrossOrigin = image.crossOrigin;\n    const recordInlineImage = () => {\n      image.removeEventListener(\"load\", recordInlineImage);\n      try {\n        canvasService.width = image.naturalWidth;\n        canvasService.height = image.naturalHeight;\n        canvasCtx.drawImage(image, 0, 0);\n        attributes2.rr_dataURL = canvasService.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      } catch (err) {\n        if (image.crossOrigin !== \"anonymous\") {\n          image.crossOrigin = \"anonymous\";\n          if (image.complete && image.naturalWidth !== 0)\n            recordInlineImage();\n          else image.addEventListener(\"load\", recordInlineImage);\n          return;\n        } else {\n          console.warn(\n            `Cannot inline img src=${imageSrc}! Error: ${err}`\n          );\n        }\n      }\n      if (image.crossOrigin === \"anonymous\") {\n        priorCrossOrigin ? attributes2.crossOrigin = priorCrossOrigin : image.removeAttribute(\"crossorigin\");\n      }\n    };\n    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n    else image.addEventListener(\"load\", recordInlineImage);\n  }\n  if (tagName === \"audio\" || tagName === \"video\") {\n    attributes2.rr_mediaState = n2.paused ? \"paused\" : \"played\";\n    attributes2.rr_mediaCurrentTime = n2.currentTime;\n  }\n  if (!newlyAddedElement) {\n    if (n2.scrollLeft) {\n      attributes2.rr_scrollLeft = n2.scrollLeft;\n    }\n    if (n2.scrollTop) {\n      attributes2.rr_scrollTop = n2.scrollTop;\n    }\n  }\n  if (needBlock) {\n    const { width, height } = n2.getBoundingClientRect();\n    attributes2 = {\n      class: attributes2.class,\n      rr_width: `${width}px`,\n      rr_height: `${height}px`\n    };\n  }\n  if (tagName === \"iframe\" && !keepIframeSrcFn(attributes2.src)) {\n    if (!needBlock && !getIframeContentDocument(n2)) {\n      attributes2.rr_src = attributes2.src;\n    }\n    delete attributes2.src;\n  }\n  let isCustomElement;\n  try {\n    if (customElements.get(tagName)) isCustomElement = true;\n  } catch (e2) {\n  }\n  return {\n    type: NodeType$2.Element,\n    tagName,\n    attributes: attributes2,\n    childNodes: [],\n    isSVG: isSVGElement(n2) || void 0,\n    needBlock,\n    rootId,\n    isCustom: isCustomElement\n  };\n}\nfunction lowerIfExists(maybeAttr) {\n  if (maybeAttr === void 0 || maybeAttr === null) {\n    return \"\";\n  } else {\n    return maybeAttr.toLowerCase();\n  }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n  if (slimDOMOptions.comment && sn.type === NodeType$2.Comment) {\n    return true;\n  } else if (sn.type === NodeType$2.Element) {\n    if (slimDOMOptions.script && // script tag\n    (sn.tagName === \"script\" || // (module)preload link\n    sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" || sn.attributes.rel === \"modulepreload\") || // prefetch link\n    sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n      return true;\n    } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(\n      /^msapplication-tile(image|color)$/\n    ) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n      return true;\n    } else if (sn.tagName === \"meta\") {\n      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n        return true;\n      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n      lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== void 0) {\n        return true;\n      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n        return true;\n      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction serializeNodeWithId(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5e3,\n    onStylesheetLoad,\n    stylesheetLoadTimeout = 5e3,\n    keepIframeSrcFn = () => false,\n    newlyAddedElement = false\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n2, {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    maskAllText,\n    unblockSelector,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement\n  });\n  if (!_serializedNode) {\n    console.warn(n2, \"not serialized\");\n    return null;\n  }\n  let id;\n  if (mirror2.hasNode(n2)) {\n    id = mirror2.getId(n2);\n  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$2.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode2 = Object.assign(_serializedNode, { id });\n  mirror2.add(n2, serializedNode2);\n  if (id === IGNORED_NODE) {\n    return null;\n  }\n  if (onSerialize) {\n    onSerialize(n2);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode2.type === NodeType$2.Element) {\n    recordChild = recordChild && !serializedNode2.needBlock;\n    delete serializedNode2.needBlock;\n    const shadowRoot = n2.shadowRoot;\n    if (shadowRoot && isNativeShadowDom(shadowRoot))\n      serializedNode2.isShadowHost = true;\n  }\n  if ((serializedNode2.type === NodeType$2.Document || serializedNode2.type === NodeType$2.Element) && recordChild) {\n    if (slimDOMOptions.headWhitespace && serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"head\") {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      mirror: mirror2,\n      blockClass,\n      blockSelector,\n      maskAllText,\n      unblockSelector,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      onStylesheetLoad,\n      stylesheetLoadTimeout,\n      keepIframeSrcFn\n    };\n    for (const childN of Array.from(n2.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode2.childNodes.push(serializedChildNode);\n      }\n    }\n    if (isElement(n2) && n2.shadowRoot) {\n      for (const childN of Array.from(n2.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          isNativeShadowDom(n2.shadowRoot) && (serializedChildNode.isShadow = true);\n          serializedNode2.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n  if (n2.parentNode && isShadowRoot(n2.parentNode) && isNativeShadowDom(n2.parentNode)) {\n    serializedNode2.isShadow = true;\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"iframe\" && !_isBlockedElement(\n    n2,\n    blockClass,\n    blockSelector,\n    unblockSelector\n  )) {\n    onceIframeLoaded(\n      n2,\n      () => {\n        const iframeDoc = getIframeContentDocument(n2);\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n          });\n          if (serializedIframeNode) {\n            onIframeLoad(\n              n2,\n              serializedIframeNode\n            );\n          }\n        }\n      },\n      iframeLoadTimeout\n    );\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"link\" && typeof serializedNode2.attributes.rel === \"string\" && (serializedNode2.attributes.rel === \"stylesheet\" || serializedNode2.attributes.rel === \"preload\" && typeof serializedNode2.attributes.href === \"string\" && extractFileExtension(serializedNode2.attributes.href) === \"css\")) {\n    onceStylesheetLoaded(\n      n2,\n      () => {\n        if (onStylesheetLoad) {\n          const serializedLinkNode = serializeNodeWithId(n2, {\n            doc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n          });\n          if (serializedLinkNode) {\n            onStylesheetLoad(\n              n2,\n              serializedLinkNode\n            );\n          }\n        }\n      },\n      stylesheetLoadTimeout\n    );\n  }\n  return serializedNode2;\n}\nfunction snapshot(n2, options) {\n  const {\n    mirror: mirror2 = new Mirror(),\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn = () => false\n  } = options || {};\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true\n  } : maskAllInputs === false ? {} : maskAllInputs;\n  const slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? (\n    // if true: set of sensible options that should not throw away any information\n    {\n      script: true,\n      comment: true,\n      headFavicon: true,\n      headWhitespace: true,\n      headMetaDescKeywords: slimDOM === \"all\",\n      // destructive\n      headMetaSocial: true,\n      headMetaRobots: true,\n      headMetaHttpEquiv: true,\n      headMetaAuthorship: true,\n      headMetaVerification: true\n    }\n  ) : slimDOM === false ? {} : slimDOM;\n  return serializeNodeWithId(n2, {\n    doc: n2,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild: false,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn,\n    newlyAddedElement: false\n  });\n}\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\nfunction parse(css, options = {}) {\n  let lineno = 1;\n  let column = 1;\n  function updatePosition(str) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    const i2 = str.lastIndexOf(\"\\n\");\n    column = i2 === -1 ? column + str.length : str.length - i2;\n  }\n  function position() {\n    const start = { line: lineno, column };\n    return (node) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n  const _Position = class _Position2 {\n    constructor(start) {\n      __publicField$1(this, \"content\");\n      __publicField$1(this, \"start\");\n      __publicField$1(this, \"end\");\n      __publicField$1(this, \"source\");\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n      this.content = _Position2.content;\n    }\n  };\n  __publicField$1(_Position, \"content\");\n  let Position = _Position;\n  Position.content = css;\n  const errorsList = [];\n  function error(msg) {\n    const err = new Error(\n      `${options.source || \"\"}:${lineno}:${column}: ${msg}`\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n  function stylesheet() {\n    const rulesList = rules2();\n    return {\n      type: \"stylesheet\",\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList\n      }\n    };\n  }\n  function open() {\n    return match(/^{\\s*/);\n  }\n  function close() {\n    return match(/^}/);\n  }\n  function rules2() {\n    let node;\n    const rules22 = [];\n    whitespace();\n    comments(rules22);\n    while (css.length && css.charAt(0) !== \"}\" && (node = atrule() || rule())) {\n      if (node) {\n        rules22.push(node);\n        comments(rules22);\n      }\n    }\n    return rules22;\n  }\n  function match(re) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n  function whitespace() {\n    match(/^\\s*/);\n  }\n  function comments(rules22 = []) {\n    let c2;\n    while (c2 = comment()) {\n      if (c2) {\n        rules22.push(c2);\n      }\n      c2 = comment();\n    }\n    return rules22;\n  }\n  function comment() {\n    const pos = position();\n    if (\"/\" !== css.charAt(0) || \"*\" !== css.charAt(1)) {\n      return;\n    }\n    let i2 = 2;\n    while (\"\" !== css.charAt(i2) && (\"*\" !== css.charAt(i2) || \"/\" !== css.charAt(i2 + 1))) {\n      ++i2;\n    }\n    i2 += 2;\n    if (\"\" === css.charAt(i2 - 1)) {\n      return error(\"End of comment missing\");\n    }\n    const str = css.slice(2, i2 - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i2);\n    column += 2;\n    return pos({\n      type: \"comment\",\n      comment: str\n    });\n  }\n  function selector() {\n    const m = match(/^([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const splitSelectors = trim(m[0]).replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, \"\").replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m2) => {\n      return m2.replace(/,/g, \"‌\");\n    }).split(/\\s*(?![^(]*\\)),\\s*/);\n    if (splitSelectors.length <= 1) {\n      return splitSelectors.map((s2) => {\n        return s2.replace(/\\u200C/g, \",\");\n      });\n    }\n    let i2 = 0;\n    let j = 0;\n    const len = splitSelectors.length;\n    const finalSelectors = [];\n    while (i2 < len) {\n      const openingParensCount = (splitSelectors[i2].match(/\\(/g) || []).length;\n      const closingParensCount = (splitSelectors[i2].match(/\\)/g) || []).length;\n      let unbalancedParens = openingParensCount - closingParensCount;\n      if (unbalancedParens >= 1) {\n        let foundClosingSelector = false;\n        j = i2 + 1;\n        while (j < len) {\n          const nextOpeningParensCount = (splitSelectors[j].match(/\\(/g) || []).length;\n          const nextClosingParensCount = (splitSelectors[j].match(/\\)/g) || []).length;\n          const nextUnbalancedParens = nextClosingParensCount - nextOpeningParensCount;\n          if (nextUnbalancedParens === unbalancedParens) {\n            finalSelectors.push(splitSelectors.slice(i2, j + 1).join(\",\"));\n            i2 = j + 1;\n            foundClosingSelector = true;\n            break;\n          }\n          j++;\n          unbalancedParens -= nextUnbalancedParens;\n        }\n        if (foundClosingSelector) {\n          continue;\n        }\n        splitSelectors.slice(i2, len).forEach((selector2) => selector2 && finalSelectors.push(selector2));\n        break;\n      }\n      splitSelectors[i2] && finalSelectors.push(splitSelectors[i2]);\n      i2++;\n    }\n    return finalSelectors.map((s2) => {\n      return s2.replace(/\\u200C/g, \",\");\n    });\n  }\n  function declaration() {\n    const pos = position();\n    const propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n    const ret = pos({\n      type: \"declaration\",\n      property: prop.replace(commentre, \"\"),\n      value: val ? trim(val[0]).replace(commentre, \"\") : \"\"\n    });\n    match(/^[;\\s]*/);\n    return ret;\n  }\n  function declarations() {\n    const decls = [];\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n    let decl;\n    while (decl = declaration()) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n    while (m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/)) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n    if (!vals.length) {\n      return;\n    }\n    return pos({\n      type: \"keyframe\",\n      values: vals,\n      declarations: declarations()\n    });\n  }\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error(\"@keyframes missing name\");\n    }\n    const name = m[1];\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n    let frame;\n    let frames = comments();\n    while (frame = keyframe()) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n    return pos({\n      type: \"keyframes\",\n      name,\n      vendor,\n      keyframes: frames\n    });\n  }\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n    const style = comments().concat(rules2());\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n    return pos({\n      type: \"supports\",\n      supports,\n      rules: style\n    });\n  }\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n    if (!m) {\n      return;\n    }\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n    const style = comments().concat(rules2());\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n    return pos({\n      type: \"host\",\n      rules: style\n    });\n  }\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n    const style = comments().concat(rules2());\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n    return pos({\n      type: \"media\",\n      media,\n      rules: style\n    });\n  }\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n    return pos({\n      type: \"custom-media\",\n      name: trim(m[1]),\n      media: trim(m[2])\n    });\n  }\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n    const sel = selector() || [];\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n    let decl;\n    while (decl = declaration()) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n    return pos({\n      type: \"page\",\n      selectors: sel,\n      declarations: decls\n    });\n  }\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n    const style = comments().concat(rules2());\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n    return pos({\n      type: \"document\",\n      document: doc,\n      vendor,\n      rules: style\n    });\n  }\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n    let decl;\n    while (decl = declaration()) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n    return pos({\n      type: \"font-face\",\n      declarations: decls\n    });\n  }\n  const atimport = _compileAtrule(\"import\");\n  const atcharset = _compileAtrule(\"charset\");\n  const atnamespace = _compileAtrule(\"namespace\");\n  function _compileAtrule(name) {\n    const re = new RegExp(\n      \"^@\" + name + \"\\\\s*((?:\" + [\n        /[^\\\\]\"(?:\\\\\"|[^\"])*\"/.source,\n        // consume any quoted parts (checking that the double quote isn't itself escaped)\n        /[^\\\\]'(?:\\\\'|[^'])*'/.source,\n        // same but for single quotes\n        \"[^;]\"\n      ].join(\"|\") + \")+);\"\n    );\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n  function atrule() {\n    if (css[0] !== \"@\") {\n      return;\n    }\n    return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();\n  }\n  function rule() {\n    const pos = position();\n    const sel = selector();\n    if (!sel) {\n      return error(\"selector missing\");\n    }\n    comments();\n    return pos({\n      type: \"rule\",\n      selectors: sel,\n      declarations: declarations()\n    });\n  }\n  return addParent(stylesheet());\n}\nfunction trim(str) {\n  return str ? str.replace(/^\\s+|\\s+$/g, \"\") : \"\";\n}\nfunction addParent(obj, parent) {\n  const isNode = obj && typeof obj.type === \"string\";\n  const childParent = isNode ? obj : parent;\n  for (const k of Object.keys(obj)) {\n    const value = obj[k];\n    if (Array.isArray(value)) {\n      value.forEach((v2) => {\n        addParent(v2, childParent);\n      });\n    } else if (value && typeof value === \"object\") {\n      addParent(value, childParent);\n    }\n  }\n  if (isNode) {\n    Object.defineProperty(obj, \"parent\", {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null\n    });\n  }\n  return obj;\n}\nconst tagMap = {\n  script: \"noscript\",\n  // camel case svg element tag names\n  altglyph: \"altGlyph\",\n  altglyphdef: \"altGlyphDef\",\n  altglyphitem: \"altGlyphItem\",\n  animatecolor: \"animateColor\",\n  animatemotion: \"animateMotion\",\n  animatetransform: \"animateTransform\",\n  clippath: \"clipPath\",\n  feblend: \"feBlend\",\n  fecolormatrix: \"feColorMatrix\",\n  fecomponenttransfer: \"feComponentTransfer\",\n  fecomposite: \"feComposite\",\n  feconvolvematrix: \"feConvolveMatrix\",\n  fediffuselighting: \"feDiffuseLighting\",\n  fedisplacementmap: \"feDisplacementMap\",\n  fedistantlight: \"feDistantLight\",\n  fedropshadow: \"feDropShadow\",\n  feflood: \"feFlood\",\n  fefunca: \"feFuncA\",\n  fefuncb: \"feFuncB\",\n  fefuncg: \"feFuncG\",\n  fefuncr: \"feFuncR\",\n  fegaussianblur: \"feGaussianBlur\",\n  feimage: \"feImage\",\n  femerge: \"feMerge\",\n  femergenode: \"feMergeNode\",\n  femorphology: \"feMorphology\",\n  feoffset: \"feOffset\",\n  fepointlight: \"fePointLight\",\n  fespecularlighting: \"feSpecularLighting\",\n  fespotlight: \"feSpotLight\",\n  fetile: \"feTile\",\n  feturbulence: \"feTurbulence\",\n  foreignobject: \"foreignObject\",\n  glyphref: \"glyphRef\",\n  lineargradient: \"linearGradient\",\n  radialgradient: \"radialGradient\"\n};\nfunction getTagName(n2) {\n  let tagName = tagMap[n2.tagName] ? tagMap[n2.tagName] : n2.tagName;\n  if (tagName === \"link\" && n2.attributes._cssText) {\n    tagName = \"style\";\n  }\n  return tagName;\n}\nfunction escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, \"g\");\nfunction addHoverClass(cssText, cache) {\n  const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\n  if (cachedStyle) return cachedStyle;\n  if (cssText.length >= 1e6) {\n    return cssText;\n  }\n  const ast = parse(cssText, {\n    silent: true\n  });\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n  const selectors = [];\n  ast.stylesheet.rules.forEach((rule) => {\n    if (\"selectors\" in rule) {\n      (rule.selectors || []).forEach((selector) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          selectors.push(selector);\n        }\n      });\n    }\n  });\n  if (selectors.length === 0) {\n    return cssText;\n  }\n  const selectorMatcher = new RegExp(\n    selectors.filter((selector, index) => selectors.indexOf(selector) === index).sort((a2, b) => b.length - a2.length).map((selector) => {\n      return escapeRegExp(selector);\n    }).join(\"|\"),\n    \"g\"\n  );\n  const result = cssText.replace(selectorMatcher, (selector) => {\n    const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, \"$1.\\\\:hover\");\n    return `${selector}, ${newSelector}`;\n  });\n  cache?.stylesWithHoverClass.set(cssText, result);\n  return result;\n}\nfunction createCache() {\n  const stylesWithHoverClass = /* @__PURE__ */ new Map();\n  return {\n    stylesWithHoverClass\n  };\n}\nfunction buildNode(n2, options) {\n  const { doc, hackCss, cache } = options;\n  switch (n2.type) {\n    case NodeType$2.Document:\n      return doc.implementation.createDocument(null, \"\", null);\n    case NodeType$2.DocumentType:\n      return doc.implementation.createDocumentType(\n        n2.name || \"html\",\n        n2.publicId,\n        n2.systemId\n      );\n    case NodeType$2.Element: {\n      const tagName = getTagName(n2);\n      let node;\n      if (n2.isSVG) {\n        node = doc.createElementNS(\"http://www.w3.org/2000/svg\", tagName);\n      } else {\n        if (\n          // If the tag name is a custom element name\n          n2.isCustom && // If the browser supports custom elements\n          doc.defaultView?.customElements && // If the custom element hasn't been defined yet\n          !doc.defaultView.customElements.get(n2.tagName)\n        )\n          doc.defaultView.customElements.define(\n            n2.tagName,\n            class extends doc.defaultView.HTMLElement {\n            }\n          );\n        node = doc.createElement(tagName);\n      }\n      const specialAttributes = {};\n      for (const name in n2.attributes) {\n        if (!Object.prototype.hasOwnProperty.call(n2.attributes, name)) {\n          continue;\n        }\n        let value = n2.attributes[name];\n        if (tagName === \"option\" && name === \"selected\" && value === false) {\n          continue;\n        }\n        if (value === null) {\n          continue;\n        }\n        if (value === true) value = \"\";\n        if (name.startsWith(\"rr_\")) {\n          specialAttributes[name] = value;\n          continue;\n        }\n        const isTextarea = tagName === \"textarea\" && name === \"value\";\n        const isRemoteOrDynamicCss = tagName === \"style\" && name === \"_cssText\";\n        if (isRemoteOrDynamicCss && hackCss && typeof value === \"string\") {\n          value = addHoverClass(value, cache);\n        }\n        if ((isTextarea || isRemoteOrDynamicCss) && typeof value === \"string\") {\n          const child = doc.createTextNode(value);\n          for (const c2 of Array.from(node.childNodes)) {\n            if (c2.nodeType === node.TEXT_NODE) {\n              node.removeChild(c2);\n            }\n          }\n          node.appendChild(child);\n          continue;\n        }\n        try {\n          if (n2.isSVG && name === \"xlink:href\") {\n            node.setAttributeNS(\n              \"http://www.w3.org/1999/xlink\",\n              name,\n              value.toString()\n            );\n          } else if (name === \"onload\" || name === \"onclick\" || name.substring(0, 7) === \"onmouse\") {\n            node.setAttribute(\"_\" + name, value.toString());\n          } else if (tagName === \"meta\" && n2.attributes[\"http-equiv\"] === \"Content-Security-Policy\" && name === \"content\") {\n            node.setAttribute(\"csp-content\", value.toString());\n            continue;\n          } else if (tagName === \"link\" && (n2.attributes.rel === \"preload\" || n2.attributes.rel === \"modulepreload\")) {\n          } else if (tagName === \"link\" && n2.attributes.rel === \"prefetch\" && typeof n2.attributes.href === \"string\" && extractFileExtension(n2.attributes.href) === \"js\") {\n          } else if (tagName === \"img\" && n2.attributes.srcset && n2.attributes.rr_dataURL) {\n            node.setAttribute(\n              \"rrweb-original-srcset\",\n              n2.attributes.srcset\n            );\n          } else {\n            node.setAttribute(name, value.toString());\n          }\n        } catch (error) {\n        }\n      }\n      for (const name in specialAttributes) {\n        const value = specialAttributes[name];\n        if (tagName === \"canvas\" && name === \"rr_dataURL\") {\n          const image = doc.createElement(\"img\");\n          image.onload = () => {\n            const ctx = node.getContext(\"2d\");\n            if (ctx) {\n              ctx.drawImage(image, 0, 0, image.width, image.height);\n            }\n          };\n          image.src = value.toString();\n          if (node.RRNodeType)\n            node.rr_dataURL = value.toString();\n        } else if (tagName === \"img\" && name === \"rr_dataURL\") {\n          const image = node;\n          if (!image.currentSrc.startsWith(\"data:\")) {\n            image.setAttribute(\n              \"rrweb-original-src\",\n              n2.attributes.src\n            );\n            image.src = value.toString();\n          }\n        }\n        if (name === \"rr_width\") {\n          node.style.setProperty(\"width\", value.toString());\n        } else if (name === \"rr_height\") {\n          node.style.setProperty(\"height\", value.toString());\n        } else if (name === \"rr_mediaCurrentTime\" && typeof value === \"number\") {\n          node.currentTime = value;\n        } else if (name === \"rr_mediaState\") {\n          switch (value) {\n            case \"played\":\n              node.play().catch((e2) => console.warn(\"media playback error\", e2));\n              break;\n            case \"paused\":\n              node.pause();\n              break;\n          }\n        }\n      }\n      if (n2.isShadowHost) {\n        if (!node.shadowRoot) {\n          node.attachShadow({ mode: \"open\" });\n        } else {\n          while (node.shadowRoot.firstChild) {\n            node.shadowRoot.removeChild(node.shadowRoot.firstChild);\n          }\n        }\n      }\n      return node;\n    }\n    case NodeType$2.Text:\n      return doc.createTextNode(\n        n2.isStyle && hackCss ? addHoverClass(n2.textContent, cache) : n2.textContent\n      );\n    case NodeType$2.CDATA:\n      if (!(doc instanceof XMLDocument)) {\n        return null;\n      }\n      return doc.createCDATASection(n2.textContent);\n    case NodeType$2.Comment:\n      return doc.createComment(n2.textContent);\n    default:\n      return null;\n  }\n}\nfunction buildNodeWithSN(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    skipChild = false,\n    hackCss = true,\n    afterAppend,\n    cache\n  } = options;\n  if (mirror2.has(n2.id)) {\n    const nodeInMirror = mirror2.getNode(n2.id);\n    const meta = mirror2.getMeta(nodeInMirror);\n    if (isNodeMetaEqual(meta, n2)) return mirror2.getNode(n2.id);\n  }\n  let node = buildNode(n2, { doc, hackCss, cache });\n  if (!node) {\n    return null;\n  }\n  if (n2.rootId && mirror2.getNode(n2.rootId) !== doc) {\n    mirror2.replace(n2.rootId, doc);\n  }\n  if (n2.type === NodeType$2.Document) {\n    doc.close();\n    doc.open();\n    if (n2.compatMode === \"BackCompat\" && n2.childNodes && n2.childNodes[0].type !== NodeType$2.DocumentType) {\n      if (n2.childNodes[0].type === NodeType$2.Element && \"xmlns\" in n2.childNodes[0].attributes && n2.childNodes[0].attributes.xmlns === \"http://www.w3.org/1999/xhtml\") {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">'\n        );\n      } else {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">'\n        );\n      }\n    }\n    node = doc;\n  }\n  mirror2.add(node, n2);\n  if ((n2.type === NodeType$2.Document || n2.type === NodeType$2.Element) && !skipChild) {\n    for (const childN of n2.childNodes) {\n      const childNode = buildNodeWithSN(childN, {\n        doc,\n        mirror: mirror2,\n        skipChild: false,\n        hackCss,\n        afterAppend,\n        cache\n      });\n      if (!childNode) {\n        console.warn(\"Failed to rebuild\", childN);\n        continue;\n      }\n      if (childN.isShadow && isElement(node) && node.shadowRoot) {\n        node.shadowRoot.appendChild(childNode);\n      } else if (n2.type === NodeType$2.Document && childN.type == NodeType$2.Element) {\n        const htmlElement = childNode;\n        let body = null;\n        htmlElement.childNodes.forEach((child) => {\n          if (child.nodeName === \"BODY\") body = child;\n        });\n        if (body) {\n          htmlElement.removeChild(body);\n          node.appendChild(childNode);\n          htmlElement.appendChild(body);\n        } else {\n          node.appendChild(childNode);\n        }\n      } else {\n        node.appendChild(childNode);\n      }\n      if (afterAppend) {\n        afterAppend(childNode, childN.id);\n      }\n    }\n  }\n  return node;\n}\nfunction visit(mirror2, onVisit) {\n  function walk(node) {\n    onVisit(node);\n  }\n  for (const id of mirror2.getIds()) {\n    if (mirror2.has(id)) {\n      walk(mirror2.getNode(id));\n    }\n  }\n}\nfunction handleScroll(node, mirror2) {\n  const n2 = mirror2.getMeta(node);\n  if (n2?.type !== NodeType$2.Element) {\n    return;\n  }\n  const el = node;\n  for (const name in n2.attributes) {\n    if (!(Object.prototype.hasOwnProperty.call(n2.attributes, name) && name.startsWith(\"rr_\"))) {\n      continue;\n    }\n    const value = n2.attributes[name];\n    if (name === \"rr_scrollLeft\") {\n      el.scrollLeft = value;\n    }\n    if (name === \"rr_scrollTop\") {\n      el.scrollTop = value;\n    }\n  }\n}\nfunction rebuild(n2, options) {\n  const {\n    doc,\n    onVisit,\n    hackCss = true,\n    afterAppend,\n    cache,\n    mirror: mirror2 = new Mirror()\n  } = options;\n  const node = buildNodeWithSN(n2, {\n    doc,\n    mirror: mirror2,\n    skipChild: false,\n    hackCss,\n    afterAppend,\n    cache\n  });\n  visit(mirror2, (visitedNode) => {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n    handleScroll(visitedNode, mirror2);\n  });\n  return node;\n}\nfunction on(type, fn, target = document) {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\nconst DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.\";\nlet _mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  }\n};\nif (typeof window !== \"undefined\" && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === \"map\") {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction throttle(func, wait, options = {}) {\n  let timeout = null;\n  let previous = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    const context = this;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout$1(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\nfunction hookSetter(target, key, d, isRevoked, win = window) {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked ? d : {\n      set(value) {\n        setTimeout$1(() => {\n          d.set.call(this, value);\n        }, 0);\n        if (original && original.set) {\n          original.set.call(this, value);\n        }\n      }\n    }\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return () => {\n      };\n    }\n    const original = source[name];\n    const wrapped = replacement(original);\n    if (typeof wrapped === \"function\") {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    }\n    source[name] = wrapped;\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {\n    };\n  }\n}\nlet nowTimestamp = Date.now;\nif (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {\n  nowTimestamp = () => (/* @__PURE__ */ new Date()).getTime();\n}\nfunction getWindowScroll(win) {\n  const doc = win.document;\n  return {\n    left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc?.documentElement.scrollLeft || doc?.body?.parentElement?.scrollLeft || doc?.body?.scrollLeft || 0,\n    top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : doc?.documentElement.scrollTop || doc?.body?.parentElement?.scrollTop || doc?.body?.scrollTop || 0\n  };\n}\nfunction getWindowHeight() {\n  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode(node) {\n  if (!node) {\n    return null;\n  }\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    return el;\n  } catch (error) {\n    return null;\n  }\n}\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\n  if (!node) {\n    return false;\n  }\n  const el = closestElementOfNode(node);\n  if (!el) {\n    return false;\n  }\n  const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\n  if (!checkAncestors) {\n    const isUnblocked = unblockSelector && el.matches(unblockSelector);\n    return blockedPredicate(el) && !isUnblocked;\n  }\n  const blockDistance = distanceToMatch(el, blockedPredicate);\n  let unblockDistance = -1;\n  if (blockDistance < 0) {\n    return false;\n  }\n  if (unblockSelector) {\n    unblockDistance = distanceToMatch(\n      el,\n      createMatchPredicate(null, unblockSelector)\n    );\n  }\n  if (blockDistance > -1 && unblockDistance < 0) {\n    return true;\n  }\n  return blockDistance < unblockDistance;\n}\nfunction isSerialized(n2, mirror2) {\n  return mirror2.getId(n2) !== -1;\n}\nfunction isIgnored(n2, mirror2) {\n  return mirror2.getId(n2) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror2) {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror2.getId(target);\n  if (!mirror2.has(id)) {\n    return true;\n  }\n  if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n    return false;\n  }\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved(target.parentNode, mirror2);\n}\nfunction legacy_isTouchEvent(event) {\n  return Boolean(event.changedTouches);\n}\nfunction polyfill$1(win = window) {\n  if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = (...args) => {\n      let node = args[0];\n      if (!(0 in args)) {\n        throw new TypeError(\"1 argument is required\");\n      }\n      do {\n        if (this === node) {\n          return true;\n        }\n      } while (node = node && node.parentNode);\n      return false;\n    };\n  }\n}\nfunction queueToResolveTrees(queue) {\n  const queueNodeMap = {};\n  const putIntoMap = (m, parent) => {\n    const nodeInTree = {\n      value: m,\n      parent,\n      children: []\n    };\n    queueNodeMap[m.node.id] = nodeInTree;\n    return nodeInTree;\n  };\n  const queueNodeTrees = [];\n  for (const mutation of queue) {\n    const { nextId, parentId } = mutation;\n    if (nextId && nextId in queueNodeMap) {\n      const nextInTree = queueNodeMap[nextId];\n      if (nextInTree.parent) {\n        const idx = nextInTree.parent.children.indexOf(nextInTree);\n        nextInTree.parent.children.splice(\n          idx,\n          0,\n          putIntoMap(mutation, nextInTree.parent)\n        );\n      } else {\n        const idx = queueNodeTrees.indexOf(nextInTree);\n        queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\n      }\n      continue;\n    }\n    if (parentId in queueNodeMap) {\n      const parentInTree = queueNodeMap[parentId];\n      parentInTree.children.push(putIntoMap(mutation, parentInTree));\n      continue;\n    }\n    queueNodeTrees.push(putIntoMap(mutation, null));\n  }\n  return queueNodeTrees;\n}\nfunction iterateResolveTree(tree, cb) {\n  cb(tree.value);\n  for (let i2 = tree.children.length - 1; i2 >= 0; i2--) {\n    iterateResolveTree(tree.children[i2], cb);\n  }\n}\nfunction isSerializedIframe(n2, mirror2) {\n  return Boolean(n2.nodeName === \"IFRAME\" && mirror2.getMeta(n2));\n}\nfunction isSerializedStylesheet(n2, mirror2) {\n  return Boolean(\n    n2.nodeName === \"LINK\" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute(\"rel\") === \"stylesheet\" && mirror2.getMeta(n2)\n  );\n}\nfunction getBaseDimension(node, rootIframe) {\n  const frameElement = node.ownerDocument?.defaultView?.frameElement;\n  if (!frameElement || frameElement === rootIframe) {\n    return {\n      x: 0,\n      y: 0,\n      relativeScale: 1,\n      absoluteScale: 1\n    };\n  }\n  const frameDimension = frameElement.getBoundingClientRect();\n  const frameBaseDimension = getBaseDimension(frameElement, rootIframe);\n  const relativeScale = frameDimension.height / frameElement.clientHeight;\n  return {\n    x: frameDimension.x * frameBaseDimension.relativeScale + frameBaseDimension.x,\n    y: frameDimension.y * frameBaseDimension.relativeScale + frameBaseDimension.y,\n    relativeScale,\n    absoluteScale: frameBaseDimension.absoluteScale * relativeScale\n  };\n}\nfunction hasShadowRoot(n2) {\n  return Boolean(n2?.shadowRoot);\n}\nfunction getNestedRule(rules2, position) {\n  const rule = rules2[position[0]];\n  if (position.length === 1) {\n    return rule;\n  } else {\n    return getNestedRule(\n      rule.cssRules[position[1]].cssRules,\n      position.slice(2)\n    );\n  }\n}\nfunction getPositionsAndIndex(nestedIndex) {\n  const positions = [...nestedIndex];\n  const index = positions.pop();\n  return { positions, index };\n}\nfunction uniqueTextMutations(mutations) {\n  const idSet = /* @__PURE__ */ new Set();\n  const uniqueMutations = [];\n  for (let i2 = mutations.length; i2--; ) {\n    const mutation = mutations[i2];\n    if (!idSet.has(mutation.id)) {\n      uniqueMutations.push(mutation);\n      idSet.add(mutation.id);\n    }\n  }\n  return uniqueMutations;\n}\nclass StyleSheetMirror {\n  constructor() {\n    this.id = 1;\n    this.styleIDMap = /* @__PURE__ */ new WeakMap();\n    this.idStyleMap = /* @__PURE__ */ new Map();\n  }\n  getId(stylesheet) {\n    return this.styleIDMap.get(stylesheet) ?? -1;\n  }\n  has(stylesheet) {\n    return this.styleIDMap.has(stylesheet);\n  }\n  /**\n   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.\n   */\n  add(stylesheet, id) {\n    if (this.has(stylesheet)) return this.getId(stylesheet);\n    let newId;\n    if (id === void 0) {\n      newId = this.id++;\n    } else newId = id;\n    this.styleIDMap.set(stylesheet, newId);\n    this.idStyleMap.set(newId, stylesheet);\n    return newId;\n  }\n  getStyle(id) {\n    return this.idStyleMap.get(id) || null;\n  }\n  reset() {\n    this.styleIDMap = /* @__PURE__ */ new WeakMap();\n    this.idStyleMap = /* @__PURE__ */ new Map();\n    this.id = 1;\n  }\n  generateId() {\n    return this.id++;\n  }\n}\nfunction getShadowHost(n2) {\n  let shadowHost = null;\n  if (n2.getRootNode?.()?.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n2.getRootNode().host)\n    shadowHost = n2.getRootNode().host;\n  return shadowHost;\n}\nfunction getRootShadowHost(n2) {\n  let rootShadowHost = n2;\n  let shadowHost;\n  while (shadowHost = getShadowHost(rootShadowHost))\n    rootShadowHost = shadowHost;\n  return rootShadowHost;\n}\nfunction shadowHostInDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  const shadowHost = getRootShadowHost(n2);\n  return doc.contains(shadowHost);\n}\nfunction inDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  return doc.contains(n2) || shadowHostInDom(n2);\n}\nconst cachedImplementations = {};\nfunction getImplementation(name) {\n  const cached = cachedImplementations[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations[name] = impl.bind(\n    window\n  );\n}\nfunction onRequestAnimationFrame(...rest) {\n  return getImplementation(\"requestAnimationFrame\")(...rest);\n}\nfunction setTimeout$1(...rest) {\n  return getImplementation(\"setTimeout\")(...rest);\n}\nfunction clearTimeout(...rest) {\n  return getImplementation(\"clearTimeout\")(...rest);\n}\nconst utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  StyleSheetMirror,\n  get _mirror() {\n    return _mirror;\n  },\n  clearTimeout,\n  closestElementOfNode,\n  getBaseDimension,\n  getNestedRule,\n  getPositionsAndIndex,\n  getRootShadowHost,\n  getShadowHost,\n  getWindowHeight,\n  getWindowScroll,\n  getWindowWidth,\n  hasShadowRoot,\n  hookSetter,\n  inDom,\n  isAncestorRemoved,\n  isBlocked,\n  isIgnored,\n  isSerialized,\n  isSerializedIframe,\n  isSerializedStylesheet,\n  iterateResolveTree,\n  legacy_isTouchEvent,\n  get nowTimestamp() {\n    return nowTimestamp;\n  },\n  on,\n  onRequestAnimationFrame,\n  patch,\n  polyfill: polyfill$1,\n  queueToResolveTrees,\n  setTimeout: setTimeout$1,\n  shadowHostInDom,\n  throttle,\n  uniqueTextMutations\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {\n  CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n  CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n  CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n  return CanvasContext2;\n})(CanvasContext || {});\nvar MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {\n  MediaInteractions2[MediaInteractions2[\"Play\"] = 0] = \"Play\";\n  MediaInteractions2[MediaInteractions2[\"Pause\"] = 1] = \"Pause\";\n  MediaInteractions2[MediaInteractions2[\"Seeked\"] = 2] = \"Seeked\";\n  MediaInteractions2[MediaInteractions2[\"VolumeChange\"] = 3] = \"VolumeChange\";\n  MediaInteractions2[MediaInteractions2[\"RateChange\"] = 4] = \"RateChange\";\n  return MediaInteractions2;\n})(MediaInteractions || {});\nvar ReplayerEvents = /* @__PURE__ */ ((ReplayerEvents2) => {\n  ReplayerEvents2[\"Start\"] = \"start\";\n  ReplayerEvents2[\"Pause\"] = \"pause\";\n  ReplayerEvents2[\"Resume\"] = \"resume\";\n  ReplayerEvents2[\"Resize\"] = \"resize\";\n  ReplayerEvents2[\"Finish\"] = \"finish\";\n  ReplayerEvents2[\"FullsnapshotRebuilded\"] = \"fullsnapshot-rebuilded\";\n  ReplayerEvents2[\"LoadStylesheetStart\"] = \"load-stylesheet-start\";\n  ReplayerEvents2[\"LoadStylesheetEnd\"] = \"load-stylesheet-end\";\n  ReplayerEvents2[\"SkipStart\"] = \"skip-start\";\n  ReplayerEvents2[\"SkipEnd\"] = \"skip-end\";\n  ReplayerEvents2[\"MouseInteraction\"] = \"mouse-interaction\";\n  ReplayerEvents2[\"EventCast\"] = \"event-cast\";\n  ReplayerEvents2[\"CustomEvent\"] = \"custom-event\";\n  ReplayerEvents2[\"Flush\"] = \"flush\";\n  ReplayerEvents2[\"StateChange\"] = \"state-change\";\n  ReplayerEvents2[\"PlayBack\"] = \"play-back\";\n  ReplayerEvents2[\"Destroy\"] = \"destroy\";\n  return ReplayerEvents2;\n})(ReplayerEvents || {});\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar __defProp2 = Object.defineProperty;\nvar __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar NodeType$1 = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType$1 || {});\nlet Mirror$1 = class Mirror2 {\n  constructor() {\n    __publicField2(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField2(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach(\n        (childNode) => this.removeNodeFromMap(childNode)\n      );\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n};\nfunction createMirror$1() {\n  return new Mirror$1();\n}\nfunction parseCSSText(cssText) {\n  const res = {};\n  const listDelimiter = /;(?![^(]*\\))/g;\n  const propertyDelimiter = /:(.+)/;\n  const comment = /\\/\\*.*?\\*\\//g;\n  cssText.replace(comment, \"\").split(listDelimiter).forEach(function(item) {\n    if (item) {\n      const tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[camelize(tmp[0].trim())] = tmp[1].trim());\n    }\n  });\n  return res;\n}\nfunction toCSSText(style) {\n  const properties = [];\n  for (const name in style) {\n    const value = style[name];\n    if (typeof value !== \"string\") continue;\n    const normalizedName = hyphenate(name);\n    properties.push(`${normalizedName}: ${value};`);\n  }\n  return properties.join(\" \");\n}\nconst camelizeRE = /-([a-z])/g;\nconst CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9-]+$/;\nconst camelize = (str) => {\n  if (CUSTOM_PROPERTY_REGEX.test(str)) return str;\n  return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : \"\");\n};\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = (str) => {\n  return str.replace(hyphenateRE, \"-$1\").toLowerCase();\n};\nclass BaseRRNode {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any\n  constructor(..._args) {\n    __publicField(this, \"parentElement\", null);\n    __publicField(this, \"parentNode\", null);\n    __publicField(this, \"ownerDocument\");\n    __publicField(this, \"firstChild\", null);\n    __publicField(this, \"lastChild\", null);\n    __publicField(this, \"previousSibling\", null);\n    __publicField(this, \"nextSibling\", null);\n    __publicField(this, \"ELEMENT_NODE\", 1);\n    __publicField(this, \"TEXT_NODE\", 3);\n    __publicField(this, \"nodeType\");\n    __publicField(this, \"nodeName\");\n    __publicField(this, \"RRNodeType\");\n  }\n  get childNodes() {\n    const childNodes = [];\n    let childIterator = this.firstChild;\n    while (childIterator) {\n      childNodes.push(childIterator);\n      childIterator = childIterator.nextSibling;\n    }\n    return childNodes;\n  }\n  contains(node) {\n    if (!(node instanceof BaseRRNode)) return false;\n    else if (node.ownerDocument !== this.ownerDocument) return false;\n    else if (node === this) return true;\n    while (node.parentNode) {\n      if (node.parentNode === this) return true;\n      node = node.parentNode;\n    }\n    return false;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  appendChild(_newChild) {\n    throw new Error(\n      `RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method.`\n    );\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  insertBefore(_newChild, _refChild) {\n    throw new Error(\n      `RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method.`\n    );\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  removeChild(_node) {\n    throw new Error(\n      `RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method.`\n    );\n  }\n  toString() {\n    return \"RRNode\";\n  }\n}\nclass BaseRRDocument extends BaseRRNode {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(...args) {\n    super(args);\n    __publicField(this, \"nodeType\", 9);\n    __publicField(this, \"nodeName\", \"#document\");\n    __publicField(this, \"compatMode\", \"CSS1Compat\");\n    __publicField(this, \"RRNodeType\", NodeType$1.Document);\n    __publicField(this, \"textContent\", null);\n    this.ownerDocument = this;\n  }\n  get documentElement() {\n    return this.childNodes.find(\n      (node) => node.RRNodeType === NodeType$1.Element && node.tagName === \"HTML\"\n    ) || null;\n  }\n  get body() {\n    return this.documentElement?.childNodes.find(\n      (node) => node.RRNodeType === NodeType$1.Element && node.tagName === \"BODY\"\n    ) || null;\n  }\n  get head() {\n    return this.documentElement?.childNodes.find(\n      (node) => node.RRNodeType === NodeType$1.Element && node.tagName === \"HEAD\"\n    ) || null;\n  }\n  get implementation() {\n    return this;\n  }\n  get firstElementChild() {\n    return this.documentElement;\n  }\n  appendChild(newChild) {\n    const nodeType = newChild.RRNodeType;\n    if (nodeType === NodeType$1.Element || nodeType === NodeType$1.DocumentType) {\n      if (this.childNodes.some((s2) => s2.RRNodeType === nodeType)) {\n        throw new Error(\n          `RRDomException: Failed to execute 'appendChild' on 'RRNode': Only one ${nodeType === NodeType$1.Element ? \"RRElement\" : \"RRDoctype\"} on RRDocument allowed.`\n        );\n      }\n    }\n    const child = appendChild(this, newChild);\n    child.parentElement = null;\n    return child;\n  }\n  insertBefore(newChild, refChild) {\n    const nodeType = newChild.RRNodeType;\n    if (nodeType === NodeType$1.Element || nodeType === NodeType$1.DocumentType) {\n      if (this.childNodes.some((s2) => s2.RRNodeType === nodeType)) {\n        throw new Error(\n          `RRDomException: Failed to execute 'insertBefore' on 'RRNode': Only one ${nodeType === NodeType$1.Element ? \"RRElement\" : \"RRDoctype\"} on RRDocument allowed.`\n        );\n      }\n    }\n    const child = insertBefore(this, newChild, refChild);\n    child.parentElement = null;\n    return child;\n  }\n  removeChild(node) {\n    return removeChild(this, node);\n  }\n  open() {\n    this.firstChild = null;\n    this.lastChild = null;\n  }\n  close() {\n  }\n  /**\n   * Adhoc implementation for setting xhtml namespace in rebuilt.ts (rrweb-snapshot).\n   * There are two lines used this function:\n   * 1. doc.write('\\<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\"\\>')\n   * 2. doc.write('\\<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\"\\>')\n   */\n  write(content) {\n    let publicId;\n    if (content === '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">')\n      publicId = \"-//W3C//DTD XHTML 1.0 Transitional//EN\";\n    else if (content === '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">')\n      publicId = \"-//W3C//DTD HTML 4.0 Transitional//EN\";\n    if (publicId) {\n      const doctype = this.createDocumentType(\"html\", publicId, \"\");\n      this.open();\n      this.appendChild(doctype);\n    }\n  }\n  createDocument(_namespace, _qualifiedName, _doctype) {\n    return new BaseRRDocument();\n  }\n  createDocumentType(qualifiedName, publicId, systemId) {\n    const doctype = new BaseRRDocumentType(qualifiedName, publicId, systemId);\n    doctype.ownerDocument = this;\n    return doctype;\n  }\n  createElement(tagName) {\n    const element = new BaseRRElement(tagName);\n    element.ownerDocument = this;\n    return element;\n  }\n  createElementNS(_namespaceURI, qualifiedName) {\n    return this.createElement(qualifiedName);\n  }\n  createTextNode(data) {\n    const text = new BaseRRText(data);\n    text.ownerDocument = this;\n    return text;\n  }\n  createComment(data) {\n    const comment = new BaseRRComment(data);\n    comment.ownerDocument = this;\n    return comment;\n  }\n  createCDATASection(data) {\n    const CDATASection = new BaseRRCDATASection(data);\n    CDATASection.ownerDocument = this;\n    return CDATASection;\n  }\n  toString() {\n    return \"RRDocument\";\n  }\n}\nclass BaseRRDocumentType extends BaseRRNode {\n  constructor(qualifiedName, publicId, systemId) {\n    super();\n    __publicField(this, \"nodeType\", 10);\n    __publicField(this, \"RRNodeType\", NodeType$1.DocumentType);\n    __publicField(this, \"name\");\n    __publicField(this, \"publicId\");\n    __publicField(this, \"systemId\");\n    __publicField(this, \"textContent\", null);\n    this.name = qualifiedName;\n    this.publicId = publicId;\n    this.systemId = systemId;\n    this.nodeName = qualifiedName;\n  }\n  toString() {\n    return \"RRDocumentType\";\n  }\n}\nclass BaseRRElement extends BaseRRNode {\n  constructor(tagName) {\n    super();\n    __publicField(this, \"nodeType\", 1);\n    __publicField(this, \"RRNodeType\", NodeType$1.Element);\n    __publicField(this, \"tagName\");\n    __publicField(this, \"attributes\", {});\n    __publicField(this, \"shadowRoot\", null);\n    __publicField(this, \"scrollLeft\");\n    __publicField(this, \"scrollTop\");\n    this.tagName = tagName.toUpperCase();\n    this.nodeName = tagName.toUpperCase();\n  }\n  get textContent() {\n    let result = \"\";\n    this.childNodes.forEach((node) => result += node.textContent);\n    return result;\n  }\n  set textContent(textContent) {\n    this.firstChild = null;\n    this.lastChild = null;\n    this.appendChild(this.ownerDocument.createTextNode(textContent));\n  }\n  get classList() {\n    return new ClassList(\n      this.attributes.class,\n      (newClassName) => {\n        this.attributes.class = newClassName;\n      }\n    );\n  }\n  get id() {\n    return this.attributes.id || \"\";\n  }\n  get className() {\n    return this.attributes.class || \"\";\n  }\n  get style() {\n    const style = this.attributes.style ? parseCSSText(this.attributes.style) : {};\n    const hyphenateRE2 = /\\B([A-Z])/g;\n    style.setProperty = (name, value, priority) => {\n      if (hyphenateRE2.test(name)) return;\n      const normalizedName = camelize(name);\n      if (!value) delete style[normalizedName];\n      else style[normalizedName] = value;\n      if (priority === \"important\") style[normalizedName] += \" !important\";\n      this.attributes.style = toCSSText(style);\n    };\n    style.removeProperty = (name) => {\n      if (hyphenateRE2.test(name)) return \"\";\n      const normalizedName = camelize(name);\n      const value = style[normalizedName] || \"\";\n      delete style[normalizedName];\n      this.attributes.style = toCSSText(style);\n      return value;\n    };\n    return style;\n  }\n  getAttribute(name) {\n    return this.attributes[name] || null;\n  }\n  setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n  }\n  setAttributeNS(_namespace, qualifiedName, value) {\n    this.setAttribute(qualifiedName, value);\n  }\n  removeAttribute(name) {\n    delete this.attributes[name];\n  }\n  appendChild(newChild) {\n    return appendChild(this, newChild);\n  }\n  insertBefore(newChild, refChild) {\n    return insertBefore(this, newChild, refChild);\n  }\n  removeChild(node) {\n    return removeChild(this, node);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attachShadow(_init) {\n    const shadowRoot = this.ownerDocument.createElement(\"SHADOWROOT\");\n    this.shadowRoot = shadowRoot;\n    return shadowRoot;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  dispatchEvent(_event) {\n    return true;\n  }\n  toString() {\n    let attributeString = \"\";\n    for (const attribute in this.attributes) {\n      attributeString += `${attribute}=\"${this.attributes[attribute]}\" `;\n    }\n    return `${this.tagName} ${attributeString}`;\n  }\n}\nclass BaseRRMediaElement extends BaseRRElement {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"currentTime\");\n    __publicField(this, \"volume\");\n    __publicField(this, \"paused\");\n    __publicField(this, \"muted\");\n    __publicField(this, \"playbackRate\");\n    __publicField(this, \"loop\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attachShadow(_init) {\n    throw new Error(\n      `RRDomException: Failed to execute 'attachShadow' on 'RRElement': This RRElement does not support attachShadow`\n    );\n  }\n  play() {\n    this.paused = false;\n  }\n  pause() {\n    this.paused = true;\n  }\n}\nclass BaseRRText extends BaseRRNode {\n  constructor(data) {\n    super();\n    __publicField(this, \"nodeType\", 3);\n    __publicField(this, \"nodeName\", \"#text\");\n    __publicField(this, \"RRNodeType\", NodeType$1.Text);\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  get textContent() {\n    return this.data;\n  }\n  set textContent(textContent) {\n    this.data = textContent;\n  }\n  toString() {\n    return `RRText text=${JSON.stringify(this.data)}`;\n  }\n}\nclass BaseRRComment extends BaseRRNode {\n  constructor(data) {\n    super();\n    __publicField(this, \"nodeType\", 8);\n    __publicField(this, \"nodeName\", \"#comment\");\n    __publicField(this, \"RRNodeType\", NodeType$1.Comment);\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  get textContent() {\n    return this.data;\n  }\n  set textContent(textContent) {\n    this.data = textContent;\n  }\n  toString() {\n    return `RRComment text=${JSON.stringify(this.data)}`;\n  }\n}\nclass BaseRRCDATASection extends BaseRRNode {\n  constructor(data) {\n    super();\n    __publicField(this, \"nodeName\", \"#cdata-section\");\n    __publicField(this, \"nodeType\", 4);\n    __publicField(this, \"RRNodeType\", NodeType$1.CDATA);\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  get textContent() {\n    return this.data;\n  }\n  set textContent(textContent) {\n    this.data = textContent;\n  }\n  toString() {\n    return `RRCDATASection data=${JSON.stringify(this.data)}`;\n  }\n}\nclass ClassList {\n  constructor(classText, onChange) {\n    __publicField(this, \"onChange\");\n    __publicField(this, \"classes\", []);\n    __publicField(this, \"add\", (...classNames) => {\n      for (const item of classNames) {\n        const className = String(item);\n        if (this.classes.indexOf(className) >= 0) continue;\n        this.classes.push(className);\n      }\n      this.onChange && this.onChange(this.classes.join(\" \"));\n    });\n    __publicField(this, \"remove\", (...classNames) => {\n      this.classes = this.classes.filter(\n        (item) => classNames.indexOf(item) === -1\n      );\n      this.onChange && this.onChange(this.classes.join(\" \"));\n    });\n    if (classText) {\n      const classes = classText.trim().split(/\\s+/);\n      this.classes.push(...classes);\n    }\n    this.onChange = onChange;\n  }\n}\nfunction appendChild(parent, newChild) {\n  if (newChild.parentNode) newChild.parentNode.removeChild(newChild);\n  if (parent.lastChild) {\n    parent.lastChild.nextSibling = newChild;\n    newChild.previousSibling = parent.lastChild;\n  } else {\n    parent.firstChild = newChild;\n    newChild.previousSibling = null;\n  }\n  parent.lastChild = newChild;\n  newChild.nextSibling = null;\n  newChild.parentNode = parent;\n  newChild.parentElement = parent;\n  newChild.ownerDocument = parent.ownerDocument;\n  return newChild;\n}\nfunction insertBefore(parent, newChild, refChild) {\n  if (!refChild) return appendChild(parent, newChild);\n  if (refChild.parentNode !== parent)\n    throw new Error(\n      \"Failed to execute 'insertBefore' on 'RRNode': The RRNode before which the new node is to be inserted is not a child of this RRNode.\"\n    );\n  if (newChild === refChild) return newChild;\n  if (newChild.parentNode) newChild.parentNode.removeChild(newChild);\n  newChild.previousSibling = refChild.previousSibling;\n  refChild.previousSibling = newChild;\n  newChild.nextSibling = refChild;\n  if (newChild.previousSibling) newChild.previousSibling.nextSibling = newChild;\n  else parent.firstChild = newChild;\n  newChild.parentElement = parent;\n  newChild.parentNode = parent;\n  newChild.ownerDocument = parent.ownerDocument;\n  return newChild;\n}\nfunction removeChild(parent, child) {\n  if (child.parentNode !== parent)\n    throw new Error(\n      \"Failed to execute 'removeChild' on 'RRNode': The RRNode to be removed is not a child of this RRNode.\"\n    );\n  if (child.previousSibling)\n    child.previousSibling.nextSibling = child.nextSibling;\n  else parent.firstChild = child.nextSibling;\n  if (child.nextSibling)\n    child.nextSibling.previousSibling = child.previousSibling;\n  else parent.lastChild = child.previousSibling;\n  child.previousSibling = null;\n  child.nextSibling = null;\n  child.parentElement = null;\n  child.parentNode = null;\n  return child;\n}\nvar NodeType = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"PLACEHOLDER\"] = 0] = \"PLACEHOLDER\";\n  NodeType2[NodeType2[\"ELEMENT_NODE\"] = 1] = \"ELEMENT_NODE\";\n  NodeType2[NodeType2[\"ATTRIBUTE_NODE\"] = 2] = \"ATTRIBUTE_NODE\";\n  NodeType2[NodeType2[\"TEXT_NODE\"] = 3] = \"TEXT_NODE\";\n  NodeType2[NodeType2[\"CDATA_SECTION_NODE\"] = 4] = \"CDATA_SECTION_NODE\";\n  NodeType2[NodeType2[\"ENTITY_REFERENCE_NODE\"] = 5] = \"ENTITY_REFERENCE_NODE\";\n  NodeType2[NodeType2[\"ENTITY_NODE\"] = 6] = \"ENTITY_NODE\";\n  NodeType2[NodeType2[\"PROCESSING_INSTRUCTION_NODE\"] = 7] = \"PROCESSING_INSTRUCTION_NODE\";\n  NodeType2[NodeType2[\"COMMENT_NODE\"] = 8] = \"COMMENT_NODE\";\n  NodeType2[NodeType2[\"DOCUMENT_NODE\"] = 9] = \"DOCUMENT_NODE\";\n  NodeType2[NodeType2[\"DOCUMENT_TYPE_NODE\"] = 10] = \"DOCUMENT_TYPE_NODE\";\n  NodeType2[NodeType2[\"DOCUMENT_FRAGMENT_NODE\"] = 11] = \"DOCUMENT_FRAGMENT_NODE\";\n  return NodeType2;\n})(NodeType || {});\nfunction getIFrameContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {\n  }\n}\nfunction getIFrameContentWindow(iframe) {\n  try {\n    return iframe.contentWindow;\n  } catch (e2) {\n  }\n}\nconst NAMESPACES = {\n  svg: \"http://www.w3.org/2000/svg\",\n  \"xlink:href\": \"http://www.w3.org/1999/xlink\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\nconst SVGTagMap = {\n  altglyph: \"altGlyph\",\n  altglyphdef: \"altGlyphDef\",\n  altglyphitem: \"altGlyphItem\",\n  animatecolor: \"animateColor\",\n  animatemotion: \"animateMotion\",\n  animatetransform: \"animateTransform\",\n  clippath: \"clipPath\",\n  feblend: \"feBlend\",\n  fecolormatrix: \"feColorMatrix\",\n  fecomponenttransfer: \"feComponentTransfer\",\n  fecomposite: \"feComposite\",\n  feconvolvematrix: \"feConvolveMatrix\",\n  fediffuselighting: \"feDiffuseLighting\",\n  fedisplacementmap: \"feDisplacementMap\",\n  fedistantlight: \"feDistantLight\",\n  fedropshadow: \"feDropShadow\",\n  feflood: \"feFlood\",\n  fefunca: \"feFuncA\",\n  fefuncb: \"feFuncB\",\n  fefuncg: \"feFuncG\",\n  fefuncr: \"feFuncR\",\n  fegaussianblur: \"feGaussianBlur\",\n  feimage: \"feImage\",\n  femerge: \"feMerge\",\n  femergenode: \"feMergeNode\",\n  femorphology: \"feMorphology\",\n  feoffset: \"feOffset\",\n  fepointlight: \"fePointLight\",\n  fespecularlighting: \"feSpecularLighting\",\n  fespotlight: \"feSpotLight\",\n  fetile: \"feTile\",\n  feturbulence: \"feTurbulence\",\n  foreignobject: \"foreignObject\",\n  glyphref: \"glyphRef\",\n  lineargradient: \"linearGradient\",\n  radialgradient: \"radialGradient\"\n};\nlet createdNodeSet = null;\nfunction diff(oldTree, newTree, replayer, rrnodeMirror = newTree.mirror || newTree.ownerDocument.mirror) {\n  oldTree = diffBeforeUpdatingChildren(\n    oldTree,\n    newTree,\n    replayer,\n    rrnodeMirror\n  );\n  diffChildren(oldTree, newTree, replayer, rrnodeMirror);\n  diffAfterUpdatingChildren(oldTree, newTree, replayer);\n}\nfunction diffBeforeUpdatingChildren(oldTree, newTree, replayer, rrnodeMirror) {\n  if (replayer.afterAppend && !createdNodeSet) {\n    createdNodeSet = /* @__PURE__ */ new WeakSet();\n    setTimeout(() => {\n      createdNodeSet = null;\n    }, 0);\n  }\n  if (!sameNodeType(oldTree, newTree)) {\n    const calibratedOldTree = createOrGetNode(\n      newTree,\n      replayer.mirror,\n      rrnodeMirror\n    );\n    oldTree.parentNode?.replaceChild(calibratedOldTree, oldTree);\n    oldTree = calibratedOldTree;\n  }\n  switch (newTree.RRNodeType) {\n    case NodeType$1.Document: {\n      if (!nodeMatching(oldTree, newTree, replayer.mirror, rrnodeMirror)) {\n        const newMeta = rrnodeMirror.getMeta(newTree);\n        if (newMeta) {\n          replayer.mirror.removeNodeFromMap(oldTree);\n          oldTree.close();\n          oldTree.open();\n          replayer.mirror.add(oldTree, newMeta);\n          createdNodeSet?.add(oldTree);\n        }\n      }\n      break;\n    }\n    case NodeType$1.Element: {\n      const oldElement = oldTree;\n      const newRRElement = newTree;\n      switch (newRRElement.tagName) {\n        case \"IFRAME\": {\n          const oldContentDocument = getIFrameContentDocument(\n            oldTree\n          );\n          if (!oldContentDocument) break;\n          diff(\n            oldContentDocument,\n            newTree.contentDocument,\n            replayer,\n            rrnodeMirror\n          );\n          break;\n        }\n      }\n      if (newRRElement.shadowRoot) {\n        if (!oldElement.shadowRoot) oldElement.attachShadow({ mode: \"open\" });\n        diffChildren(\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          oldElement.shadowRoot,\n          newRRElement.shadowRoot,\n          replayer,\n          rrnodeMirror\n        );\n      }\n      diffProps(oldElement, newRRElement, rrnodeMirror);\n      break;\n    }\n  }\n  return oldTree;\n}\nfunction diffAfterUpdatingChildren(oldTree, newTree, replayer) {\n  switch (newTree.RRNodeType) {\n    case NodeType$1.Document: {\n      const scrollData = newTree.scrollData;\n      scrollData && replayer.applyScroll(scrollData, true);\n      break;\n    }\n    case NodeType$1.Element: {\n      const oldElement = oldTree;\n      const newRRElement = newTree;\n      newRRElement.scrollData && replayer.applyScroll(newRRElement.scrollData, true);\n      newRRElement.inputData && replayer.applyInput(newRRElement.inputData);\n      switch (newRRElement.tagName) {\n        case \"AUDIO\":\n        case \"VIDEO\": {\n          const oldMediaElement = oldTree;\n          const newMediaRRElement = newRRElement;\n          if (newMediaRRElement.paused !== void 0)\n            newMediaRRElement.paused ? void oldMediaElement.pause() : void oldMediaElement.play();\n          if (newMediaRRElement.muted !== void 0)\n            oldMediaElement.muted = newMediaRRElement.muted;\n          if (newMediaRRElement.volume !== void 0)\n            oldMediaElement.volume = newMediaRRElement.volume;\n          if (newMediaRRElement.currentTime !== void 0)\n            oldMediaElement.currentTime = newMediaRRElement.currentTime;\n          if (newMediaRRElement.playbackRate !== void 0)\n            oldMediaElement.playbackRate = newMediaRRElement.playbackRate;\n          break;\n        }\n        case \"CANVAS\": {\n          const rrCanvasElement = newTree;\n          if (rrCanvasElement.rr_dataURL !== null) {\n            const image = document.createElement(\"img\");\n            image.onload = () => {\n              const ctx = oldElement.getContext(\"2d\");\n              if (ctx) {\n                ctx.drawImage(image, 0, 0, image.width, image.height);\n              }\n            };\n            image.src = rrCanvasElement.rr_dataURL;\n          }\n          rrCanvasElement.canvasMutations.forEach(\n            (canvasMutation2) => replayer.applyCanvas(\n              canvasMutation2.event,\n              canvasMutation2.mutation,\n              oldTree\n            )\n          );\n          break;\n        }\n        case \"STYLE\": {\n          const styleSheet = oldElement.sheet;\n          styleSheet && newTree.rules.forEach(\n            (data) => replayer.applyStyleSheetMutation(data, styleSheet)\n          );\n          break;\n        }\n      }\n      break;\n    }\n    case NodeType$1.Text:\n    case NodeType$1.Comment:\n    case NodeType$1.CDATA: {\n      if (oldTree.textContent !== newTree.data)\n        oldTree.textContent = newTree.data;\n      break;\n    }\n  }\n  if (createdNodeSet?.has(oldTree)) {\n    createdNodeSet.delete(oldTree);\n    replayer.afterAppend?.(oldTree, replayer.mirror.getId(oldTree));\n  }\n}\nfunction diffProps(oldTree, newTree, rrnodeMirror) {\n  const oldAttributes = oldTree.attributes;\n  const newAttributes = newTree.attributes;\n  for (const name in newAttributes) {\n    const newValue = newAttributes[name];\n    const sn = rrnodeMirror.getMeta(newTree);\n    if (sn?.isSVG && NAMESPACES[name])\n      oldTree.setAttributeNS(NAMESPACES[name], name, newValue);\n    else if (newTree.tagName === \"CANVAS\" && name === \"rr_dataURL\") {\n      const image = document.createElement(\"img\");\n      image.src = newValue;\n      image.onload = () => {\n        const ctx = oldTree.getContext(\"2d\");\n        if (ctx) {\n          ctx.drawImage(image, 0, 0, image.width, image.height);\n        }\n      };\n    } else if (newTree.tagName === \"IFRAME\" && name === \"srcdoc\") continue;\n    else {\n      try {\n        oldTree.setAttribute(name, newValue);\n      } catch (err) {\n        console.warn(err);\n      }\n    }\n  }\n  for (const { name } of Array.from(oldAttributes))\n    if (!(name in newAttributes)) oldTree.removeAttribute(name);\n  newTree.scrollLeft && (oldTree.scrollLeft = newTree.scrollLeft);\n  newTree.scrollTop && (oldTree.scrollTop = newTree.scrollTop);\n}\nfunction diffChildren(oldTree, newTree, replayer, rrnodeMirror) {\n  const oldChildren = Array.from(oldTree.childNodes);\n  const newChildren = newTree.childNodes;\n  if (oldChildren.length === 0 && newChildren.length === 0) return;\n  let oldStartIndex = 0, oldEndIndex = oldChildren.length - 1, newStartIndex = 0, newEndIndex = newChildren.length - 1;\n  let oldStartNode = oldChildren[oldStartIndex], oldEndNode = oldChildren[oldEndIndex], newStartNode = newChildren[newStartIndex], newEndNode = newChildren[newEndIndex];\n  let oldIdToIndex = void 0, indexInOld = void 0;\n  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n    if (oldStartNode === void 0) {\n      oldStartNode = oldChildren[++oldStartIndex];\n    } else if (oldEndNode === void 0) {\n      oldEndNode = oldChildren[--oldEndIndex];\n    } else if (\n      // same first node?\n      nodeMatching(oldStartNode, newStartNode, replayer.mirror, rrnodeMirror)\n    ) {\n      oldStartNode = oldChildren[++oldStartIndex];\n      newStartNode = newChildren[++newStartIndex];\n    } else if (\n      // same last node?\n      nodeMatching(oldEndNode, newEndNode, replayer.mirror, rrnodeMirror)\n    ) {\n      oldEndNode = oldChildren[--oldEndIndex];\n      newEndNode = newChildren[--newEndIndex];\n    } else if (\n      // is the first old node the same as the last new node?\n      nodeMatching(oldStartNode, newEndNode, replayer.mirror, rrnodeMirror)\n    ) {\n      try {\n        handleInsertBefore(oldTree, oldStartNode, oldEndNode.nextSibling);\n      } catch (e2) {\n        console.warn(e2);\n      }\n      oldStartNode = oldChildren[++oldStartIndex];\n      newEndNode = newChildren[--newEndIndex];\n    } else if (\n      // is the last old node the same as the first new node?\n      nodeMatching(oldEndNode, newStartNode, replayer.mirror, rrnodeMirror)\n    ) {\n      try {\n        handleInsertBefore(oldTree, oldEndNode, oldStartNode);\n      } catch (e2) {\n        console.warn(e2);\n      }\n      oldEndNode = oldChildren[--oldEndIndex];\n      newStartNode = newChildren[++newStartIndex];\n    } else {\n      if (!oldIdToIndex) {\n        oldIdToIndex = {};\n        for (let i2 = oldStartIndex; i2 <= oldEndIndex; i2++) {\n          const oldChild2 = oldChildren[i2];\n          if (oldChild2 && replayer.mirror.hasNode(oldChild2))\n            oldIdToIndex[replayer.mirror.getId(oldChild2)] = i2;\n        }\n      }\n      indexInOld = oldIdToIndex[rrnodeMirror.getId(newStartNode)];\n      const nodeToMove = oldChildren[indexInOld];\n      if (indexInOld !== void 0 && nodeToMove && nodeMatching(nodeToMove, newStartNode, replayer.mirror, rrnodeMirror)) {\n        try {\n          handleInsertBefore(oldTree, nodeToMove, oldStartNode);\n        } catch (e2) {\n          console.warn(e2);\n        }\n        oldChildren[indexInOld] = void 0;\n      } else {\n        const newNode = createOrGetNode(\n          newStartNode,\n          replayer.mirror,\n          rrnodeMirror\n        );\n        if (oldTree.nodeName === \"#document\" && oldStartNode && /**\n        * Special case 1: one document isn't allowed to have two doctype nodes at the same time, so we need to remove the old one first before inserting the new one.\n        * How this case happens: A parent document in the old tree already has a doctype node with an id e.g. #1. A new full snapshot rebuilds the replayer with a new doctype node with another id #2. According to the algorithm, the new doctype node will be inserted before the old one, which is not allowed by the Document standard.\n        */\n        (newNode.nodeType === newNode.DOCUMENT_TYPE_NODE && oldStartNode.nodeType === oldStartNode.DOCUMENT_TYPE_NODE || /**\n        * Special case 2: one document isn't allowed to have two HTMLElements at the same time, so we need to remove the old one first before inserting the new one.\n        * How this case happens: A mounted iframe element has an automatically created HTML element. We should delete it before inserting a serialized one. Otherwise, an error 'Only one element on document allowed' will be thrown.\n        */\n        newNode.nodeType === newNode.ELEMENT_NODE && oldStartNode.nodeType === oldStartNode.ELEMENT_NODE)) {\n          oldTree.removeChild(oldStartNode);\n          replayer.mirror.removeNodeFromMap(oldStartNode);\n          oldStartNode = oldChildren[++oldStartIndex];\n        }\n        try {\n          handleInsertBefore(oldTree, newNode, oldStartNode || null);\n        } catch (e2) {\n          console.warn(e2);\n        }\n      }\n      newStartNode = newChildren[++newStartIndex];\n    }\n  }\n  if (oldStartIndex > oldEndIndex) {\n    const referenceRRNode = newChildren[newEndIndex + 1];\n    let referenceNode = null;\n    if (referenceRRNode)\n      referenceNode = replayer.mirror.getNode(\n        rrnodeMirror.getId(referenceRRNode)\n      );\n    for (; newStartIndex <= newEndIndex; ++newStartIndex) {\n      const newNode = createOrGetNode(\n        newChildren[newStartIndex],\n        replayer.mirror,\n        rrnodeMirror\n      );\n      try {\n        handleInsertBefore(oldTree, newNode, referenceNode);\n      } catch (e2) {\n        console.warn(e2);\n      }\n    }\n  } else if (newStartIndex > newEndIndex) {\n    for (; oldStartIndex <= oldEndIndex; oldStartIndex++) {\n      const node = oldChildren[oldStartIndex];\n      if (!node || node.parentNode !== oldTree) continue;\n      try {\n        oldTree.removeChild(node);\n        replayer.mirror.removeNodeFromMap(node);\n      } catch (e2) {\n        console.warn(e2);\n      }\n    }\n  }\n  let oldChild = oldTree.firstChild;\n  let newChild = newTree.firstChild;\n  while (oldChild !== null && newChild !== null) {\n    diff(oldChild, newChild, replayer, rrnodeMirror);\n    oldChild = oldChild.nextSibling;\n    newChild = newChild.nextSibling;\n  }\n}\nfunction createOrGetNode(rrNode, domMirror, rrnodeMirror) {\n  const nodeId = rrnodeMirror.getId(rrNode);\n  const sn = rrnodeMirror.getMeta(rrNode);\n  let node = null;\n  if (nodeId > -1) node = domMirror.getNode(nodeId);\n  if (node !== null && sameNodeType(node, rrNode)) return node;\n  switch (rrNode.RRNodeType) {\n    case NodeType$1.Document:\n      node = new Document();\n      break;\n    case NodeType$1.DocumentType:\n      node = document.implementation.createDocumentType(\n        rrNode.name,\n        rrNode.publicId,\n        rrNode.systemId\n      );\n      break;\n    case NodeType$1.Element: {\n      let tagName = rrNode.tagName.toLowerCase();\n      tagName = SVGTagMap[tagName] || tagName;\n      if (sn && \"isSVG\" in sn && sn?.isSVG) {\n        node = document.createElementNS(NAMESPACES[\"svg\"], tagName);\n      } else node = document.createElement(rrNode.tagName);\n      break;\n    }\n    case NodeType$1.Text:\n      node = document.createTextNode(rrNode.data);\n      break;\n    case NodeType$1.Comment:\n      node = document.createComment(rrNode.data);\n      break;\n    case NodeType$1.CDATA:\n      node = document.createCDATASection(rrNode.data);\n      break;\n  }\n  if (sn) domMirror.add(node, { ...sn });\n  try {\n    createdNodeSet?.add(node);\n  } catch (e2) {\n  }\n  return node;\n}\nfunction sameNodeType(node1, node2) {\n  if (node1.nodeType !== node2.nodeType) return false;\n  return node1.nodeType !== node1.ELEMENT_NODE || node1.tagName.toUpperCase() === node2.tagName;\n}\nfunction nodeMatching(node1, node2, domMirror, rrdomMirror) {\n  const node1Id = domMirror.getId(node1);\n  const node2Id = rrdomMirror.getId(node2);\n  if (node1Id === -1 || node1Id !== node2Id) return false;\n  return sameNodeType(node1, node2);\n}\nfunction getInsertedStylesFromElement(styleElement) {\n  const elementCssRules = styleElement.sheet?.cssRules;\n  if (!elementCssRules || !elementCssRules.length) return;\n  const tempStyleSheet = new CSSStyleSheet();\n  tempStyleSheet.replaceSync(styleElement.innerText);\n  const innerTextStylesMap = {};\n  for (let i2 = 0; i2 < tempStyleSheet.cssRules.length; i2++) {\n    innerTextStylesMap[tempStyleSheet.cssRules[i2].cssText] = tempStyleSheet.cssRules[i2];\n  }\n  const insertedStylesStyleSheet = [];\n  for (let i2 = 0; i2 < elementCssRules?.length; i2++) {\n    const cssRuleText = elementCssRules[i2].cssText;\n    if (!innerTextStylesMap[cssRuleText]) {\n      insertedStylesStyleSheet.push({\n        index: i2,\n        cssRuleText\n      });\n    }\n  }\n  return insertedStylesStyleSheet;\n}\nfunction handleInsertBefore(oldTree, nodeToMove, insertBeforeNode) {\n  let insertedStyles;\n  if (nodeToMove.nodeName === \"STYLE\") {\n    insertedStyles = getInsertedStylesFromElement(\n      nodeToMove\n    );\n  }\n  oldTree.insertBefore(nodeToMove, insertBeforeNode);\n  if (insertedStyles && insertedStyles.length) {\n    insertedStyles.forEach(({ cssRuleText, index }) => {\n      nodeToMove.sheet?.insertRule(cssRuleText, index);\n    });\n  }\n}\nclass RRDocument extends BaseRRDocument {\n  constructor(mirror2) {\n    super();\n    __publicField(this, \"UNSERIALIZED_STARTING_ID\", -2);\n    __publicField(this, \"_unserializedId\", this.UNSERIALIZED_STARTING_ID);\n    __publicField(this, \"mirror\", createMirror());\n    __publicField(this, \"scrollData\", null);\n    if (mirror2) {\n      this.mirror = mirror2;\n    }\n  }\n  /**\n   * Every time the id is used, it will minus 1 automatically to avoid collisions.\n   */\n  get unserializedId() {\n    return this._unserializedId--;\n  }\n  createDocument(_namespace, _qualifiedName, _doctype) {\n    return new RRDocument();\n  }\n  createDocumentType(qualifiedName, publicId, systemId) {\n    const documentTypeNode = new RRDocumentType(\n      qualifiedName,\n      publicId,\n      systemId\n    );\n    documentTypeNode.ownerDocument = this;\n    return documentTypeNode;\n  }\n  createElement(tagName) {\n    const upperTagName = tagName.toUpperCase();\n    let element;\n    switch (upperTagName) {\n      case \"AUDIO\":\n      case \"VIDEO\":\n        element = new RRMediaElement(upperTagName);\n        break;\n      case \"IFRAME\":\n        element = new RRIFrameElement(upperTagName, this.mirror);\n        break;\n      case \"CANVAS\":\n        element = new RRCanvasElement(upperTagName);\n        break;\n      case \"STYLE\":\n        element = new RRStyleElement(upperTagName);\n        break;\n      default:\n        element = new RRElement(upperTagName);\n        break;\n    }\n    element.ownerDocument = this;\n    return element;\n  }\n  createComment(data) {\n    const commentNode = new RRComment(data);\n    commentNode.ownerDocument = this;\n    return commentNode;\n  }\n  createCDATASection(data) {\n    const sectionNode = new RRCDATASection(data);\n    sectionNode.ownerDocument = this;\n    return sectionNode;\n  }\n  createTextNode(data) {\n    const textNode = new RRText(data);\n    textNode.ownerDocument = this;\n    return textNode;\n  }\n  destroyTree() {\n    this.firstChild = null;\n    this.lastChild = null;\n    this.mirror.reset();\n  }\n  open() {\n    super.open();\n    this._unserializedId = this.UNSERIALIZED_STARTING_ID;\n  }\n}\nconst RRDocumentType = BaseRRDocumentType;\nclass RRElement extends BaseRRElement {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"inputData\", null);\n    __publicField(this, \"scrollData\", null);\n  }\n}\nclass RRMediaElement extends BaseRRMediaElement {\n}\nclass RRCanvasElement extends RRElement {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"rr_dataURL\", null);\n    __publicField(this, \"canvasMutations\", []);\n  }\n  /**\n   * This is a dummy implementation to distinguish RRCanvasElement from real HTMLCanvasElement.\n   */\n  getContext() {\n    return null;\n  }\n}\nclass RRStyleElement extends RRElement {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"rules\", []);\n  }\n}\nclass RRIFrameElement extends RRElement {\n  constructor(upperTagName, mirror2) {\n    super(upperTagName);\n    __publicField(this, \"contentDocument\", new RRDocument());\n    this.contentDocument.mirror = mirror2;\n  }\n}\nconst RRText = BaseRRText;\nconst RRComment = BaseRRComment;\nconst RRCDATASection = BaseRRCDATASection;\nfunction getValidTagName(element) {\n  if (element instanceof HTMLFormElement) {\n    return \"FORM\";\n  }\n  return element.tagName.toUpperCase();\n}\nfunction buildFromNode(node, rrdom, domMirror, parentRRNode) {\n  let rrNode;\n  switch (node.nodeType) {\n    case NodeType.DOCUMENT_NODE:\n      if (parentRRNode && parentRRNode.nodeName === \"IFRAME\")\n        rrNode = parentRRNode.contentDocument;\n      else {\n        rrNode = rrdom;\n        rrNode.compatMode = node.compatMode;\n      }\n      break;\n    case NodeType.DOCUMENT_TYPE_NODE: {\n      const documentType = node;\n      rrNode = rrdom.createDocumentType(\n        documentType.name,\n        documentType.publicId,\n        documentType.systemId\n      );\n      break;\n    }\n    case NodeType.ELEMENT_NODE: {\n      const elementNode = node;\n      const tagName = getValidTagName(elementNode);\n      rrNode = rrdom.createElement(tagName);\n      const rrElement = rrNode;\n      for (const { name, value } of Array.from(elementNode.attributes)) {\n        rrElement.attributes[name] = value;\n      }\n      elementNode.scrollLeft && (rrElement.scrollLeft = elementNode.scrollLeft);\n      elementNode.scrollTop && (rrElement.scrollTop = elementNode.scrollTop);\n      break;\n    }\n    case NodeType.TEXT_NODE:\n      rrNode = rrdom.createTextNode(node.textContent || \"\");\n      break;\n    case NodeType.CDATA_SECTION_NODE:\n      rrNode = rrdom.createCDATASection(node.data);\n      break;\n    case NodeType.COMMENT_NODE:\n      rrNode = rrdom.createComment(node.textContent || \"\");\n      break;\n    case NodeType.DOCUMENT_FRAGMENT_NODE:\n      rrNode = parentRRNode.attachShadow({ mode: \"open\" });\n      break;\n    default:\n      return null;\n  }\n  let sn = domMirror.getMeta(node);\n  if (rrdom instanceof RRDocument) {\n    if (!sn) {\n      sn = getDefaultSN(rrNode, rrdom.unserializedId);\n      domMirror.add(node, sn);\n    }\n    rrdom.mirror.add(rrNode, { ...sn });\n  }\n  return rrNode;\n}\nfunction buildFromDom(dom, domMirror = createMirror$1(), rrdom = new RRDocument()) {\n  function walk2(node, parentRRNode) {\n    const rrNode = buildFromNode(node, rrdom, domMirror, parentRRNode);\n    if (rrNode === null) return;\n    if (\n      // if the parentRRNode isn't a RRIFrameElement\n      parentRRNode?.nodeName !== \"IFRAME\" && // if node isn't a shadow root\n      node.nodeType !== NodeType.DOCUMENT_FRAGMENT_NODE\n    ) {\n      parentRRNode?.appendChild(rrNode);\n      rrNode.parentNode = parentRRNode;\n      rrNode.parentElement = parentRRNode;\n    }\n    if (node.nodeName === \"IFRAME\") {\n      const iframeDoc = getIFrameContentDocument(node);\n      iframeDoc && walk2(iframeDoc, rrNode);\n    } else if (node.nodeType === NodeType.DOCUMENT_NODE || node.nodeType === NodeType.ELEMENT_NODE || node.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {\n      if (node.nodeType === NodeType.ELEMENT_NODE && node.shadowRoot)\n        walk2(node.shadowRoot, rrNode);\n      node.childNodes.forEach((childNode) => walk2(childNode, rrNode));\n    }\n  }\n  walk2(dom, null);\n  return rrdom;\n}\nfunction createMirror() {\n  return new Mirror22();\n}\nclass Mirror22 {\n  constructor() {\n    __publicField(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n}\nfunction getDefaultSN(node, id) {\n  switch (node.RRNodeType) {\n    case NodeType$1.Document:\n      return {\n        id,\n        type: node.RRNodeType,\n        childNodes: []\n      };\n    case NodeType$1.DocumentType: {\n      const doctype = node;\n      return {\n        id,\n        type: node.RRNodeType,\n        name: doctype.name,\n        publicId: doctype.publicId,\n        systemId: doctype.systemId\n      };\n    }\n    case NodeType$1.Element:\n      return {\n        id,\n        type: node.RRNodeType,\n        tagName: node.tagName.toLowerCase(),\n        // In rrweb data, all tagNames are lowercase.\n        attributes: {},\n        childNodes: []\n      };\n    case NodeType$1.Text:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: node.textContent || \"\"\n      };\n    case NodeType$1.Comment:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: node.textContent || \"\"\n      };\n    case NodeType$1.CDATA:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: \"\"\n      };\n  }\n}\nfunction isNodeInLinkedList(n2) {\n  return \"__ln\" in n2;\n}\nclass DoubleLinkedList {\n  constructor() {\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n  }\n  get(position) {\n    if (position >= this.length) {\n      throw new Error(\"Position outside of list range\");\n    }\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n  addNode(n2) {\n    const node = {\n      value: n2,\n      previous: null,\n      next: null\n    };\n    n2.__ln = node;\n    if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {\n      const current = n2.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n2.previousSibling.__ln;\n      n2.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {\n      const current = n2.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n2.nextSibling.__ln;\n      n2.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    if (node.next === null) {\n      this.tail = node;\n    }\n    this.length++;\n  }\n  removeNode(n2) {\n    const current = n2.__ln;\n    if (!this.head) {\n      return;\n    }\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      } else {\n        this.tail = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      } else {\n        this.tail = current.previous;\n      }\n    }\n    if (n2.__ln) {\n      delete n2.__ln;\n    }\n    this.length--;\n  }\n}\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\nclass MutationBuffer {\n  constructor() {\n    this.frozen = false;\n    this.locked = false;\n    this.texts = [];\n    this.attributes = [];\n    this.attributeMap = /* @__PURE__ */ new WeakMap();\n    this.removes = [];\n    this.mapRemoves = [];\n    this.movedMap = {};\n    this.addedSet = /* @__PURE__ */ new Set();\n    this.movedSet = /* @__PURE__ */ new Set();\n    this.droppedSet = /* @__PURE__ */ new Set();\n    this.processMutations = (mutations) => {\n      mutations.forEach(this.processMutation);\n      this.emit();\n    };\n    this.emit = () => {\n      if (this.frozen || this.locked) {\n        return;\n      }\n      const adds = [];\n      const addedIds = /* @__PURE__ */ new Set();\n      const addList = new DoubleLinkedList();\n      const getNextId = (n2) => {\n        let ns = n2;\n        let nextId = IGNORED_NODE;\n        while (nextId === IGNORED_NODE) {\n          ns = ns && ns.nextSibling;\n          nextId = ns && this.mirror.getId(ns);\n        }\n        return nextId;\n      };\n      const pushAdd = (n2) => {\n        if (!n2.parentNode || !inDom(n2)) {\n          return;\n        }\n        const parentId = isShadowRoot(n2.parentNode) ? this.mirror.getId(getShadowHost(n2)) : this.mirror.getId(n2.parentNode);\n        const nextId = getNextId(n2);\n        if (parentId === -1 || nextId === -1) {\n          return addList.addNode(n2);\n        }\n        const sn = serializeNodeWithId(n2, {\n          doc: this.doc,\n          mirror: this.mirror,\n          blockClass: this.blockClass,\n          blockSelector: this.blockSelector,\n          maskAllText: this.maskAllText,\n          unblockSelector: this.unblockSelector,\n          maskTextClass: this.maskTextClass,\n          unmaskTextClass: this.unmaskTextClass,\n          maskTextSelector: this.maskTextSelector,\n          unmaskTextSelector: this.unmaskTextSelector,\n          skipChild: true,\n          newlyAddedElement: true,\n          inlineStylesheet: this.inlineStylesheet,\n          maskInputOptions: this.maskInputOptions,\n          maskAttributeFn: this.maskAttributeFn,\n          maskTextFn: this.maskTextFn,\n          maskInputFn: this.maskInputFn,\n          slimDOMOptions: this.slimDOMOptions,\n          dataURLOptions: this.dataURLOptions,\n          recordCanvas: this.recordCanvas,\n          inlineImages: this.inlineImages,\n          onSerialize: (currentN) => {\n            if (isSerializedIframe(currentN, this.mirror) && !isBlocked(\n              currentN,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            )) {\n              this.iframeManager.addIframe(currentN);\n            }\n            if (isSerializedStylesheet(currentN, this.mirror)) {\n              this.stylesheetManager.trackLinkElement(\n                currentN\n              );\n            }\n            if (hasShadowRoot(n2)) {\n              this.shadowDomManager.addShadowRoot(n2.shadowRoot, this.doc);\n            }\n          },\n          onIframeLoad: (iframe, childSn) => {\n            if (isBlocked(\n              iframe,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            )) {\n              return;\n            }\n            this.iframeManager.attachIframe(iframe, childSn);\n            if (iframe.contentWindow) {\n              this.canvasManager.addWindow(iframe.contentWindow);\n            }\n            this.shadowDomManager.observeAttachShadow(iframe);\n          },\n          onStylesheetLoad: (link, childSn) => {\n            this.stylesheetManager.attachLinkElement(link, childSn);\n          }\n        });\n        if (sn) {\n          adds.push({\n            parentId,\n            nextId,\n            node: sn\n          });\n          addedIds.add(sn.id);\n        }\n      };\n      while (this.mapRemoves.length) {\n        this.mirror.removeNodeFromMap(this.mapRemoves.shift());\n      }\n      for (const n2 of this.movedSet) {\n        if (isParentRemoved(this.removes, n2, this.mirror) && !this.movedSet.has(n2.parentNode)) {\n          continue;\n        }\n        pushAdd(n2);\n      }\n      for (const n2 of this.addedSet) {\n        if (!isAncestorInSet(this.droppedSet, n2) && !isParentRemoved(this.removes, n2, this.mirror)) {\n          pushAdd(n2);\n        } else if (isAncestorInSet(this.movedSet, n2)) {\n          pushAdd(n2);\n        } else {\n          this.droppedSet.add(n2);\n        }\n      }\n      let candidate = null;\n      while (addList.length) {\n        let node = null;\n        if (candidate) {\n          const parentId = this.mirror.getId(candidate.value.parentNode);\n          const nextId = getNextId(candidate.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = candidate;\n          }\n        }\n        if (!node) {\n          let tailNode = addList.tail;\n          while (tailNode) {\n            const _node = tailNode;\n            tailNode = tailNode.previous;\n            if (_node) {\n              const parentId = this.mirror.getId(_node.value.parentNode);\n              const nextId = getNextId(_node.value);\n              if (nextId === -1) continue;\n              else if (parentId !== -1) {\n                node = _node;\n                break;\n              } else {\n                const unhandledNode = _node.value;\n                if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                  const shadowHost = unhandledNode.parentNode.host;\n                  const parentId2 = this.mirror.getId(shadowHost);\n                  if (parentId2 !== -1) {\n                    node = _node;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (!node) {\n          while (addList.head) {\n            addList.removeNode(addList.head.value);\n          }\n          break;\n        }\n        candidate = node.previous;\n        addList.removeNode(node.value);\n        pushAdd(node.value);\n      }\n      const payload = {\n        texts: this.texts.map((text) => ({\n          id: this.mirror.getId(text.node),\n          value: text.value\n        })).filter((text) => !addedIds.has(text.id)).filter((text) => this.mirror.has(text.id)),\n        attributes: this.attributes.map((attribute) => {\n          const { attributes } = attribute;\n          if (typeof attributes.style === \"string\") {\n            const diffAsStr = JSON.stringify(attribute.styleDiff);\n            const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n            if (diffAsStr.length < attributes.style.length) {\n              if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                attributes.style = attribute.styleDiff;\n              }\n            }\n          }\n          return {\n            id: this.mirror.getId(attribute.node),\n            attributes\n          };\n        }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),\n        removes: this.removes,\n        adds\n      };\n      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n        return;\n      }\n      this.texts = [];\n      this.attributes = [];\n      this.attributeMap = /* @__PURE__ */ new WeakMap();\n      this.removes = [];\n      this.addedSet = /* @__PURE__ */ new Set();\n      this.movedSet = /* @__PURE__ */ new Set();\n      this.droppedSet = /* @__PURE__ */ new Set();\n      this.movedMap = {};\n      this.mutationCb(payload);\n    };\n    this.processMutation = (m) => {\n      if (isIgnored(m.target, this.mirror)) {\n        return;\n      }\n      switch (m.type) {\n        case \"characterData\": {\n          const value = m.target.textContent;\n          if (!isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            false\n          ) && value !== m.oldValue) {\n            this.texts.push({\n              value: needMaskingText(\n                m.target,\n                this.maskTextClass,\n                this.maskTextSelector,\n                this.unmaskTextClass,\n                this.unmaskTextSelector,\n                this.maskAllText\n              ) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n              node: m.target\n            });\n          }\n          break;\n        }\n        case \"attributes\": {\n          const target = m.target;\n          let attributeName = m.attributeName;\n          let value = m.target.getAttribute(attributeName);\n          if (attributeName === \"value\") {\n            const type = getInputType(target);\n            const tagName = target.tagName;\n            value = getInputValue(target, tagName, type);\n            const isInputMasked = shouldMaskInput({\n              maskInputOptions: this.maskInputOptions,\n              tagName,\n              type\n            });\n            const forceMask = needMaskingText(\n              m.target,\n              this.maskTextClass,\n              this.maskTextSelector,\n              this.unmaskTextClass,\n              this.unmaskTextSelector,\n              isInputMasked\n            );\n            value = maskInputValue({\n              isMasked: forceMask,\n              element: target,\n              value,\n              maskInputFn: this.maskInputFn\n            });\n          }\n          if (isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            false\n          ) || value === m.oldValue) {\n            return;\n          }\n          let item = this.attributeMap.get(m.target);\n          if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !this.keepIframeSrcFn(value)) {\n            const iframeDoc = getIFrameContentDocument(\n              target\n            );\n            if (!iframeDoc) {\n              attributeName = \"rr_src\";\n            } else {\n              return;\n            }\n          }\n          if (!item) {\n            item = {\n              node: m.target,\n              attributes: {},\n              styleDiff: {},\n              _unchangedStyles: {}\n            };\n            this.attributes.push(item);\n            this.attributeMap.set(m.target, item);\n          }\n          if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n            target.setAttribute(\"data-rr-is-password\", \"true\");\n          }\n          if (!ignoreAttribute(target.tagName, attributeName)) {\n            item.attributes[attributeName] = transformAttribute(\n              this.doc,\n              toLowerCase(target.tagName),\n              toLowerCase(attributeName),\n              value,\n              target,\n              this.maskAttributeFn\n            );\n            if (attributeName === \"style\") {\n              if (!this.unattachedDoc) {\n                try {\n                  this.unattachedDoc = document.implementation.createHTMLDocument();\n                } catch (e2) {\n                  this.unattachedDoc = this.doc;\n                }\n              }\n              const old = this.unattachedDoc.createElement(\"span\");\n              if (m.oldValue) {\n                old.setAttribute(\"style\", m.oldValue);\n              }\n              for (const pname of Array.from(target.style)) {\n                const newValue = target.style.getPropertyValue(pname);\n                const newPriority = target.style.getPropertyPriority(pname);\n                if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                  if (newPriority === \"\") {\n                    item.styleDiff[pname] = newValue;\n                  } else {\n                    item.styleDiff[pname] = [newValue, newPriority];\n                  }\n                } else {\n                  item._unchangedStyles[pname] = [newValue, newPriority];\n                }\n              }\n              for (const pname of Array.from(old.style)) {\n                if (target.style.getPropertyValue(pname) === \"\") {\n                  item.styleDiff[pname] = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n        case \"childList\": {\n          if (isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            true\n          )) {\n            return;\n          }\n          m.addedNodes.forEach((n2) => this.genAdds(n2, m.target));\n          m.removedNodes.forEach((n2) => {\n            const nodeId = this.mirror.getId(n2);\n            const parentId = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);\n            if (isBlocked(\n              m.target,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            ) || isIgnored(n2, this.mirror) || !isSerialized(n2, this.mirror)) {\n              return;\n            }\n            if (this.addedSet.has(n2)) {\n              deepDelete(this.addedSet, n2);\n              this.droppedSet.add(n2);\n            } else if (this.addedSet.has(m.target) && nodeId === -1) ;\n            else if (isAncestorRemoved(m.target, this.mirror)) ;\n            else if (this.movedSet.has(n2) && this.movedMap[moveKey(nodeId, parentId)]) {\n              deepDelete(this.movedSet, n2);\n            } else {\n              this.removes.push({\n                parentId,\n                id: nodeId,\n                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0\n              });\n            }\n            this.mapRemoves.push(n2);\n          });\n          break;\n        }\n      }\n    };\n    this.genAdds = (n2, target) => {\n      if (this.processedNodeManager.inOtherBuffer(n2, this)) return;\n      if (this.addedSet.has(n2) || this.movedSet.has(n2)) return;\n      if (this.mirror.hasNode(n2)) {\n        if (isIgnored(n2, this.mirror)) {\n          return;\n        }\n        this.movedSet.add(n2);\n        let targetId = null;\n        if (target && this.mirror.hasNode(target)) {\n          targetId = this.mirror.getId(target);\n        }\n        if (targetId && targetId !== -1) {\n          this.movedMap[moveKey(this.mirror.getId(n2), targetId)] = true;\n        }\n      } else {\n        this.addedSet.add(n2);\n        this.droppedSet.delete(n2);\n      }\n      if (!isBlocked(\n        n2,\n        this.blockClass,\n        this.blockSelector,\n        this.unblockSelector,\n        false\n      )) {\n        n2.childNodes.forEach((childN) => this.genAdds(childN));\n        if (hasShadowRoot(n2)) {\n          n2.shadowRoot.childNodes.forEach((childN) => {\n            this.processedNodeManager.add(childN, this);\n            this.genAdds(childN, n2);\n          });\n        }\n      }\n    };\n  }\n  init(options) {\n    [\n      \"mutationCb\",\n      \"blockClass\",\n      \"blockSelector\",\n      \"unblockSelector\",\n      \"maskAllText\",\n      \"maskTextClass\",\n      \"unmaskTextClass\",\n      \"maskTextSelector\",\n      \"unmaskTextSelector\",\n      \"inlineStylesheet\",\n      \"maskInputOptions\",\n      \"maskAttributeFn\",\n      \"maskTextFn\",\n      \"maskInputFn\",\n      \"keepIframeSrcFn\",\n      \"recordCanvas\",\n      \"inlineImages\",\n      \"slimDOMOptions\",\n      \"dataURLOptions\",\n      \"doc\",\n      \"mirror\",\n      \"iframeManager\",\n      \"stylesheetManager\",\n      \"shadowDomManager\",\n      \"canvasManager\",\n      \"processedNodeManager\"\n    ].forEach((key) => {\n      this[key] = options[key];\n    });\n  }\n  freeze() {\n    this.frozen = true;\n    this.canvasManager.freeze();\n  }\n  unfreeze() {\n    this.frozen = false;\n    this.canvasManager.unfreeze();\n    this.emit();\n  }\n  isFrozen() {\n    return this.frozen;\n  }\n  lock() {\n    this.locked = true;\n    this.canvasManager.lock();\n  }\n  unlock() {\n    this.locked = false;\n    this.canvasManager.unlock();\n    this.emit();\n  }\n  reset() {\n    this.shadowDomManager.reset();\n    this.canvasManager.reset();\n  }\n}\nfunction deepDelete(addsSet, n2) {\n  addsSet.delete(n2);\n  n2.childNodes.forEach((childN) => deepDelete(addsSet, childN));\n}\nfunction isParentRemoved(removes, n2, mirror2) {\n  if (removes.length === 0) return false;\n  return _isParentRemoved(removes, n2, mirror2);\n}\nfunction _isParentRemoved(removes, n2, mirror2) {\n  let node = n2.parentNode;\n  while (node) {\n    const parentId = mirror2.getId(node);\n    if (removes.some((r2) => r2.id === parentId)) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\nfunction isAncestorInSet(set, n2) {\n  if (set.size === 0) return false;\n  return _isAncestorInSet(set, n2);\n}\nfunction _isAncestorInSet(set, n2) {\n  const { parentNode } = n2;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return _isAncestorInSet(set, parentNode);\n}\nlet errorHandler;\nfunction registerErrorHandler(handler) {\n  errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n  errorHandler = void 0;\n}\nconst callbackWrapper = (cb) => {\n  if (!errorHandler) {\n    return cb;\n  }\n  const rrwebWrapped = (...rest) => {\n    try {\n      return cb(...rest);\n    } catch (error) {\n      if (errorHandler && errorHandler(error) === true) {\n        return () => {\n        };\n      }\n      throw error;\n    }\n  };\n  return rrwebWrapped;\n};\nconst mutationBuffers = [];\nfunction getEventTarget(event) {\n  try {\n    if (\"composedPath\" in event) {\n      const path = event.composedPath();\n      if (path.length) {\n        return path[0];\n      }\n    } else if (\"path\" in event && event.path.length) {\n      return event.path[0];\n    }\n  } catch {\n  }\n  return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  mutationBuffer.init(options);\n  let mutationObserverCtor = window.MutationObserver || /**\n  * Some websites may disable MutationObserver by removing it from the window object.\n  * If someone is using rrweb to build a browser extention or things like it, they\n  * could not change the website's code but can have an opportunity to inject some\n  * code before the website executing its JS logic.\n  * Then they can do this to store the native MutationObserver:\n  * window.__rrMutationObserver = MutationObserver\n  */\n  window.__rrMutationObserver;\n  const angularZoneSymbol = window?.Zone?.__symbol__?.(\"MutationObserver\");\n  if (angularZoneSymbol && window[angularZoneSymbol]) {\n    mutationObserverCtor = window[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(\n    callbackWrapper((mutations) => {\n      if (options.onMutation && options.onMutation(mutations) === false) {\n        return;\n      }\n      mutationBuffer.processMutations.bind(mutationBuffer)(mutations);\n    })\n  );\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\nfunction initMoveObserver({\n  mousemoveCb,\n  sampling,\n  doc,\n  mirror: mirror2\n}) {\n  if (sampling.mousemove === false) {\n    return () => {\n    };\n  }\n  const threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n  const callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n  let positions = [];\n  let timeBaseline;\n  const wrappedCb = throttle(\n    callbackWrapper(\n      (source) => {\n        const totalOffset = Date.now() - timeBaseline;\n        mousemoveCb(\n          positions.map((p) => {\n            p.timeOffset -= totalOffset;\n            return p;\n          }),\n          source\n        );\n        positions = [];\n        timeBaseline = null;\n      }\n    ),\n    callbackThreshold\n  );\n  const updatePosition = callbackWrapper(\n    throttle(\n      callbackWrapper((evt) => {\n        const target = getEventTarget(evt);\n        const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;\n        if (!timeBaseline) {\n          timeBaseline = nowTimestamp();\n        }\n        positions.push({\n          x: clientX,\n          y: clientY,\n          id: mirror2.getId(target),\n          timeOffset: nowTimestamp() - timeBaseline\n        });\n        wrappedCb(\n          typeof DragEvent !== \"undefined\" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove\n        );\n      }),\n      threshold,\n      {\n        trailing: false\n      }\n    )\n  );\n  const handlers = [\n    on(\"mousemove\", updatePosition, doc),\n    on(\"touchmove\", updatePosition, doc),\n    on(\"drag\", updatePosition, doc)\n  ];\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initMouseInteractionObserver({\n  mouseInteractionCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  if (sampling.mouseInteraction === false) {\n    return () => {\n    };\n  }\n  const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;\n  const handlers = [];\n  let currentPointerType = null;\n  const getHandler = (eventKey) => {\n    return (event) => {\n      const target = getEventTarget(event);\n      if (isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n        return;\n      }\n      let pointerType = null;\n      let thisEventKey = eventKey;\n      if (\"pointerType\" in event) {\n        switch (event.pointerType) {\n          case \"mouse\":\n            pointerType = PointerTypes.Mouse;\n            break;\n          case \"touch\":\n            pointerType = PointerTypes.Touch;\n            break;\n          case \"pen\":\n            pointerType = PointerTypes.Pen;\n            break;\n        }\n        if (pointerType === PointerTypes.Touch) {\n          if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n            thisEventKey = \"TouchStart\";\n          } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n            thisEventKey = \"TouchEnd\";\n          }\n        } else if (pointerType === PointerTypes.Pen) ;\n      } else if (legacy_isTouchEvent(event)) {\n        pointerType = PointerTypes.Touch;\n      }\n      if (pointerType !== null) {\n        currentPointerType = pointerType;\n        if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n          pointerType = null;\n        }\n      } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n        pointerType = currentPointerType;\n        currentPointerType = null;\n      }\n      const e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e2) {\n        return;\n      }\n      const id = mirror2.getId(target);\n      const { clientX, clientY } = e2;\n      callbackWrapper(mouseInteractionCb)({\n        type: MouseInteractions[thisEventKey],\n        id,\n        x: clientX,\n        y: clientY,\n        ...pointerType !== null && { pointerType }\n      });\n    };\n  };\n  Object.keys(MouseInteractions).filter(\n    (key) => Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false\n  ).forEach((eventKey) => {\n    let eventName = toLowerCase(eventKey);\n    const handler = getHandler(eventKey);\n    if (window.PointerEvent) {\n      switch (MouseInteractions[eventKey]) {\n        case MouseInteractions.MouseDown:\n        case MouseInteractions.MouseUp:\n          eventName = eventName.replace(\n            \"mouse\",\n            \"pointer\"\n          );\n          break;\n        case MouseInteractions.TouchStart:\n        case MouseInteractions.TouchEnd:\n          return;\n      }\n    }\n    handlers.push(on(eventName, handler, doc));\n  });\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initScrollObserver({\n  scrollCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  const updatePosition = callbackWrapper(\n    throttle(\n      callbackWrapper((evt) => {\n        const target = getEventTarget(evt);\n        if (!target || isBlocked(\n          target,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        )) {\n          return;\n        }\n        const id = mirror2.getId(target);\n        if (target === doc && doc.defaultView) {\n          const scrollLeftTop = getWindowScroll(doc.defaultView);\n          scrollCb({\n            id,\n            x: scrollLeftTop.left,\n            y: scrollLeftTop.top\n          });\n        } else {\n          scrollCb({\n            id,\n            x: target.scrollLeft,\n            y: target.scrollTop\n          });\n        }\n      }),\n      sampling.scroll || 100\n    )\n  );\n  return on(\"scroll\", updatePosition, doc);\n}\nfunction initViewportResizeObserver({ viewportResizeCb }, { win }) {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = callbackWrapper(\n    throttle(\n      callbackWrapper(() => {\n        const height = getWindowHeight();\n        const width = getWindowWidth();\n        if (lastH !== height || lastW !== width) {\n          viewportResizeCb({\n            width: Number(width),\n            height: Number(height)\n          });\n          lastH = height;\n          lastW = width;\n        }\n      }),\n      200\n    )\n  );\n  return on(\"resize\", updateDimension, win);\n}\nconst INPUT_TAGS = [\"INPUT\", \"TEXTAREA\", \"SELECT\"];\nconst lastInputValueMap = /* @__PURE__ */ new WeakMap();\nfunction initInputObserver({\n  inputCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  ignoreClass,\n  ignoreSelector,\n  maskInputOptions,\n  maskInputFn,\n  sampling,\n  userTriggeredOnInput,\n  maskTextClass,\n  unmaskTextClass,\n  maskTextSelector,\n  unmaskTextSelector\n}) {\n  function eventHandler(event) {\n    let target = getEventTarget(event);\n    const userTriggered = event.isTrusted;\n    const tagName = target && toUpperCase(target.tagName);\n    if (tagName === \"OPTION\") target = target.parentElement;\n    if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(\n      target,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      true\n    )) {\n      return;\n    }\n    const el = target;\n    if (el.classList.contains(ignoreClass) || ignoreSelector && el.matches(ignoreSelector)) {\n      return;\n    }\n    const type = getInputType(target);\n    let text = getInputValue(el, tagName, type);\n    let isChecked = false;\n    const isInputMasked = shouldMaskInput({\n      maskInputOptions,\n      tagName,\n      type\n    });\n    const forceMask = needMaskingText(\n      target,\n      maskTextClass,\n      maskTextSelector,\n      unmaskTextClass,\n      unmaskTextSelector,\n      isInputMasked\n    );\n    if (type === \"radio\" || type === \"checkbox\") {\n      isChecked = target.checked;\n    }\n    text = maskInputValue({\n      isMasked: forceMask,\n      element: target,\n      value: text,\n      maskInputFn\n    });\n    cbWithDedup(\n      target,\n      userTriggeredOnInput ? { text, isChecked, userTriggered } : { text, isChecked }\n    );\n    const name = target.name;\n    if (type === \"radio\" && name && isChecked) {\n      doc.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`).forEach((el2) => {\n        if (el2 !== target) {\n          const text2 = maskInputValue({\n            // share mask behavior of `target`\n            isMasked: forceMask,\n            element: el2,\n            value: getInputValue(el2, tagName, type),\n            maskInputFn\n          });\n          cbWithDedup(\n            el2,\n            userTriggeredOnInput ? { text: text2, isChecked: !isChecked, userTriggered: false } : { text: text2, isChecked: !isChecked }\n          );\n        }\n      });\n    }\n  }\n  function cbWithDedup(target, v2) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {\n      lastInputValueMap.set(target, v2);\n      const id = mirror2.getId(target);\n      callbackWrapper(inputCb)({\n        ...v2,\n        id\n      });\n    }\n  }\n  const events = sampling.input === \"last\" ? [\"change\"] : [\"input\", \"change\"];\n  const handlers = events.map(\n    (eventName) => on(eventName, callbackWrapper(eventHandler), doc)\n  );\n  const currentWindow = doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  }\n  const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(\n    currentWindow.HTMLInputElement.prototype,\n    \"value\"\n  );\n  const hookProperties = [\n    [currentWindow.HTMLInputElement.prototype, \"value\"],\n    [currentWindow.HTMLInputElement.prototype, \"checked\"],\n    [currentWindow.HTMLSelectElement.prototype, \"value\"],\n    [currentWindow.HTMLTextAreaElement.prototype, \"value\"],\n    // Some UI library use selectedIndex to set select value\n    [currentWindow.HTMLSelectElement.prototype, \"selectedIndex\"],\n    [currentWindow.HTMLOptionElement.prototype, \"selected\"]\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map(\n        (p) => hookSetter(\n          p[0],\n          p[1],\n          {\n            set() {\n              callbackWrapper(eventHandler)({\n                target: this,\n                isTrusted: false\n                // userTriggered to false as this could well be programmatic\n              });\n            }\n          },\n          false,\n          currentWindow\n        )\n      )\n    );\n  }\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction getNestedCSSRulePositions(rule) {\n  const positions = [];\n  function recurse(childRule, pos) {\n    if (hasNestedCSSRule(\"CSSGroupingRule\") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule(\"CSSMediaRule\") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule(\"CSSSupportsRule\") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule(\"CSSConditionRule\") && childRule.parentRule instanceof CSSConditionRule) {\n      const rules2 = Array.from(\n        childRule.parentRule.cssRules\n      );\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    } else if (childRule.parentStyleSheet) {\n      const rules2 = Array.from(childRule.parentStyleSheet.cssRules);\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    }\n    return pos;\n  }\n  return recurse(rule, positions);\n}\nfunction getIdAndStyleId(sheet, mirror2, styleMirror) {\n  let id, styleId;\n  if (!sheet) return {};\n  if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);\n  else styleId = styleMirror.getId(sheet);\n  return {\n    styleId,\n    id\n  };\n}\nfunction initStyleSheetObserver({ styleSheetRuleCb, mirror: mirror2, stylesheetManager }, { win }) {\n  if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n    return () => {\n    };\n  }\n  const insertRule = win.CSSStyleSheet.prototype.insertRule;\n  win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [rule, index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(\n          thisArg,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            adds: [{ rule, index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n  win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(\n          thisArg,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            removes: [{ index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  let replace;\n  if (win.CSSStyleSheet.prototype.replace) {\n    replace = win.CSSStyleSheet.prototype.replace;\n    win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n      apply: callbackWrapper(\n        (target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(\n            thisArg,\n            mirror2,\n            stylesheetManager.styleMirror\n          );\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replace: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        }\n      )\n    });\n  }\n  let replaceSync;\n  if (win.CSSStyleSheet.prototype.replaceSync) {\n    replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n    win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n      apply: callbackWrapper(\n        (target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(\n            thisArg,\n            mirror2,\n            stylesheetManager.styleMirror\n          );\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replaceSync: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        }\n      )\n    });\n  }\n  const supportedNestedCSSRuleTypes = {};\n  if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n  } else {\n    if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n    }\n    if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n    }\n    if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n    }\n  }\n  const unmodifiedFunctions = {};\n  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n    unmodifiedFunctions[typeKey] = {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      insertRule: type.prototype.insertRule,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      deleteRule: type.prototype.deleteRule\n    };\n    type.prototype.insertRule = new Proxy(\n      unmodifiedFunctions[typeKey].insertRule,\n      {\n        apply: callbackWrapper(\n          (target, thisArg, argumentsList) => {\n            const [rule, index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(\n              thisArg.parentStyleSheet,\n              mirror2,\n              stylesheetManager.styleMirror\n            );\n            if (id && id !== -1 || styleId && styleId !== -1) {\n              styleSheetRuleCb({\n                id,\n                styleId,\n                adds: [\n                  {\n                    rule,\n                    index: [\n                      ...getNestedCSSRulePositions(thisArg),\n                      index || 0\n                      // defaults to 0\n                    ]\n                  }\n                ]\n              });\n            }\n            return target.apply(thisArg, argumentsList);\n          }\n        )\n      }\n    );\n    type.prototype.deleteRule = new Proxy(\n      unmodifiedFunctions[typeKey].deleteRule,\n      {\n        apply: callbackWrapper(\n          (target, thisArg, argumentsList) => {\n            const [index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(\n              thisArg.parentStyleSheet,\n              mirror2,\n              stylesheetManager.styleMirror\n            );\n            if (id && id !== -1 || styleId && styleId !== -1) {\n              styleSheetRuleCb({\n                id,\n                styleId,\n                removes: [\n                  { index: [...getNestedCSSRulePositions(thisArg), index] }\n                ]\n              });\n            }\n            return target.apply(thisArg, argumentsList);\n          }\n        )\n      }\n    );\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleSheet.prototype.insertRule = insertRule;\n    win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n    replace && (win.CSSStyleSheet.prototype.replace = replace);\n    replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n    });\n  });\n}\nfunction initAdoptedStyleSheetObserver({\n  mirror: mirror2,\n  stylesheetManager\n}, host) {\n  let hostId = null;\n  if (host.nodeName === \"#document\") hostId = mirror2.getId(host);\n  else hostId = mirror2.getId(host.host);\n  const patchTarget = host.nodeName === \"#document\" ? host.defaultView?.Document : host.ownerDocument?.defaultView?.ShadowRoot;\n  const originalPropertyDescriptor = patchTarget?.prototype ? Object.getOwnPropertyDescriptor(\n    patchTarget?.prototype,\n    \"adoptedStyleSheets\"\n  ) : void 0;\n  if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)\n    return () => {\n    };\n  Object.defineProperty(host, \"adoptedStyleSheets\", {\n    configurable: originalPropertyDescriptor.configurable,\n    enumerable: originalPropertyDescriptor.enumerable,\n    get() {\n      return originalPropertyDescriptor.get?.call(this);\n    },\n    set(sheets) {\n      const result = originalPropertyDescriptor.set?.call(this, sheets);\n      if (hostId !== null && hostId !== -1) {\n        try {\n          stylesheetManager.adoptStyleSheets(sheets, hostId);\n        } catch (e2) {\n        }\n      }\n      return result;\n    }\n  });\n  return callbackWrapper(() => {\n    Object.defineProperty(host, \"adoptedStyleSheets\", {\n      configurable: originalPropertyDescriptor.configurable,\n      enumerable: originalPropertyDescriptor.enumerable,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      get: originalPropertyDescriptor.get,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      set: originalPropertyDescriptor.set\n    });\n  });\n}\nfunction initStyleDeclarationObserver({\n  styleDeclarationCb,\n  mirror: mirror2,\n  ignoreCSSAttributes,\n  stylesheetManager\n}, { win }) {\n  const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n  win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [property, value, priority] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return setProperty.apply(thisArg, [property, value, priority]);\n        }\n        const { id, styleId } = getIdAndStyleId(\n          thisArg.parentRule?.parentStyleSheet,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            set: {\n              property,\n              value,\n              priority\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n  win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [property] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return removeProperty.apply(thisArg, [property]);\n        }\n        const { id, styleId } = getIdAndStyleId(\n          thisArg.parentRule?.parentStyleSheet,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            remove: {\n              property\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n  });\n}\nfunction initMediaInteractionObserver({\n  mediaInteractionCb,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  mirror: mirror2,\n  sampling,\n  doc\n}) {\n  const handler = callbackWrapper(\n    (type) => throttle(\n      callbackWrapper((event) => {\n        const target = getEventTarget(event);\n        if (!target || isBlocked(\n          target,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        )) {\n          return;\n        }\n        const { currentTime, volume, muted, playbackRate } = target;\n        mediaInteractionCb({\n          type,\n          id: mirror2.getId(target),\n          currentTime,\n          volume,\n          muted,\n          playbackRate\n        });\n      }),\n      sampling.media || 500\n    )\n  );\n  const handlers = [\n    on(\"play\", handler(MediaInteractions.Play), doc),\n    on(\"pause\", handler(MediaInteractions.Pause), doc),\n    on(\"seeked\", handler(MediaInteractions.Seeked), doc),\n    on(\"volumechange\", handler(MediaInteractions.VolumeChange), doc),\n    on(\"ratechange\", handler(MediaInteractions.RateChange), doc)\n  ];\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initFontObserver({ fontCb, doc }) {\n  const win = doc.defaultView;\n  if (!win) {\n    return () => {\n    };\n  }\n  const handlers = [];\n  const fontMap = /* @__PURE__ */ new WeakMap();\n  const originalFontFace = win.FontFace;\n  win.FontFace = function FontFace2(family, source, descriptors) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== \"string\",\n      descriptors,\n      fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n    });\n    return fontFace;\n  };\n  const restoreHandler = patch(\n    doc.fonts,\n    \"add\",\n    function(original) {\n      return function(fontFace) {\n        setTimeout$1(\n          callbackWrapper(() => {\n            const p = fontMap.get(fontFace);\n            if (p) {\n              fontCb(p);\n              fontMap.delete(fontFace);\n            }\n          }),\n          0\n        );\n        return original.apply(this, [fontFace]);\n      };\n    }\n  );\n  handlers.push(() => {\n    win.FontFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initSelectionObserver(param) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    selectionCb\n  } = param;\n  let collapsed = true;\n  const updateSelection = callbackWrapper(() => {\n    const selection = doc.getSelection();\n    if (!selection || collapsed && selection?.isCollapsed) return;\n    collapsed = selection.isCollapsed || false;\n    const ranges = [];\n    const count = selection.rangeCount || 0;\n    for (let i2 = 0; i2 < count; i2++) {\n      const range = selection.getRangeAt(i2);\n      const { startContainer, startOffset, endContainer, endOffset } = range;\n      const blocked = isBlocked(\n        startContainer,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        true\n      ) || isBlocked(\n        endContainer,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        true\n      );\n      if (blocked) continue;\n      ranges.push({\n        start: mirror2.getId(startContainer),\n        startOffset,\n        end: mirror2.getId(endContainer),\n        endOffset\n      });\n    }\n    selectionCb({ ranges });\n  });\n  updateSelection();\n  return on(\"selectionchange\", updateSelection);\n}\nfunction initCustomElementObserver({\n  doc,\n  customElementCb\n}) {\n  const win = doc.defaultView;\n  if (!win || !win.customElements) return () => {\n  };\n  const restoreHandler = patch(\n    win.customElements,\n    \"define\",\n    function(original) {\n      return function(name, constructor, options) {\n        try {\n          customElementCb({\n            define: {\n              name\n            }\n          });\n        } catch (e2) {\n        }\n        return original.apply(this, [name, constructor, options]);\n      };\n    }\n  );\n  return restoreHandler;\n}\nfunction initObservers(o2, _hooks = {}) {\n  const currentWindow = o2.doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n    };\n  }\n  let mutationObserver;\n  if (o2.recordDOM) {\n    mutationObserver = initMutationObserver(o2, o2.doc);\n  }\n  const mousemoveHandler = initMoveObserver(o2);\n  const mouseInteractionHandler = initMouseInteractionObserver(o2);\n  const scrollHandler = initScrollObserver(o2);\n  const viewportResizeHandler = initViewportResizeObserver(o2, {\n    win: currentWindow\n  });\n  const inputHandler = initInputObserver(o2);\n  const mediaInteractionHandler = initMediaInteractionObserver(o2);\n  let styleSheetObserver = () => {\n  };\n  let adoptedStyleSheetObserver = () => {\n  };\n  let styleDeclarationObserver = () => {\n  };\n  let fontObserver = () => {\n  };\n  if (o2.recordDOM) {\n    styleSheetObserver = initStyleSheetObserver(o2, { win: currentWindow });\n    adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);\n    styleDeclarationObserver = initStyleDeclarationObserver(o2, {\n      win: currentWindow\n    });\n    if (o2.collectFonts) {\n      fontObserver = initFontObserver(o2);\n    }\n  }\n  const selectionObserver = initSelectionObserver(o2);\n  const customElementObserver = initCustomElementObserver(o2);\n  const pluginHandlers = [];\n  for (const plugin of o2.plugins) {\n    pluginHandlers.push(\n      plugin.observer(plugin.callback, currentWindow, plugin.options)\n    );\n  }\n  return callbackWrapper(() => {\n    mutationBuffers.forEach((b) => b.reset());\n    mutationObserver?.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    adoptedStyleSheetObserver();\n    styleDeclarationObserver();\n    fontObserver();\n    selectionObserver();\n    customElementObserver();\n    pluginHandlers.forEach((h) => h());\n  });\n}\nfunction hasNestedCSSRule(prop) {\n  return typeof window[prop] !== \"undefined\";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n  return Boolean(\n    typeof window[prop] !== \"undefined\" && // Note: Generally, this check _shouldn't_ be necessary\n    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here\n    window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype\n  );\n}\nclass CrossOriginIframeMirror {\n  constructor(generateIdFn) {\n    this.generateIdFn = generateIdFn;\n    this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n    this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n  }\n  getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n    const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n    let id = idToRemoteIdMap.get(remoteId);\n    if (!id) {\n      id = this.generateIdFn();\n      idToRemoteIdMap.set(remoteId, id);\n      remoteIdToIdMap.set(id, remoteId);\n    }\n    return id;\n  }\n  getIds(iframe, remoteId) {\n    const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return remoteId.map(\n      (id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap)\n    );\n  }\n  getRemoteId(iframe, id, map) {\n    const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n    if (typeof id !== \"number\") return id;\n    const remoteId = remoteIdToIdMap.get(id);\n    if (!remoteId) return -1;\n    return remoteId;\n  }\n  getRemoteIds(iframe, ids) {\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));\n  }\n  reset(iframe) {\n    if (!iframe) {\n      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n      this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n      return;\n    }\n    this.iframeIdToRemoteIdMap.delete(iframe);\n    this.iframeRemoteIdToIdMap.delete(iframe);\n  }\n  getIdToRemoteIdMap(iframe) {\n    let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n    if (!idToRemoteIdMap) {\n      idToRemoteIdMap = /* @__PURE__ */ new Map();\n      this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n    }\n    return idToRemoteIdMap;\n  }\n  getRemoteIdToIdMap(iframe) {\n    let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n    if (!remoteIdToIdMap) {\n      remoteIdToIdMap = /* @__PURE__ */ new Map();\n      this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n    }\n    return remoteIdToIdMap;\n  }\n}\nclass IframeManagerNoop {\n  constructor() {\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n  }\n  addIframe() {\n  }\n  addLoadListener() {\n  }\n  attachIframe() {\n  }\n}\nclass IframeManager {\n  constructor(options) {\n    this.iframes = /* @__PURE__ */ new WeakMap();\n    this.crossOriginIframeMap = /* @__PURE__ */ new WeakMap();\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n    this.mutationCb = options.mutationCb;\n    this.wrappedEmit = options.wrappedEmit;\n    this.stylesheetManager = options.stylesheetManager;\n    this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(\n      this.stylesheetManager.styleMirror.generateId.bind(\n        this.stylesheetManager.styleMirror\n      )\n    );\n    this.mirror = options.mirror;\n    if (this.recordCrossOriginIframes) {\n      window.addEventListener(\"message\", this.handleMessage.bind(this));\n    }\n  }\n  addIframe(iframeEl) {\n    this.iframes.set(iframeEl, true);\n    if (iframeEl.contentWindow)\n      this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n  }\n  addLoadListener(cb) {\n    this.loadListener = cb;\n  }\n  attachIframe(iframeEl, childSn) {\n    this.mutationCb({\n      adds: [\n        {\n          parentId: this.mirror.getId(iframeEl),\n          nextId: null,\n          node: childSn\n        }\n      ],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true\n    });\n    if (this.recordCrossOriginIframes)\n      iframeEl.contentWindow?.addEventListener(\n        \"message\",\n        this.handleMessage.bind(this)\n      );\n    this.loadListener?.(iframeEl);\n    const iframeDoc = getIFrameContentDocument(iframeEl);\n    if (iframeDoc && iframeDoc.adoptedStyleSheets && iframeDoc.adoptedStyleSheets.length > 0)\n      this.stylesheetManager.adoptStyleSheets(\n        iframeDoc.adoptedStyleSheets,\n        this.mirror.getId(iframeDoc)\n      );\n  }\n  handleMessage(message) {\n    const crossOriginMessageEvent = message;\n    if (crossOriginMessageEvent.data.type !== \"rrweb\" || // To filter out the rrweb messages which are forwarded by some sites.\n    crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)\n      return;\n    const iframeSourceWindow = message.source;\n    if (!iframeSourceWindow) return;\n    const iframeEl = this.crossOriginIframeMap.get(message.source);\n    if (!iframeEl) return;\n    const transformedEvent = this.transformCrossOriginEvent(\n      iframeEl,\n      crossOriginMessageEvent.data.event\n    );\n    if (transformedEvent)\n      this.wrappedEmit(\n        transformedEvent,\n        crossOriginMessageEvent.data.isCheckout\n      );\n  }\n  transformCrossOriginEvent(iframeEl, e2) {\n    switch (e2.type) {\n      case EventType.FullSnapshot: {\n        this.crossOriginIframeMirror.reset(iframeEl);\n        this.crossOriginIframeStyleMirror.reset(iframeEl);\n        this.replaceIdOnNode(e2.data.node, iframeEl);\n        const rootId = e2.data.node.id;\n        this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n        this.patchRootIdOnNode(e2.data.node, rootId);\n        return {\n          timestamp: e2.timestamp,\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.Mutation,\n            adds: [\n              {\n                parentId: this.mirror.getId(iframeEl),\n                nextId: null,\n                node: e2.data.node\n              }\n            ],\n            removes: [],\n            texts: [],\n            attributes: [],\n            isAttachIframe: true\n          }\n        };\n      }\n      case EventType.Meta:\n      case EventType.Load:\n      case EventType.DomContentLoaded: {\n        return false;\n      }\n      case EventType.Plugin: {\n        return e2;\n      }\n      case EventType.Custom: {\n        this.replaceIds(\n          e2.data.payload,\n          iframeEl,\n          [\"id\", \"parentId\", \"previousId\", \"nextId\"]\n        );\n        return e2;\n      }\n      case EventType.IncrementalSnapshot: {\n        switch (e2.data.source) {\n          case IncrementalSource.Mutation: {\n            e2.data.adds.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\n                \"parentId\",\n                \"nextId\",\n                \"previousId\"\n              ]);\n              this.replaceIdOnNode(n2.node, iframeEl);\n              const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\n              rootId && this.patchRootIdOnNode(n2.node, rootId);\n            });\n            e2.data.removes.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"parentId\", \"id\"]);\n            });\n            e2.data.attributes.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"id\"]);\n            });\n            e2.data.texts.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"id\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.Drag:\n          case IncrementalSource.TouchMove:\n          case IncrementalSource.MouseMove: {\n            e2.data.positions.forEach((p) => {\n              this.replaceIds(p, iframeEl, [\"id\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.ViewportResize: {\n            return false;\n          }\n          case IncrementalSource.MediaInteraction:\n          case IncrementalSource.MouseInteraction:\n          case IncrementalSource.Scroll:\n          case IncrementalSource.CanvasMutation:\n          case IncrementalSource.Input: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            return e2;\n          }\n          case IncrementalSource.StyleSheetRule:\n          case IncrementalSource.StyleDeclaration: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            this.replaceStyleIds(e2.data, iframeEl, [\"styleId\"]);\n            return e2;\n          }\n          case IncrementalSource.Font: {\n            return e2;\n          }\n          case IncrementalSource.Selection: {\n            e2.data.ranges.forEach((range) => {\n              this.replaceIds(range, iframeEl, [\"start\", \"end\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.AdoptedStyleSheet: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            this.replaceStyleIds(e2.data, iframeEl, [\"styleIds\"]);\n            e2.data.styles?.forEach((style) => {\n              this.replaceStyleIds(style, iframeEl, [\"styleId\"]);\n            });\n            return e2;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  replace(iframeMirror, obj, iframeEl, keys) {\n    for (const key of keys) {\n      if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\") continue;\n      if (Array.isArray(obj[key])) {\n        obj[key] = iframeMirror.getIds(\n          iframeEl,\n          obj[key]\n        );\n      } else {\n        obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n      }\n    }\n    return obj;\n  }\n  replaceIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n  }\n  replaceStyleIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n  }\n  replaceIdOnNode(node, iframeEl) {\n    this.replaceIds(node, iframeEl, [\"id\", \"rootId\"]);\n    if (\"childNodes\" in node) {\n      node.childNodes.forEach((child) => {\n        this.replaceIdOnNode(child, iframeEl);\n      });\n    }\n  }\n  patchRootIdOnNode(node, rootId) {\n    if (node.type !== NodeType$2.Document && !node.rootId) node.rootId = rootId;\n    if (\"childNodes\" in node) {\n      node.childNodes.forEach((child) => {\n        this.patchRootIdOnNode(child, rootId);\n      });\n    }\n  }\n}\nclass ShadowDomManagerNoop {\n  init() {\n  }\n  addShadowRoot() {\n  }\n  observeAttachShadow() {\n  }\n  reset() {\n  }\n}\nclass ShadowDomManager {\n  constructor(options) {\n    this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    this.restoreHandlers = [];\n    this.mutationCb = options.mutationCb;\n    this.scrollCb = options.scrollCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n    this.init();\n  }\n  init() {\n    this.reset();\n    this.patchAttachShadow(Element, document);\n  }\n  addShadowRoot(shadowRoot, doc) {\n    if (!isNativeShadowDom(shadowRoot)) return;\n    if (this.shadowDoms.has(shadowRoot)) return;\n    this.shadowDoms.add(shadowRoot);\n    this.bypassOptions.canvasManager.addShadowRoot(shadowRoot);\n    const observer = initMutationObserver(\n      {\n        ...this.bypassOptions,\n        doc,\n        mutationCb: this.mutationCb,\n        mirror: this.mirror,\n        shadowDomManager: this\n      },\n      shadowRoot\n    );\n    this.restoreHandlers.push(() => observer.disconnect());\n    this.restoreHandlers.push(\n      initScrollObserver({\n        ...this.bypassOptions,\n        scrollCb: this.scrollCb,\n        // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813\n        // scroll is not allowed to pass the boundary, so we need to listen the shadow document\n        doc: shadowRoot,\n        mirror: this.mirror\n      })\n    );\n    setTimeout$1(() => {\n      if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0)\n        this.bypassOptions.stylesheetManager.adoptStyleSheets(\n          shadowRoot.adoptedStyleSheets,\n          this.mirror.getId(shadowRoot.host)\n        );\n      this.restoreHandlers.push(\n        initAdoptedStyleSheetObserver(\n          {\n            mirror: this.mirror,\n            stylesheetManager: this.bypassOptions.stylesheetManager\n          },\n          shadowRoot\n        )\n      );\n    }, 0);\n  }\n  /**\n   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.\n   */\n  observeAttachShadow(iframeElement) {\n    const iframeDoc = getIFrameContentDocument(iframeElement);\n    const iframeWindow = getIFrameContentWindow(iframeElement);\n    if (!iframeDoc || !iframeWindow) return;\n    this.patchAttachShadow(\n      iframeWindow.Element,\n      iframeDoc\n    );\n  }\n  /**\n   * Patch 'attachShadow' to observe newly added shadow doms.\n   */\n  patchAttachShadow(element, doc) {\n    const manager = this;\n    this.restoreHandlers.push(\n      patch(\n        element.prototype,\n        \"attachShadow\",\n        function(original) {\n          return function(option) {\n            const shadowRoot = original.call(this, option);\n            if (this.shadowRoot && inDom(this))\n              manager.addShadowRoot(this.shadowRoot, doc);\n            return shadowRoot;\n          };\n        }\n      )\n    );\n  }\n  reset() {\n    this.restoreHandlers.forEach((handler) => {\n      try {\n        handler();\n      } catch (e2) {\n      }\n    });\n    this.restoreHandlers = [];\n    this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    this.bypassOptions.canvasManager.resetShadowRoots();\n  }\n}\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (var i$1 = 0; i$1 < chars.length; i$1++) {\n  lookup[chars.charCodeAt(i$1)] = i$1;\n}\nvar encode = function(arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = \"\";\n  for (i2 = 0; i2 < len; i2 += 3) {\n    base64 += chars[bytes[i2] >> 2];\n    base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];\n    base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];\n    base64 += chars[bytes[i2 + 2] & 63];\n  }\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + \"=\";\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + \"==\";\n  }\n  return base64;\n};\nvar decode = function(base64) {\n  var bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;\n  if (base64[base64.length - 1] === \"=\") {\n    bufferLength--;\n    if (base64[base64.length - 2] === \"=\") {\n      bufferLength--;\n    }\n  }\n  var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n  for (i2 = 0; i2 < len; i2 += 4) {\n    encoded1 = lookup[base64.charCodeAt(i2)];\n    encoded2 = lookup[base64.charCodeAt(i2 + 1)];\n    encoded3 = lookup[base64.charCodeAt(i2 + 2)];\n    encoded4 = lookup[base64.charCodeAt(i2 + 3)];\n    bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n  return arraybuffer;\n};\nconst canvasVarMap = /* @__PURE__ */ new Map();\nfunction variableListFor$1(ctx, ctor) {\n  let contextMap = canvasVarMap.get(ctx);\n  if (!contextMap) {\n    contextMap = /* @__PURE__ */ new Map();\n    canvasVarMap.set(ctx, contextMap);\n  }\n  if (!contextMap.has(ctor)) {\n    contextMap.set(ctor, []);\n  }\n  return contextMap.get(ctor);\n}\nconst saveWebGLVar = (value, win, ctx) => {\n  if (!value || !(isInstanceOfWebGLObject(value, win) || typeof value === \"object\"))\n    return;\n  const name = value.constructor.name;\n  const list = variableListFor$1(ctx, name);\n  let index = list.indexOf(value);\n  if (index === -1) {\n    index = list.length;\n    list.push(value);\n  }\n  return index;\n};\nfunction serializeArg(value, win, ctx) {\n  if (value instanceof Array) {\n    return value.map((arg) => serializeArg(arg, win, ctx));\n  } else if (value === null) {\n    return value;\n  } else if (value instanceof Float32Array || value instanceof Float64Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Int16Array || value instanceof Int8Array || value instanceof Uint8ClampedArray) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [Object.values(value)]\n    };\n  } else if (\n    // SharedArrayBuffer disabled on most browsers due to spectre.\n    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer\n    // value instanceof SharedArrayBuffer ||\n    value instanceof ArrayBuffer\n  ) {\n    const name = value.constructor.name;\n    const base64 = encode(value);\n    return {\n      rr_type: name,\n      base64\n    };\n  } else if (value instanceof DataView) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [\n        serializeArg(value.buffer, win, ctx),\n        value.byteOffset,\n        value.byteLength\n      ]\n    };\n  } else if (value instanceof HTMLImageElement) {\n    const name = value.constructor.name;\n    const { src } = value;\n    return {\n      rr_type: name,\n      src\n    };\n  } else if (value instanceof HTMLCanvasElement) {\n    const name = \"HTMLImageElement\";\n    const src = value.toDataURL();\n    return {\n      rr_type: name,\n      src\n    };\n  } else if (value instanceof ImageData) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [serializeArg(value.data, win, ctx), value.width, value.height]\n    };\n  } else if (isInstanceOfWebGLObject(value, win) || typeof value === \"object\") {\n    const name = value.constructor.name;\n    const index = saveWebGLVar(value, win, ctx);\n    return {\n      rr_type: name,\n      index\n    };\n  }\n  return value;\n}\nconst serializeArgs = (args, win, ctx) => {\n  return args.map((arg) => serializeArg(arg, win, ctx));\n};\nconst isInstanceOfWebGLObject = (value, win) => {\n  const webGLConstructorNames = [\n    \"WebGLActiveInfo\",\n    \"WebGLBuffer\",\n    \"WebGLFramebuffer\",\n    \"WebGLProgram\",\n    \"WebGLRenderbuffer\",\n    \"WebGLShader\",\n    \"WebGLShaderPrecisionFormat\",\n    \"WebGLTexture\",\n    \"WebGLUniformLocation\",\n    \"WebGLVertexArrayObject\",\n    // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.\n    \"WebGLVertexArrayObjectOES\"\n  ];\n  const supportedWebGLConstructorNames = webGLConstructorNames.filter(\n    (name) => typeof win[name] === \"function\"\n  );\n  return Boolean(\n    supportedWebGLConstructorNames.find(\n      (name) => value instanceof win[name]\n    )\n  );\n};\nfunction initCanvas2DMutationObserver(cb, win, blockClass2, blockSelector, unblockSelector) {\n  const handlers = [];\n  const props2D = Object.getOwnPropertyNames(\n    win.CanvasRenderingContext2D.prototype\n  );\n  for (const prop of props2D) {\n    try {\n      if (typeof win.CanvasRenderingContext2D.prototype[prop] !== \"function\") {\n        continue;\n      }\n      const restoreHandler = patch(\n        win.CanvasRenderingContext2D.prototype,\n        prop,\n        function(original) {\n          return function(...args) {\n            if (!isBlocked(\n              this.canvas,\n              blockClass2,\n              blockSelector,\n              unblockSelector,\n              true\n            )) {\n              setTimeout$1(() => {\n                const recordArgs = serializeArgs(args, win, this);\n                cb(this.canvas, {\n                  type: CanvasContext[\"2D\"],\n                  property: prop,\n                  args: recordArgs\n                });\n              }, 0);\n            }\n            return original.apply(this, args);\n          };\n        }\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter(\n        win.CanvasRenderingContext2D.prototype,\n        prop,\n        {\n          set(v2) {\n            cb(this.canvas, {\n              type: CanvasContext[\"2D\"],\n              property: prop,\n              args: [v2],\n              setter: true\n            });\n          }\n        }\n      );\n      handlers.push(hookHandler);\n    }\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\nfunction getNormalizedContextName(contextType) {\n  return contextType === \"experimental-webgl\" ? \"webgl\" : contextType;\n}\nfunction initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, setPreserveDrawingBufferToTrue) {\n  const handlers = [];\n  try {\n    const restoreHandler = patch(\n      win.HTMLCanvasElement.prototype,\n      \"getContext\",\n      function(original) {\n        return function(contextType, ...args) {\n          if (!isBlocked(this, blockClass, blockSelector, unblockSelector, true)) {\n            const ctxName = getNormalizedContextName(contextType);\n            if (!(\"__context\" in this)) this.__context = ctxName;\n            if (setPreserveDrawingBufferToTrue && [\"webgl\", \"webgl2\"].includes(ctxName)) {\n              if (args[0] && typeof args[0] === \"object\") {\n                const contextAttributes = args[0];\n                if (!contextAttributes.preserveDrawingBuffer) {\n                  contextAttributes.preserveDrawingBuffer = true;\n                }\n              } else {\n                args.splice(0, 1, {\n                  preserveDrawingBuffer: true\n                });\n              }\n            }\n          }\n          return original.apply(this, [contextType, ...args]);\n        };\n      }\n    );\n    handlers.push(restoreHandler);\n  } catch {\n    console.error(\"failed to patch HTMLCanvasElement.prototype.getContext\");\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\nfunction patchGLPrototype(prototype, type, cb, blockClass2, blockSelector, unblockSelector, _mirror2, win) {\n  const handlers = [];\n  const props = Object.getOwnPropertyNames(prototype);\n  for (const prop of props) {\n    if (\n      //prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky\n      [\n        \"isContextLost\",\n        \"canvas\",\n        \"drawingBufferWidth\",\n        \"drawingBufferHeight\"\n      ].includes(prop)\n    ) {\n      continue;\n    }\n    try {\n      if (typeof prototype[prop] !== \"function\") {\n        continue;\n      }\n      const restoreHandler = patch(\n        prototype,\n        prop,\n        function(original) {\n          return function(...args) {\n            const result = original.apply(this, args);\n            saveWebGLVar(result, win, this);\n            if (\"tagName\" in this.canvas && !isBlocked(\n              this.canvas,\n              blockClass2,\n              blockSelector,\n              unblockSelector,\n              true\n            )) {\n              const recordArgs = serializeArgs(args, win, this);\n              const mutation = {\n                type,\n                property: prop,\n                args: recordArgs\n              };\n              cb(this.canvas, mutation);\n            }\n            return result;\n          };\n        }\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter(prototype, prop, {\n        set(v2) {\n          cb(this.canvas, {\n            type,\n            property: prop,\n            args: [v2],\n            setter: true\n          });\n        }\n      });\n      handlers.push(hookHandler);\n    }\n  }\n  return handlers;\n}\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass2, blockSelector, unblockSelector, mirror2) {\n  const handlers = [];\n  handlers.push(\n    ...patchGLPrototype(\n      win.WebGLRenderingContext.prototype,\n      CanvasContext.WebGL,\n      cb,\n      blockClass2,\n      blockSelector,\n      unblockSelector,\n      mirror2,\n      win\n    )\n  );\n  if (typeof win.WebGL2RenderingContext !== \"undefined\") {\n    handlers.push(\n      ...patchGLPrototype(\n        win.WebGL2RenderingContext.prototype,\n        CanvasContext.WebGL2,\n        cb,\n        blockClass2,\n        blockSelector,\n        unblockSelector,\n        mirror2,\n        win\n      )\n    );\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\nconst r$1 = `for(var e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",t=\"undefined\"==typeof Uint8Array?[]:new Uint8Array(256),a=0;a<64;a++)t[e.charCodeAt(a)]=a;var n=function(t){var a,n=new Uint8Array(t),r=n.length,s=\"\";for(a=0;a<r;a+=3)s+=e[n[a]>>2],s+=e[(3&n[a])<<4|n[a+1]>>4],s+=e[(15&n[a+1])<<2|n[a+2]>>6],s+=e[63&n[a+2]];return r%3==2?s=s.substring(0,s.length-1)+\"=\":r%3==1&&(s=s.substring(0,s.length-2)+\"==\"),s};const r=new Map,s=new Map;const i=self;i.onmessage=async function(e){if(!(\"OffscreenCanvas\"in globalThis))return i.postMessage({id:e.data.id});{const{id:t,bitmap:a,width:o,height:f,maxCanvasSize:c,dataURLOptions:g}=e.data,u=async function(e,t,a){const r=e+\"-\"+t;if(\"OffscreenCanvas\"in globalThis){if(s.has(r))return s.get(r);const i=new OffscreenCanvas(e,t);i.getContext(\"2d\");const o=await i.convertToBlob(a),f=await o.arrayBuffer(),c=n(f);return s.set(r,c),c}return\"\"}(o,f,g),[h,d]=function(e,t,a){if(!a)return[e,t];const[n,r]=a;if(e<=n&&t<=r)return[e,t];let s=e,i=t;return s>n&&(i=Math.floor(n*t/e),s=n),i>r&&(s=Math.floor(r*e/t),i=r),[s,i]}(o,f,c),l=new OffscreenCanvas(h,d),w=l.getContext(\"bitmaprenderer\"),p=h===o&&d===f?a:await createImageBitmap(a,{resizeWidth:h,resizeHeight:d,resizeQuality:\"low\"});w.transferFromImageBitmap(p),a.close();const y=await l.convertToBlob(g),v=y.type,b=await y.arrayBuffer(),m=n(b);if(p.close(),!r.has(t)&&await u===m)return r.set(t,m),i.postMessage({id:t});if(r.get(t)===m)return i.postMessage({id:t});i.postMessage({id:t,type:v,base64:m,width:o,height:f}),r.set(t,m)}};`;\nfunction t$1() {\n  const t2 = new Blob([r$1]);\n  return URL.createObjectURL(t2);\n}\nclass CanvasManagerNoop {\n  reset() {\n  }\n  freeze() {\n  }\n  unfreeze() {\n  }\n  lock() {\n  }\n  unlock() {\n  }\n  snapshot() {\n  }\n  addWindow() {\n  }\n  addShadowRoot() {\n  }\n  resetShadowRoots() {\n  }\n}\nclass CanvasManager {\n  constructor(options) {\n    this.pendingCanvasMutations = /* @__PURE__ */ new Map();\n    this.rafStamps = { latestId: 0, invokeId: null };\n    this.shadowDoms = /* @__PURE__ */ new Set();\n    this.windowsSet = /* @__PURE__ */ new WeakSet();\n    this.windows = [];\n    this.restoreHandlers = [];\n    this.frozen = false;\n    this.locked = false;\n    this.snapshotInProgressMap = /* @__PURE__ */ new Map();\n    this.worker = null;\n    this.lastSnapshotTime = 0;\n    this.processMutation = (target, mutation) => {\n      const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;\n      if (newFrame || !this.rafStamps.invokeId)\n        this.rafStamps.invokeId = this.rafStamps.latestId;\n      if (!this.pendingCanvasMutations.has(target)) {\n        this.pendingCanvasMutations.set(target, []);\n      }\n      this.pendingCanvasMutations.get(target).push(mutation);\n    };\n    const {\n      sampling = \"all\",\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maxCanvasSize,\n      recordCanvas,\n      dataURLOptions,\n      errorHandler: errorHandler2\n    } = options;\n    this.mutationCb = options.mutationCb;\n    this.mirror = options.mirror;\n    this.options = options;\n    if (errorHandler2) {\n      registerErrorHandler(errorHandler2);\n    }\n    if (recordCanvas && typeof sampling === \"number\" || options.enableManualSnapshot) {\n      this.worker = this.initFPSWorker();\n    }\n    this.addWindow(win);\n    if (options.enableManualSnapshot) {\n      return;\n    }\n    callbackWrapper(() => {\n      if (recordCanvas && sampling === \"all\") {\n        this.startRAFTimestamping();\n        this.startPendingCanvasMutationFlusher();\n      }\n      if (recordCanvas && typeof sampling === \"number\") {\n        this.initCanvasFPSObserver(\n          sampling,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          maxCanvasSize,\n          {\n            dataURLOptions\n          }\n        );\n      }\n    })();\n  }\n  reset() {\n    this.pendingCanvasMutations.clear();\n    this.restoreHandlers.forEach((handler) => {\n      try {\n        handler();\n      } catch (e2) {\n      }\n    });\n    this.restoreHandlers = [];\n    this.windowsSet = /* @__PURE__ */ new WeakSet();\n    this.windows = [];\n    this.shadowDoms = /* @__PURE__ */ new Set();\n    this.worker?.terminate();\n    this.worker = null;\n    this.snapshotInProgressMap = /* @__PURE__ */ new Map();\n  }\n  freeze() {\n    this.frozen = true;\n  }\n  unfreeze() {\n    this.frozen = false;\n  }\n  lock() {\n    this.locked = true;\n  }\n  unlock() {\n    this.locked = false;\n  }\n  addWindow(win) {\n    const {\n      sampling = \"all\",\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      recordCanvas,\n      enableManualSnapshot\n    } = this.options;\n    if (this.windowsSet.has(win)) return;\n    if (enableManualSnapshot) {\n      this.windowsSet.add(win);\n      this.windows.push(new WeakRef(win));\n      return;\n    }\n    callbackWrapper(() => {\n      if (recordCanvas && sampling === \"all\") {\n        this.initCanvasMutationObserver(\n          win,\n          blockClass,\n          blockSelector,\n          unblockSelector\n        );\n      }\n      if (recordCanvas && typeof sampling === \"number\") {\n        const canvasContextReset = initCanvasContextObserver(\n          win,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        );\n        this.restoreHandlers.push(() => {\n          canvasContextReset();\n        });\n      }\n    })();\n    this.windowsSet.add(win);\n    this.windows.push(new WeakRef(win));\n  }\n  addShadowRoot(shadowRoot) {\n    this.shadowDoms.add(new WeakRef(shadowRoot));\n  }\n  resetShadowRoots() {\n    this.shadowDoms = /* @__PURE__ */ new Set();\n  }\n  initFPSWorker() {\n    const worker = new Worker(t$1());\n    worker.onmessage = (e2) => {\n      const data = e2.data;\n      const { id } = data;\n      this.snapshotInProgressMap.set(id, false);\n      if (!(\"base64\" in data)) return;\n      const { base64, type, width, height } = data;\n      this.mutationCb({\n        id,\n        type: CanvasContext[\"2D\"],\n        commands: [\n          {\n            property: \"clearRect\",\n            // wipe canvas\n            args: [0, 0, width, height]\n          },\n          {\n            property: \"drawImage\",\n            // draws (semi-transparent) image\n            args: [\n              {\n                rr_type: \"ImageBitmap\",\n                args: [\n                  {\n                    rr_type: \"Blob\",\n                    data: [{ rr_type: \"ArrayBuffer\", base64 }],\n                    type\n                  }\n                ]\n              },\n              0,\n              0,\n              // The below args are needed if we enforce a max size, we want to\n              // retain the original size when drawing the image (which should be smaller)\n              width,\n              height\n            ]\n          }\n        ]\n      });\n    };\n    return worker;\n  }\n  initCanvasFPSObserver(fps, blockClass, blockSelector, unblockSelector, maxCanvasSize, options) {\n    const rafId = this.takeSnapshot(\n      false,\n      fps,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maxCanvasSize,\n      options.dataURLOptions\n    );\n    this.restoreHandlers.push(() => {\n      cancelAnimationFrame(rafId);\n    });\n  }\n  initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector) {\n    const canvasContextReset = initCanvasContextObserver(\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      false\n    );\n    const canvas2DReset = initCanvas2DMutationObserver(\n      this.processMutation.bind(this),\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector\n    );\n    const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(\n      this.processMutation.bind(this),\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      this.mirror\n    );\n    this.restoreHandlers.push(() => {\n      canvasContextReset();\n      canvas2DReset();\n      canvasWebGL1and2Reset();\n    });\n  }\n  snapshot(canvasElement) {\n    const { options } = this;\n    const rafId = this.takeSnapshot(\n      true,\n      options.sampling === \"all\" ? 2 : options.sampling || 2,\n      options.blockClass,\n      options.blockSelector,\n      options.unblockSelector,\n      options.maxCanvasSize,\n      options.dataURLOptions,\n      canvasElement\n    );\n    this.restoreHandlers.push(() => {\n      cancelAnimationFrame(rafId);\n    });\n  }\n  takeSnapshot(isManualSnapshot, fps, blockClass, blockSelector, unblockSelector, maxCanvasSize, dataURLOptions, canvasElement) {\n    const timeBetweenSnapshots = 1e3 / fps;\n    let rafId;\n    const getCanvas = (canvasElement2) => {\n      if (canvasElement2) {\n        return [canvasElement2];\n      }\n      const matchedCanvas = [];\n      const searchCanvas = (root) => {\n        root.querySelectorAll(\"canvas\").forEach((canvas) => {\n          if (!isBlocked(canvas, blockClass, blockSelector, unblockSelector, true)) {\n            matchedCanvas.push(canvas);\n          }\n        });\n      };\n      for (const item of this.windows) {\n        const window2 = item.deref();\n        let _document;\n        try {\n          _document = window2 && window2.document;\n        } catch {\n        }\n        if (_document) {\n          searchCanvas(_document);\n        }\n      }\n      for (const item of this.shadowDoms) {\n        const shadowRoot = item.deref();\n        if (shadowRoot) {\n          searchCanvas(shadowRoot);\n        }\n      }\n      return matchedCanvas;\n    };\n    const takeCanvasSnapshots = (timestamp) => {\n      if (!this.windows.length) {\n        return;\n      }\n      if (this.lastSnapshotTime && timestamp - this.lastSnapshotTime < timeBetweenSnapshots) {\n        rafId = onRequestAnimationFrame(takeCanvasSnapshots);\n        return;\n      }\n      this.lastSnapshotTime = timestamp;\n      getCanvas(canvasElement).forEach((canvas) => {\n        if (!this.mirror.hasNode(canvas)) {\n          return;\n        }\n        const id = this.mirror.getId(canvas);\n        if (this.snapshotInProgressMap.get(id)) return;\n        if (!canvas.width || !canvas.height) return;\n        this.snapshotInProgressMap.set(id, true);\n        if (!isManualSnapshot && [\"webgl\", \"webgl2\"].includes(canvas.__context)) {\n          const context = canvas.getContext(canvas.__context);\n          if (context?.getContextAttributes()?.preserveDrawingBuffer === false) {\n            context.clear(context.COLOR_BUFFER_BIT);\n          }\n        }\n        createImageBitmap(canvas).then((bitmap) => {\n          this.worker?.postMessage(\n            {\n              id,\n              bitmap,\n              width: canvas.width,\n              height: canvas.height,\n              dataURLOptions,\n              maxCanvasSize\n            },\n            [bitmap]\n          );\n        }).catch((error) => {\n          callbackWrapper(() => {\n            throw error;\n          })();\n        });\n      });\n      if (!isManualSnapshot) {\n        rafId = onRequestAnimationFrame(takeCanvasSnapshots);\n      }\n    };\n    rafId = onRequestAnimationFrame(takeCanvasSnapshots);\n    return rafId;\n  }\n  startPendingCanvasMutationFlusher() {\n    onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n  startRAFTimestamping() {\n    const setLatestRAFTimestamp = (timestamp) => {\n      this.rafStamps.latestId = timestamp;\n      onRequestAnimationFrame(setLatestRAFTimestamp);\n    };\n    onRequestAnimationFrame(setLatestRAFTimestamp);\n  }\n  flushPendingCanvasMutations() {\n    this.pendingCanvasMutations.forEach(\n      (_values, canvas) => {\n        const id = this.mirror.getId(canvas);\n        this.flushPendingCanvasMutationFor(canvas, id);\n      }\n    );\n    onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n  flushPendingCanvasMutationFor(canvas, id) {\n    if (this.frozen || this.locked) {\n      return;\n    }\n    const valuesWithType = this.pendingCanvasMutations.get(canvas);\n    if (!valuesWithType || id === -1) return;\n    const values = valuesWithType.map((value) => {\n      const { type: type2, ...rest } = value;\n      return rest;\n    });\n    const { type } = valuesWithType[0];\n    this.mutationCb({ id, type, commands: values });\n    this.pendingCanvasMutations.delete(canvas);\n  }\n}\nclass StylesheetManager {\n  constructor(options) {\n    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n    this.styleMirror = new StyleSheetMirror();\n    this.mutationCb = options.mutationCb;\n    this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n  }\n  attachLinkElement(linkEl, childSn) {\n    if (\"_cssText\" in childSn.attributes)\n      this.mutationCb({\n        adds: [],\n        removes: [],\n        texts: [],\n        attributes: [\n          {\n            id: childSn.id,\n            attributes: childSn.attributes\n          }\n        ]\n      });\n    this.trackLinkElement(linkEl);\n  }\n  trackLinkElement(linkEl) {\n    if (this.trackedLinkElements.has(linkEl)) return;\n    this.trackedLinkElements.add(linkEl);\n    this.trackStylesheetInLinkElement(linkEl);\n  }\n  adoptStyleSheets(sheets, hostId) {\n    if (sheets.length === 0) return;\n    const adoptedStyleSheetData = {\n      id: hostId,\n      styleIds: []\n    };\n    const styles = [];\n    for (const sheet of sheets) {\n      let styleId;\n      if (!this.styleMirror.has(sheet)) {\n        styleId = this.styleMirror.add(sheet);\n        styles.push({\n          styleId,\n          rules: Array.from(sheet.rules || CSSRule, (r2, index) => ({\n            rule: stringifyRule(r2),\n            index\n          }))\n        });\n      } else styleId = this.styleMirror.getId(sheet);\n      adoptedStyleSheetData.styleIds.push(styleId);\n    }\n    if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n    this.adoptedStyleSheetCb(adoptedStyleSheetData);\n  }\n  reset() {\n    this.styleMirror.reset();\n    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n  }\n  // TODO: take snapshot on stylesheet reload by applying event listener\n  trackStylesheetInLinkElement(_linkEl) {\n  }\n}\nclass ProcessedNodeManager {\n  constructor() {\n    this.nodeMap = /* @__PURE__ */ new WeakMap();\n    this.active = false;\n  }\n  inOtherBuffer(node, thisBuffer) {\n    const buffers = this.nodeMap.get(node);\n    return buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer);\n  }\n  add(node, buffer) {\n    if (!this.active) {\n      this.active = true;\n      onRequestAnimationFrame(() => {\n        this.nodeMap = /* @__PURE__ */ new WeakMap();\n        this.active = false;\n      });\n    }\n    this.nodeMap.set(node, (this.nodeMap.get(node) || /* @__PURE__ */ new Set()).add(buffer));\n  }\n  destroy() {\n  }\n}\nlet wrappedEmit;\nlet _wrappedEmit;\nlet _takeFullSnapshot;\ntry {\n  if (Array.from([1], (x) => x * 2)[0] !== 2) {\n    const cleanFrame = document.createElement(\"iframe\");\n    document.body.appendChild(cleanFrame);\n    Array.from = cleanFrame.contentWindow?.Array.from || Array.from;\n    document.body.removeChild(cleanFrame);\n  }\n} catch (err) {\n  console.debug(\"Unable to override Array.from\", err);\n}\nconst mirror = createMirror$2();\nfunction record(options = {}) {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    ignoreClass = \"rr-ignore\",\n    ignoreSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskAttributeFn,\n    maskInputFn,\n    maskTextFn,\n    maxCanvasSize = null,\n    packFn,\n    sampling = {},\n    dataURLOptions = {},\n    mousemoveWait,\n    recordDOM = true,\n    recordCanvas = false,\n    recordCrossOriginIframes = false,\n    recordAfter = options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\",\n    userTriggeredOnInput = false,\n    collectFonts = false,\n    inlineImages = false,\n    plugins,\n    keepIframeSrcFn = () => false,\n    ignoreCSSAttributes = /* @__PURE__ */ new Set([]),\n    errorHandler: errorHandler2,\n    onMutation,\n    getCanvasManager\n  } = options;\n  registerErrorHandler(errorHandler2);\n  const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n  let passEmitsToParent = false;\n  if (!inEmittingFrame) {\n    try {\n      if (window.parent.document) {\n        passEmitsToParent = false;\n      }\n    } catch (e2) {\n      passEmitsToParent = true;\n    }\n  }\n  if (inEmittingFrame && !emit) {\n    throw new Error(\"emit function is required\");\n  }\n  if (!inEmittingFrame && !passEmitsToParent) {\n    return () => {\n    };\n  }\n  if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {\n    sampling.mousemove = mousemoveWait;\n  }\n  mirror.reset();\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true,\n    radio: true,\n    checkbox: true\n  } : _maskInputOptions !== void 0 ? _maskInputOptions : {};\n  const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n    script: true,\n    comment: true,\n    headFavicon: true,\n    headWhitespace: true,\n    headMetaSocial: true,\n    headMetaRobots: true,\n    headMetaHttpEquiv: true,\n    headMetaVerification: true,\n    // the following are off for slimDOMOptions === true,\n    // as they destroy some (hidden) info:\n    headMetaAuthorship: _slimDOMOptions === \"all\",\n    headMetaDescKeywords: _slimDOMOptions === \"all\"\n  } : _slimDOMOptions ? _slimDOMOptions : {};\n  polyfill$1();\n  let lastFullSnapshotEvent;\n  let incrementalSnapshotCount = 0;\n  const eventProcessor = (e2) => {\n    for (const plugin of plugins || []) {\n      if (plugin.eventProcessor) {\n        e2 = plugin.eventProcessor(e2);\n      }\n    }\n    if (packFn && // Disable packing events which will be emitted to parent frames.\n    !passEmitsToParent) {\n      e2 = packFn(e2);\n    }\n    return e2;\n  };\n  wrappedEmit = (r2, isCheckout) => {\n    const e2 = r2;\n    e2.timestamp = nowTimestamp();\n    if (mutationBuffers[0]?.isFrozen() && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {\n      mutationBuffers.forEach((buf) => buf.unfreeze());\n    }\n    if (inEmittingFrame) {\n      emit?.(eventProcessor(e2), isCheckout);\n    } else if (passEmitsToParent) {\n      const message = {\n        type: \"rrweb\",\n        event: eventProcessor(e2),\n        origin: window.location.origin,\n        isCheckout\n      };\n      window.parent.postMessage(message, \"*\");\n    }\n    if (e2.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e2;\n      incrementalSnapshotCount = 0;\n    } else if (e2.type === EventType.IncrementalSnapshot) {\n      if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {\n        return;\n      }\n      incrementalSnapshotCount++;\n      const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime = checkoutEveryNms && lastFullSnapshotEvent && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot2(true);\n      }\n    }\n  };\n  _wrappedEmit = wrappedEmit;\n  const wrappedMutationEmit = (m) => {\n    wrappedEmit({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.Mutation,\n        ...m\n      }\n    });\n  };\n  const wrappedScrollEmit = (p) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.Scroll,\n      ...p\n    }\n  });\n  const wrappedCanvasMutationEmit = (p) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.CanvasMutation,\n      ...p\n    }\n  });\n  const wrappedAdoptedStyleSheetEmit = (a2) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.AdoptedStyleSheet,\n      ...a2\n    }\n  });\n  const stylesheetManager = new StylesheetManager({\n    mutationCb: wrappedMutationEmit,\n    adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n  });\n  const iframeManager = typeof __RRWEB_EXCLUDE_IFRAME__ === \"boolean\" && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop() : new IframeManager({\n    mirror,\n    mutationCb: wrappedMutationEmit,\n    stylesheetManager,\n    recordCrossOriginIframes,\n    wrappedEmit\n  });\n  for (const plugin of plugins || []) {\n    if (plugin.getMirror)\n      plugin.getMirror({\n        nodeMirror: mirror,\n        crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n        crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n      });\n  }\n  const processedNodeManager = new ProcessedNodeManager();\n  const canvasManager = _getCanvasManager(\n    getCanvasManager,\n    {\n      mirror,\n      win: window,\n      mutationCb: (p) => wrappedEmit({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.CanvasMutation,\n          ...p\n        }\n      }),\n      recordCanvas,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maxCanvasSize,\n      sampling: sampling[\"canvas\"],\n      dataURLOptions,\n      errorHandler: errorHandler2\n    }\n  );\n  const shadowDomManager = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ === \"boolean\" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop() : new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    scrollCb: wrappedScrollEmit,\n    bypassOptions: {\n      onMutation,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      dataURLOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      recordCanvas,\n      inlineImages,\n      sampling,\n      slimDOMOptions,\n      iframeManager,\n      stylesheetManager,\n      canvasManager,\n      keepIframeSrcFn,\n      processedNodeManager\n    },\n    mirror\n  });\n  const takeFullSnapshot2 = (isCheckout = false) => {\n    if (!recordDOM) {\n      return;\n    }\n    wrappedEmit(\n      {\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight()\n        }\n      },\n      isCheckout\n    );\n    stylesheetManager.reset();\n    shadowDomManager.init();\n    mutationBuffers.forEach((buf) => buf.lock());\n    const node = snapshot(document, {\n      mirror,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskAttributeFn,\n      maskInputFn,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      dataURLOptions,\n      recordCanvas,\n      inlineImages,\n      onSerialize: (n2) => {\n        if (isSerializedIframe(n2, mirror)) {\n          iframeManager.addIframe(n2);\n        }\n        if (isSerializedStylesheet(n2, mirror)) {\n          stylesheetManager.trackLinkElement(n2);\n        }\n        if (hasShadowRoot(n2)) {\n          shadowDomManager.addShadowRoot(n2.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n        if (iframe.contentWindow) {\n          canvasManager.addWindow(iframe.contentWindow);\n        }\n        shadowDomManager.observeAttachShadow(iframe);\n      },\n      onStylesheetLoad: (linkEl, childSn) => {\n        stylesheetManager.attachLinkElement(linkEl, childSn);\n      },\n      keepIframeSrcFn\n    });\n    if (!node) {\n      return console.warn(\"Failed to snapshot the document\");\n    }\n    wrappedEmit({\n      type: EventType.FullSnapshot,\n      data: {\n        node,\n        initialOffset: getWindowScroll(window)\n      }\n    });\n    mutationBuffers.forEach((buf) => buf.unlock());\n    if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)\n      stylesheetManager.adoptStyleSheets(\n        document.adoptedStyleSheets,\n        mirror.getId(document)\n      );\n  };\n  _takeFullSnapshot = takeFullSnapshot2;\n  try {\n    const handlers = [];\n    const observe = (doc) => {\n      return callbackWrapper(initObservers)(\n        {\n          onMutation,\n          mutationCb: wrappedMutationEmit,\n          mousemoveCb: (positions, source) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source,\n              positions\n            }\n          }),\n          mouseInteractionCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MouseInteraction,\n              ...d\n            }\n          }),\n          scrollCb: wrappedScrollEmit,\n          viewportResizeCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.ViewportResize,\n              ...d\n            }\n          }),\n          inputCb: (v2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Input,\n              ...v2\n            }\n          }),\n          mediaInteractionCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MediaInteraction,\n              ...p\n            }\n          }),\n          styleSheetRuleCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleSheetRule,\n              ...r2\n            }\n          }),\n          styleDeclarationCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleDeclaration,\n              ...r2\n            }\n          }),\n          canvasMutationCb: wrappedCanvasMutationEmit,\n          fontCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Font,\n              ...p\n            }\n          }),\n          selectionCb: (p) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.Selection,\n                ...p\n              }\n            });\n          },\n          customElementCb: (c2) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.CustomElement,\n                ...c2\n              }\n            });\n          },\n          blockClass,\n          ignoreClass,\n          ignoreSelector,\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector,\n          maskInputOptions,\n          inlineStylesheet,\n          sampling,\n          recordDOM,\n          recordCanvas,\n          inlineImages,\n          userTriggeredOnInput,\n          collectFonts,\n          doc,\n          maskAttributeFn,\n          maskInputFn,\n          maskTextFn,\n          keepIframeSrcFn,\n          blockSelector,\n          unblockSelector,\n          slimDOMOptions,\n          dataURLOptions,\n          mirror,\n          iframeManager,\n          stylesheetManager,\n          shadowDomManager,\n          processedNodeManager,\n          canvasManager,\n          ignoreCSSAttributes,\n          plugins: plugins?.filter((p) => p.observer)?.map((p) => ({\n            observer: p.observer,\n            options: p.options,\n            callback: (payload) => wrappedEmit({\n              type: EventType.Plugin,\n              data: {\n                plugin: p.name,\n                payload\n              }\n            })\n          })) || []\n        },\n        {}\n      );\n    };\n    iframeManager.addLoadListener((iframeEl) => {\n      try {\n        handlers.push(observe(iframeEl.contentDocument));\n      } catch (error) {\n        console.warn(error);\n      }\n    });\n    const init = () => {\n      takeFullSnapshot2();\n      handlers.push(observe(document));\n    };\n    if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n      init();\n    } else {\n      handlers.push(\n        on(\"DOMContentLoaded\", () => {\n          wrappedEmit({\n            type: EventType.DomContentLoaded,\n            data: {}\n          });\n          if (recordAfter === \"DOMContentLoaded\") init();\n        })\n      );\n      handlers.push(\n        on(\n          \"load\",\n          () => {\n            wrappedEmit({\n              type: EventType.Load,\n              data: {}\n            });\n            if (recordAfter === \"load\") init();\n          },\n          window\n        )\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n      processedNodeManager.destroy();\n      _takeFullSnapshot = void 0;\n      unregisterErrorHandler();\n    };\n  } catch (error) {\n    console.warn(error);\n  }\n}\nfunction addCustomEvent(tag, payload) {\n  if (!_wrappedEmit) {\n    throw new Error(\"please add custom event after start recording\");\n  }\n  wrappedEmit({\n    type: EventType.Custom,\n    data: {\n      tag,\n      payload\n    }\n  });\n}\nfunction freezePage() {\n  mutationBuffers.forEach((buf) => buf.freeze());\n}\nfunction takeFullSnapshot(isCheckout) {\n  if (!_takeFullSnapshot) {\n    throw new Error(\"please take full snapshot after start recording\");\n  }\n  _takeFullSnapshot(isCheckout);\n}\nrecord.mirror = mirror;\nrecord.takeFullSnapshot = takeFullSnapshot;\nfunction _getCanvasManager(getCanvasManagerFn, options) {\n  try {\n    return getCanvasManagerFn ? getCanvasManagerFn(options) : new CanvasManagerNoop();\n  } catch {\n    console.warn(\"Unable to initialize CanvasManager\");\n    return new CanvasManagerNoop();\n  }\n}\nfunction mitt$1(n2) {\n  return { all: n2 = n2 || /* @__PURE__ */ new Map(), on: function(t2, e2) {\n    var i2 = n2.get(t2);\n    i2 ? i2.push(e2) : n2.set(t2, [e2]);\n  }, off: function(t2, e2) {\n    var i2 = n2.get(t2);\n    i2 && (e2 ? i2.splice(i2.indexOf(e2) >>> 0, 1) : n2.set(t2, []));\n  }, emit: function(t2, e2) {\n    var i2 = n2.get(t2);\n    i2 && i2.slice().map(function(n3) {\n      n3(e2);\n    }), (i2 = n2.get(\"*\")) && i2.slice().map(function(n3) {\n      n3(t2, e2);\n    });\n  } };\n}\nconst mittProxy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: mitt$1\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction polyfill(w = window, d = document) {\n  if (\"scrollBehavior\" in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n    return;\n  }\n  const Element2 = w.HTMLElement || w.Element;\n  const SCROLL_TIME = 468;\n  const original = {\n    scroll: w.scroll || w.scrollTo,\n    scrollBy: w.scrollBy,\n    elementScroll: Element2.prototype.scroll || scrollElement,\n    scrollIntoView: Element2.prototype.scrollIntoView\n  };\n  const now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n  function isMicrosoftBrowser(userAgent) {\n    const userAgentPatterns = [\"MSIE \", \"Trident/\", \"Edge/\"];\n    return new RegExp(userAgentPatterns.join(\"|\")).test(userAgent);\n  }\n  const ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n  function scrollElement(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n  }\n  function ease(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n  function shouldBailOut(firstArg) {\n    if (firstArg === null || typeof firstArg !== \"object\" || firstArg.behavior === void 0 || firstArg.behavior === \"auto\" || firstArg.behavior === \"instant\") {\n      return true;\n    }\n    if (typeof firstArg === \"object\" && firstArg.behavior === \"smooth\") {\n      return false;\n    }\n    throw new TypeError(\n      \"behavior member of ScrollOptions \" + firstArg.behavior + \" is not a valid value for enumeration ScrollBehavior.\"\n    );\n  }\n  function hasScrollableSpace(el, axis) {\n    if (axis === \"Y\") {\n      return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n    }\n    if (axis === \"X\") {\n      return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n    }\n  }\n  function canOverflow(el, axis) {\n    const overflowValue = w.getComputedStyle(el, null)[\"overflow\" + axis];\n    return overflowValue === \"auto\" || overflowValue === \"scroll\";\n  }\n  function isScrollable(el) {\n    const isScrollableY = hasScrollableSpace(el, \"Y\") && canOverflow(el, \"Y\");\n    const isScrollableX = hasScrollableSpace(el, \"X\") && canOverflow(el, \"X\");\n    return isScrollableY || isScrollableX;\n  }\n  function findScrollableParent(el) {\n    while (el !== d.body && isScrollable(el) === false) {\n      el = el.parentNode || el.host;\n    }\n    return el;\n  }\n  function step(context) {\n    const time = now();\n    let value;\n    let currentX;\n    let currentY;\n    let elapsed = (time - context.startTime) / SCROLL_TIME;\n    elapsed = elapsed > 1 ? 1 : elapsed;\n    value = ease(elapsed);\n    currentX = context.startX + (context.x - context.startX) * value;\n    currentY = context.startY + (context.y - context.startY) * value;\n    context.method.call(context.scrollable, currentX, currentY);\n    if (currentX !== context.x || currentY !== context.y) {\n      w.requestAnimationFrame(step.bind(w, context));\n    }\n  }\n  function smoothScroll(el, x, y) {\n    let scrollable;\n    let startX;\n    let startY;\n    let method;\n    const startTime = now();\n    if (el === d.body) {\n      scrollable = w;\n      startX = w.scrollX || w.pageXOffset;\n      startY = w.scrollY || w.pageYOffset;\n      method = original.scroll;\n    } else {\n      scrollable = el;\n      startX = el.scrollLeft;\n      startY = el.scrollTop;\n      method = scrollElement;\n    }\n    step({\n      scrollable,\n      method,\n      startTime,\n      startX,\n      startY,\n      x,\n      y\n    });\n  }\n  w.scroll = w.scrollTo = function() {\n    if (arguments[0] === void 0) {\n      return;\n    }\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scroll.call(\n        w,\n        arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== \"object\" ? arguments[0] : w.scrollX || w.pageXOffset,\n        // use top prop, second argument if present or fallback to scrollY\n        arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : w.scrollY || w.pageYOffset\n      );\n      return;\n    }\n    smoothScroll.call(\n      w,\n      d.body,\n      arguments[0].left !== void 0 ? ~~arguments[0].left : w.scrollX || w.pageXOffset,\n      arguments[0].top !== void 0 ? ~~arguments[0].top : w.scrollY || w.pageYOffset\n    );\n  };\n  w.scrollBy = function() {\n    if (arguments[0] === void 0) {\n      return;\n    }\n    if (shouldBailOut(arguments[0])) {\n      original.scrollBy.call(\n        w,\n        arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== \"object\" ? arguments[0] : 0,\n        arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : 0\n      );\n      return;\n    }\n    smoothScroll.call(\n      w,\n      d.body,\n      ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n      ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n    );\n  };\n  Element2.prototype.scroll = Element2.prototype.scrollTo = function() {\n    if (arguments[0] === void 0) {\n      return;\n    }\n    if (shouldBailOut(arguments[0]) === true) {\n      if (typeof arguments[0] === \"number\" && arguments[1] === void 0) {\n        throw new SyntaxError(\"Value could not be converted\");\n      }\n      original.elementScroll.call(\n        this,\n        // use left prop, first number argument or fallback to scrollLeft\n        arguments[0].left !== void 0 ? ~~arguments[0].left : typeof arguments[0] !== \"object\" ? ~~arguments[0] : this.scrollLeft,\n        // use top prop, second argument or fallback to scrollTop\n        arguments[0].top !== void 0 ? ~~arguments[0].top : arguments[1] !== void 0 ? ~~arguments[1] : this.scrollTop\n      );\n      return;\n    }\n    const left = arguments[0].left;\n    const top = arguments[0].top;\n    smoothScroll.call(\n      this,\n      this,\n      typeof left === \"undefined\" ? this.scrollLeft : ~~left,\n      typeof top === \"undefined\" ? this.scrollTop : ~~top\n    );\n  };\n  Element2.prototype.scrollBy = function() {\n    if (arguments[0] === void 0) {\n      return;\n    }\n    if (shouldBailOut(arguments[0]) === true) {\n      original.elementScroll.call(\n        this,\n        arguments[0].left !== void 0 ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft,\n        arguments[0].top !== void 0 ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop\n      );\n      return;\n    }\n    this.scroll({\n      left: ~~arguments[0].left + this.scrollLeft,\n      top: ~~arguments[0].top + this.scrollTop,\n      behavior: arguments[0].behavior\n    });\n  };\n  Element2.prototype.scrollIntoView = function() {\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scrollIntoView.call(\n        this,\n        arguments[0] === void 0 ? true : arguments[0]\n      );\n      return;\n    }\n    const scrollableParent = findScrollableParent(this);\n    const parentRects = scrollableParent.getBoundingClientRect();\n    const clientRects = this.getBoundingClientRect();\n    if (scrollableParent !== d.body) {\n      smoothScroll.call(\n        this,\n        scrollableParent,\n        scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n        scrollableParent.scrollTop + clientRects.top - parentRects.top\n      );\n      if (w.getComputedStyle(scrollableParent).position !== \"fixed\") {\n        w.scrollBy({\n          left: parentRects.left,\n          top: parentRects.top,\n          behavior: \"smooth\"\n        });\n      }\n    } else {\n      w.scrollBy({\n        left: clientRects.left,\n        top: clientRects.top,\n        behavior: \"smooth\"\n      });\n    }\n  };\n}\nclass Timer {\n  constructor(actions = [], config) {\n    this.timeOffset = 0;\n    this.raf = null;\n    this.actions = actions;\n    this.speed = config.speed;\n  }\n  /**\n   * Add an action, possibly after the timer starts.\n   */\n  addAction(action) {\n    const rafWasActive = this.raf === true;\n    if (!this.actions.length || this.actions[this.actions.length - 1].delay <= action.delay) {\n      this.actions.push(action);\n    } else {\n      const index = this.findActionIndex(action);\n      this.actions.splice(index, 0, action);\n    }\n    if (rafWasActive) {\n      this.raf = onRequestAnimationFrame(this.rafCheck.bind(this));\n    }\n  }\n  start() {\n    this.timeOffset = 0;\n    this.lastTimestamp = performance.now();\n    this.raf = onRequestAnimationFrame(this.rafCheck.bind(this));\n  }\n  rafCheck() {\n    const time = performance.now();\n    this.timeOffset += (time - this.lastTimestamp) * this.speed;\n    this.lastTimestamp = time;\n    while (this.actions.length) {\n      const action = this.actions[0];\n      if (this.timeOffset >= action.delay) {\n        this.actions.shift();\n        action.doAction();\n      } else {\n        break;\n      }\n    }\n    if (this.actions.length > 0) {\n      this.raf = onRequestAnimationFrame(this.rafCheck.bind(this));\n    } else {\n      this.raf = true;\n    }\n  }\n  clear() {\n    if (this.raf) {\n      if (this.raf !== true) {\n        cancelAnimationFrame(this.raf);\n      }\n      this.raf = null;\n    }\n    this.actions.length = 0;\n  }\n  setSpeed(speed) {\n    this.speed = speed;\n  }\n  isActive() {\n    return this.raf !== null;\n  }\n  findActionIndex(action) {\n    let start = 0;\n    let end = this.actions.length - 1;\n    while (start <= end) {\n      const mid = Math.floor((start + end) / 2);\n      if (this.actions[mid].delay < action.delay) {\n        start = mid + 1;\n      } else if (this.actions[mid].delay > action.delay) {\n        end = mid - 1;\n      } else {\n        return mid + 1;\n      }\n    }\n    return start;\n  }\n}\nfunction addDelay(event, baselineTime) {\n  if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.MouseMove && event.data.positions && event.data.positions.length) {\n    const firstOffset = event.data.positions[0].timeOffset;\n    const firstTimestamp = event.timestamp + firstOffset;\n    event.delay = firstTimestamp - baselineTime;\n    return firstTimestamp - baselineTime;\n  }\n  event.delay = event.timestamp - baselineTime;\n  return event.delay;\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction t(t2, n2) {\n  var e2 = \"function\" == typeof Symbol && t2[Symbol.iterator];\n  if (!e2) return t2;\n  var r2, o2, i2 = e2.call(t2), a2 = [];\n  try {\n    for (; (void 0 === n2 || n2-- > 0) && !(r2 = i2.next()).done; ) a2.push(r2.value);\n  } catch (t3) {\n    o2 = { error: t3 };\n  } finally {\n    try {\n      r2 && !r2.done && (e2 = i2.return) && e2.call(i2);\n    } finally {\n      if (o2) throw o2.error;\n    }\n  }\n  return a2;\n}\nvar n;\n!function(t2) {\n  t2[t2.NotStarted = 0] = \"NotStarted\", t2[t2.Running = 1] = \"Running\", t2[t2.Stopped = 2] = \"Stopped\";\n}(n || (n = {}));\nvar e = { type: \"xstate.init\" };\nfunction r(t2) {\n  return void 0 === t2 ? [] : [].concat(t2);\n}\nfunction o(t2) {\n  return { type: \"xstate.assign\", assignment: t2 };\n}\nfunction i(t2, n2) {\n  return \"string\" == typeof (t2 = \"string\" == typeof t2 && n2 && n2[t2] ? n2[t2] : t2) ? { type: t2 } : \"function\" == typeof t2 ? { type: t2.name, exec: t2 } : t2;\n}\nfunction a(t2) {\n  return function(n2) {\n    return t2 === n2;\n  };\n}\nfunction u(t2) {\n  return \"string\" == typeof t2 ? { type: t2 } : t2;\n}\nfunction c(t2, n2) {\n  return { value: t2, context: n2, actions: [], changed: false, matches: a(t2) };\n}\nfunction f(t2, n2, e2) {\n  var r2 = n2, o2 = false;\n  return [t2.filter(function(t3) {\n    if (\"xstate.assign\" === t3.type) {\n      o2 = true;\n      var n3 = Object.assign({}, r2);\n      return \"function\" == typeof t3.assignment ? n3 = t3.assignment(r2, e2) : Object.keys(t3.assignment).forEach(function(o3) {\n        n3[o3] = \"function\" == typeof t3.assignment[o3] ? t3.assignment[o3](r2, e2) : t3.assignment[o3];\n      }), r2 = n3, false;\n    }\n    return true;\n  }), r2, o2];\n}\nfunction s(n2, o2) {\n  void 0 === o2 && (o2 = {});\n  var s2 = t(f(r(n2.states[n2.initial].entry).map(function(t2) {\n    return i(t2, o2.actions);\n  }), n2.context, e), 2), l2 = s2[0], v2 = s2[1], y = { config: n2, _options: o2, initialState: { value: n2.initial, actions: l2, context: v2, matches: a(n2.initial) }, transition: function(e2, o3) {\n    var s3, l3, v3 = \"string\" == typeof e2 ? { value: e2, context: n2.context } : e2, p = v3.value, g = v3.context, d = u(o3), x = n2.states[p];\n    if (x.on) {\n      var m = r(x.on[d.type]);\n      try {\n        for (var h = function(t2) {\n          var n3 = \"function\" == typeof Symbol && Symbol.iterator, e3 = n3 && t2[n3], r2 = 0;\n          if (e3) return e3.call(t2);\n          if (t2 && \"number\" == typeof t2.length) return { next: function() {\n            return t2 && r2 >= t2.length && (t2 = void 0), { value: t2 && t2[r2++], done: !t2 };\n          } };\n          throw new TypeError(n3 ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n        }(m), b = h.next(); !b.done; b = h.next()) {\n          var S = b.value;\n          if (void 0 === S) return c(p, g);\n          var w = \"string\" == typeof S ? { target: S } : S, j = w.target, E = w.actions, R = void 0 === E ? [] : E, N = w.cond, O = void 0 === N ? function() {\n            return true;\n          } : N, _ = void 0 === j, k = null != j ? j : p, T = n2.states[k];\n          if (O(g, d)) {\n            var q = t(f((_ ? r(R) : [].concat(x.exit, R, T.entry).filter(function(t2) {\n              return t2;\n            })).map(function(t2) {\n              return i(t2, y._options.actions);\n            }), g, d), 3), z = q[0], A = q[1], B = q[2], C = null != j ? j : p;\n            return { value: C, context: A, actions: z, changed: j !== p || z.length > 0 || B, matches: a(C) };\n          }\n        }\n      } catch (t2) {\n        s3 = { error: t2 };\n      } finally {\n        try {\n          b && !b.done && (l3 = h.return) && l3.call(h);\n        } finally {\n          if (s3) throw s3.error;\n        }\n      }\n    }\n    return c(p, g);\n  } };\n  return y;\n}\nvar l = function(t2, n2) {\n  return t2.actions.forEach(function(e2) {\n    var r2 = e2.exec;\n    return r2 && r2(t2.context, n2);\n  });\n};\nfunction v(t2) {\n  var r2 = t2.initialState, o2 = n.NotStarted, i2 = /* @__PURE__ */ new Set(), c2 = { _machine: t2, send: function(e2) {\n    o2 === n.Running && (r2 = t2.transition(r2, e2), l(r2, u(e2)), i2.forEach(function(t3) {\n      return t3(r2);\n    }));\n  }, subscribe: function(t3) {\n    return i2.add(t3), t3(r2), { unsubscribe: function() {\n      return i2.delete(t3);\n    } };\n  }, start: function(i3) {\n    if (i3) {\n      var u2 = \"object\" == typeof i3 ? i3 : { context: t2.config.context, value: i3 };\n      r2 = { value: u2.value, actions: [], context: u2.context, matches: a(u2.value) };\n    }\n    return o2 = n.Running, l(r2, e), c2;\n  }, stop: function() {\n    return o2 = n.Stopped, i2.clear(), c2;\n  }, get state() {\n    return r2;\n  }, get status() {\n    return o2;\n  } };\n  return c2;\n}\nfunction discardPriorSnapshots(events, baselineTime) {\n  for (let idx = events.length - 1; idx >= 0; idx--) {\n    const event = events[idx];\n    if (event.type === EventType.Meta) {\n      if (event.timestamp <= baselineTime) {\n        return events.slice(idx);\n      }\n    }\n  }\n  return events;\n}\nfunction createPlayerService(context, { getCastFn, applyEventsSynchronously, emitter }) {\n  const playerMachine = s(\n    {\n      id: \"player\",\n      context,\n      initial: \"paused\",\n      states: {\n        playing: {\n          on: {\n            PAUSE: {\n              target: \"paused\",\n              actions: [\"pause\"]\n            },\n            CAST_EVENT: {\n              target: \"playing\",\n              actions: \"castEvent\"\n            },\n            END: {\n              target: \"paused\",\n              actions: [\"resetLastPlayedEvent\", \"pause\"]\n            },\n            ADD_EVENT: {\n              target: \"playing\",\n              actions: [\"addEvent\"]\n            }\n          }\n        },\n        paused: {\n          on: {\n            PLAY: {\n              target: \"playing\",\n              actions: [\"recordTimeOffset\", \"play\"]\n            },\n            CAST_EVENT: {\n              target: \"paused\",\n              actions: \"castEvent\"\n            },\n            TO_LIVE: {\n              target: \"live\",\n              actions: [\"startLive\"]\n            },\n            ADD_EVENT: {\n              target: \"paused\",\n              actions: [\"addEvent\"]\n            }\n          }\n        },\n        live: {\n          on: {\n            ADD_EVENT: {\n              target: \"live\",\n              actions: [\"addEvent\"]\n            },\n            CAST_EVENT: {\n              target: \"live\",\n              actions: [\"castEvent\"]\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        castEvent: o({\n          lastPlayedEvent: (ctx, event) => {\n            if (event.type === \"CAST_EVENT\") {\n              return event.payload.event;\n            }\n            return ctx.lastPlayedEvent;\n          }\n        }),\n        recordTimeOffset: o((ctx, event) => {\n          let timeOffset = ctx.timeOffset;\n          if (\"payload\" in event && \"timeOffset\" in event.payload) {\n            timeOffset = event.payload.timeOffset;\n          }\n          return {\n            ...ctx,\n            timeOffset,\n            baselineTime: ctx.events[0].timestamp + timeOffset\n          };\n        }),\n        play(ctx) {\n          const { timer, events, baselineTime, lastPlayedEvent } = ctx;\n          timer.clear();\n          for (const event of events) {\n            addDelay(event, baselineTime);\n          }\n          const neededEvents = discardPriorSnapshots(events, baselineTime);\n          let lastPlayedTimestamp = lastPlayedEvent?.timestamp;\n          if (lastPlayedEvent?.type === EventType.IncrementalSnapshot && lastPlayedEvent.data.source === IncrementalSource.MouseMove) {\n            lastPlayedTimestamp = lastPlayedEvent.timestamp + lastPlayedEvent.data.positions[0]?.timeOffset;\n          }\n          if (baselineTime < (lastPlayedTimestamp || 0)) {\n            emitter.emit(ReplayerEvents.PlayBack);\n          }\n          const syncEvents = new Array();\n          for (const event of neededEvents) {\n            if (lastPlayedTimestamp && lastPlayedTimestamp < baselineTime && (event.timestamp <= lastPlayedTimestamp || event === lastPlayedEvent)) {\n              continue;\n            }\n            if (event.timestamp < baselineTime) {\n              syncEvents.push(event);\n            } else {\n              const castFn = getCastFn(event, false);\n              timer.addAction({\n                doAction: () => {\n                  castFn();\n                },\n                delay: event.delay\n              });\n            }\n          }\n          applyEventsSynchronously(syncEvents);\n          emitter.emit(ReplayerEvents.Flush);\n          timer.start();\n        },\n        pause(ctx) {\n          ctx.timer.clear();\n        },\n        resetLastPlayedEvent: o((ctx) => {\n          return {\n            ...ctx,\n            lastPlayedEvent: null\n          };\n        }),\n        startLive: o({\n          baselineTime: (ctx, event) => {\n            ctx.timer.start();\n            if (event.type === \"TO_LIVE\" && event.payload.baselineTime) {\n              return event.payload.baselineTime;\n            }\n            return Date.now();\n          }\n        }),\n        addEvent: o((ctx, machineEvent) => {\n          const { baselineTime, timer, events } = ctx;\n          if (machineEvent.type === \"ADD_EVENT\") {\n            const { event } = machineEvent.payload;\n            addDelay(event, baselineTime);\n            let end = events.length - 1;\n            if (!events[end] || events[end].timestamp <= event.timestamp) {\n              events.push(event);\n            } else {\n              let insertionIndex = -1;\n              let start = 0;\n              while (start <= end) {\n                const mid = Math.floor((start + end) / 2);\n                if (events[mid].timestamp <= event.timestamp) {\n                  start = mid + 1;\n                } else {\n                  end = mid - 1;\n                }\n              }\n              if (insertionIndex === -1) {\n                insertionIndex = start;\n              }\n              events.splice(insertionIndex, 0, event);\n            }\n            const isSync = event.timestamp < baselineTime;\n            const castFn = getCastFn(event, isSync);\n            if (isSync) {\n              castFn();\n            } else if (timer.isActive()) {\n              timer.addAction({\n                doAction: () => {\n                  castFn();\n                },\n                delay: event.delay\n              });\n            }\n          }\n          return { ...ctx, events };\n        })\n      }\n    }\n  );\n  return v(playerMachine);\n}\nfunction createSpeedService(context) {\n  const speedMachine = s(\n    {\n      id: \"speed\",\n      context,\n      initial: \"normal\",\n      states: {\n        normal: {\n          on: {\n            FAST_FORWARD: {\n              target: \"skipping\",\n              actions: [\"recordSpeed\", \"setSpeed\"]\n            },\n            SET_SPEED: {\n              target: \"normal\",\n              actions: [\"setSpeed\"]\n            }\n          }\n        },\n        skipping: {\n          on: {\n            BACK_TO_NORMAL: {\n              target: \"normal\",\n              actions: [\"restoreSpeed\"]\n            },\n            SET_SPEED: {\n              target: \"normal\",\n              actions: [\"setSpeed\"]\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        setSpeed: (ctx, event) => {\n          if (\"payload\" in event) {\n            ctx.timer.setSpeed(event.payload.speed);\n          }\n        },\n        recordSpeed: o({\n          normalSpeed: (ctx) => ctx.timer.speed\n        }),\n        restoreSpeed: (ctx) => {\n          ctx.timer.setSpeed(ctx.normalSpeed);\n        }\n      }\n    }\n  );\n  return v(speedMachine);\n}\nconst rules = (blockClass) => [\n  `.${blockClass} { background: currentColor }`,\n  \"noscript { display: none !important; }\"\n];\nconst webGLVarMap = /* @__PURE__ */ new Map();\nfunction variableListFor(ctx, ctor) {\n  let contextMap = webGLVarMap.get(ctx);\n  if (!contextMap) {\n    contextMap = /* @__PURE__ */ new Map();\n    webGLVarMap.set(ctx, contextMap);\n  }\n  if (!contextMap.has(ctor)) {\n    contextMap.set(ctor, []);\n  }\n  return contextMap.get(ctor);\n}\nfunction deserializeArg(imageMap, ctx, preload) {\n  return async (arg) => {\n    if (arg && typeof arg === \"object\" && \"rr_type\" in arg) {\n      if (preload) preload.isUnchanged = false;\n      if (arg.rr_type === \"ImageBitmap\" && \"args\" in arg) {\n        const args = await deserializeArg(imageMap, ctx, preload)(arg.args);\n        return await createImageBitmap.apply(null, args);\n      } else if (\"index\" in arg) {\n        if (preload || ctx === null) return arg;\n        const { rr_type: name, index } = arg;\n        return variableListFor(ctx, name)[index];\n      } else if (\"args\" in arg) {\n        const { rr_type: name, args } = arg;\n        const ctor = window[name];\n        return new ctor(\n          ...await Promise.all(\n            args.map(deserializeArg(imageMap, ctx, preload))\n          )\n        );\n      } else if (\"base64\" in arg) {\n        return decode(arg.base64);\n      } else if (\"src\" in arg) {\n        const image = imageMap.get(arg.src);\n        if (image) {\n          return image;\n        } else {\n          const image2 = new Image();\n          image2.src = arg.src;\n          imageMap.set(arg.src, image2);\n          return image2;\n        }\n      } else if (\"data\" in arg && arg.rr_type === \"Blob\") {\n        const blobContents = await Promise.all(\n          arg.data.map(deserializeArg(imageMap, ctx, preload))\n        );\n        const blob = new Blob(blobContents, {\n          type: arg.type\n        });\n        return blob;\n      }\n    } else if (Array.isArray(arg)) {\n      const result = await Promise.all(\n        arg.map(deserializeArg(imageMap, ctx, preload))\n      );\n      return result;\n    }\n    return arg;\n  };\n}\nfunction getContext(target, type) {\n  try {\n    if (type === CanvasContext.WebGL) {\n      return target.getContext(\"webgl\") || target.getContext(\"experimental-webgl\");\n    }\n    return target.getContext(\"webgl2\");\n  } catch (e2) {\n    return null;\n  }\n}\nconst WebGLVariableConstructorsNames = [\n  \"WebGLActiveInfo\",\n  \"WebGLBuffer\",\n  \"WebGLFramebuffer\",\n  \"WebGLProgram\",\n  \"WebGLRenderbuffer\",\n  \"WebGLShader\",\n  \"WebGLShaderPrecisionFormat\",\n  \"WebGLTexture\",\n  \"WebGLUniformLocation\",\n  \"WebGLVertexArrayObject\"\n];\nfunction saveToWebGLVarMap(ctx, result) {\n  if (!result?.constructor) return;\n  const { name } = result.constructor;\n  if (!WebGLVariableConstructorsNames.includes(name)) return;\n  const variables = variableListFor(ctx, name);\n  if (!variables.includes(result)) variables.push(result);\n}\nasync function webglMutation({\n  mutation,\n  target,\n  type,\n  imageMap,\n  errorHandler: errorHandler2\n}) {\n  try {\n    const ctx = getContext(target, type);\n    if (!ctx) return;\n    if (mutation.setter) {\n      ctx[mutation.property] = mutation.args[0];\n      return;\n    }\n    const original = ctx[mutation.property];\n    const args = await Promise.all(\n      mutation.args.map(deserializeArg(imageMap, ctx))\n    );\n    const result = original.apply(ctx, args);\n    saveToWebGLVarMap(ctx, result);\n    const debugMode = false;\n    if (debugMode) ;\n  } catch (error) {\n    errorHandler2(mutation, error);\n  }\n}\nasync function canvasMutation$1({\n  event,\n  mutations,\n  target,\n  imageMap,\n  errorHandler: errorHandler2\n}) {\n  const ctx = target.getContext(\"2d\");\n  if (!ctx) {\n    errorHandler2(mutations[0], new Error(\"Canvas context is null\"));\n    return;\n  }\n  const mutationArgsPromises = mutations.map(\n    async (mutation) => {\n      return Promise.all(mutation.args.map(deserializeArg(imageMap, ctx)));\n    }\n  );\n  const args = await Promise.all(mutationArgsPromises);\n  args.forEach((args2, index) => {\n    const mutation = mutations[index];\n    try {\n      if (mutation.setter) {\n        ctx[mutation.property] = mutation.args[0];\n        return;\n      }\n      const original = ctx[mutation.property];\n      if (mutation.property === \"drawImage\" && typeof mutation.args[0] === \"string\") {\n        imageMap.get(event);\n        original.apply(ctx, mutation.args);\n      } else {\n        original.apply(ctx, args2);\n      }\n    } catch (error) {\n      errorHandler2(mutation, error);\n    }\n    return;\n  });\n}\nasync function canvasMutation({\n  event,\n  mutation,\n  target,\n  imageMap,\n  canvasEventMap,\n  errorHandler: errorHandler2\n}) {\n  try {\n    const precomputedMutation = canvasEventMap.get(event) || mutation;\n    const commands = \"commands\" in precomputedMutation ? precomputedMutation.commands : [precomputedMutation];\n    if ([CanvasContext.WebGL, CanvasContext.WebGL2].includes(mutation.type)) {\n      for (let i2 = 0; i2 < commands.length; i2++) {\n        const command = commands[i2];\n        await webglMutation({\n          mutation: command,\n          type: mutation.type,\n          target,\n          imageMap,\n          errorHandler: errorHandler2\n        });\n      }\n      return;\n    }\n    await canvasMutation$1({\n      event,\n      mutations: commands,\n      target,\n      imageMap,\n      errorHandler: errorHandler2\n    });\n  } catch (error) {\n    errorHandler2(mutation, error);\n  }\n}\nconst SKIP_TIME_INTERVAL = 5 * 1e3;\nconst mitt = mitt$1 || mittProxy;\nconst REPLAY_CONSOLE_PREFIX = \"[replayer]\";\nconst defaultMouseTailConfig = {\n  duration: 500,\n  lineCap: \"round\",\n  lineWidth: 3,\n  strokeStyle: \"red\"\n};\nfunction indicatesTouchDevice(e2) {\n  return e2.type == EventType.IncrementalSnapshot && (e2.data.source == IncrementalSource.TouchMove || e2.data.source == IncrementalSource.MouseInteraction && e2.data.type == MouseInteractions.TouchStart);\n}\nfunction getPointerId(d) {\n  const pointerId = \"pointerId\" in d && typeof d.pointerId === \"number\" ? d.pointerId : -1;\n  return pointerId;\n}\nclass Replayer {\n  constructor(events, config) {\n    this.usingVirtualDom = false;\n    this.virtualDom = new RRDocument();\n    this.emitter = mitt();\n    this.legacy_missingNodeRetryMap = {};\n    this.cache = createCache();\n    this.imageMap = /* @__PURE__ */ new Map();\n    this.canvasEventMap = /* @__PURE__ */ new Map();\n    this.mirror = createMirror$2();\n    this.styleMirror = new StyleSheetMirror();\n    this.firstFullSnapshot = null;\n    this.newDocumentQueue = [];\n    this.pointers = {};\n    this.lastMouseDownEvent = null;\n    this.lastSelectionData = null;\n    this.constructedStyleMutations = [];\n    this.adoptedStyleSheets = [];\n    this.handleResize = (dimension) => {\n      this.iframe.style.display = \"inherit\";\n      for (const el of [\n        ...Object.values(this.pointers).flatMap((a2) => a2.mouseTail),\n        this.iframe\n      ]) {\n        if (!el) {\n          continue;\n        }\n        el.setAttribute(\"width\", String(dimension.width));\n        el.setAttribute(\"height\", String(dimension.height));\n      }\n    };\n    this.applyEventsSynchronously = (events2) => {\n      for (const event of events2) {\n        switch (event.type) {\n          case EventType.DomContentLoaded:\n          case EventType.Load:\n          case EventType.Custom:\n            continue;\n          case EventType.FullSnapshot:\n          case EventType.Meta:\n          case EventType.Plugin:\n          case EventType.IncrementalSnapshot:\n            break;\n        }\n        const castFn = this.getCastFn(event, true);\n        castFn();\n      }\n    };\n    this.getCastFn = (event, isSync = false) => {\n      let castFn;\n      switch (event.type) {\n        case EventType.DomContentLoaded:\n        case EventType.Load:\n          break;\n        case EventType.Custom:\n          castFn = () => {\n            this.emitter.emit(ReplayerEvents.CustomEvent, event);\n          };\n          break;\n        case EventType.Meta:\n          castFn = () => this.emitter.emit(ReplayerEvents.Resize, {\n            width: event.data.width,\n            height: event.data.height\n          });\n          break;\n        case EventType.FullSnapshot:\n          castFn = () => {\n            if (this.firstFullSnapshot) {\n              if (this.firstFullSnapshot === event) {\n                this.firstFullSnapshot = true;\n                return;\n              }\n            } else {\n              this.firstFullSnapshot = true;\n            }\n            this.rebuildFullSnapshot(event, isSync);\n            this.iframe.contentWindow?.scrollTo(event.data.initialOffset);\n            this.styleMirror.reset();\n          };\n          break;\n        case EventType.IncrementalSnapshot:\n          castFn = () => {\n            this.applyIncremental(event, isSync);\n            if (isSync) {\n              return;\n            }\n            if (event === this.nextUserInteractionEvent) {\n              this.nextUserInteractionEvent = null;\n              this.backToNormal();\n            }\n            if (this.config.skipInactive && !this.nextUserInteractionEvent) {\n              for (const _event of this.service.state.context.events) {\n                if (_event.timestamp <= event.timestamp) {\n                  continue;\n                }\n                if (this.isUserInteraction(_event)) {\n                  if (\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    _event.delay - event.delay > this.config.inactivePeriodThreshold * this.speedService.state.context.timer.speed\n                  ) {\n                    this.nextUserInteractionEvent = _event;\n                  }\n                  break;\n                }\n              }\n              if (this.nextUserInteractionEvent) {\n                const skipTime = (\n                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  this.nextUserInteractionEvent.delay - event.delay\n                );\n                const payload = {\n                  speed: Math.min(\n                    Math.round(skipTime / SKIP_TIME_INTERVAL),\n                    this.config.maxSpeed\n                  )\n                };\n                this.speedService.send({ type: \"FAST_FORWARD\", payload });\n                this.emitter.emit(ReplayerEvents.SkipStart, payload);\n              }\n            }\n          };\n          break;\n      }\n      const wrappedCastFn = () => {\n        if (castFn) {\n          castFn();\n        }\n        for (const plugin of this.config.plugins || []) {\n          if (plugin.handler) plugin.handler(event, isSync, { replayer: this });\n        }\n        this.service.send({ type: \"CAST_EVENT\", payload: { event } });\n        const last_index = this.service.state.context.events.length - 1;\n        if (!this.config.liveMode && event === this.service.state.context.events[last_index]) {\n          const finish = () => {\n            if (last_index < this.service.state.context.events.length - 1) {\n              return;\n            }\n            this.backToNormal();\n            this.service.send(\"END\");\n            this.emitter.emit(ReplayerEvents.Finish);\n          };\n          let finish_buffer = 50;\n          if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.MouseMove && event.data.positions.length) {\n            finish_buffer += Math.max(0, -event.data.positions[0].timeOffset);\n          }\n          setTimeout$1(finish, finish_buffer);\n        }\n        this.emitter.emit(ReplayerEvents.EventCast, event);\n      };\n      return wrappedCastFn;\n    };\n    if (!config?.liveMode && events.length < 2) {\n      throw new Error(\"Replayer need at least 2 events.\");\n    }\n    const defaultConfig = {\n      speed: 1,\n      maxSpeed: 360,\n      root: document.body,\n      loadTimeout: 0,\n      skipInactive: false,\n      inactivePeriodThreshold: 10 * 1e3,\n      showWarning: true,\n      showDebug: false,\n      blockClass: \"rr-block\",\n      liveMode: false,\n      insertStyleRules: [],\n      triggerFocus: true,\n      UNSAFE_replayCanvas: false,\n      pauseAnimation: true,\n      mouseTail: defaultMouseTailConfig,\n      useVirtualDom: true,\n      // Virtual-dom optimization is enabled by default.\n      logger: console\n    };\n    this.config = Object.assign({}, defaultConfig, config);\n    this.handleResize = this.handleResize.bind(this);\n    this.getCastFn = this.getCastFn.bind(this);\n    this.applyEventsSynchronously = this.applyEventsSynchronously.bind(this);\n    this.emitter.on(ReplayerEvents.Resize, this.handleResize);\n    this.setupDom();\n    for (const plugin of this.config.plugins || []) {\n      if (plugin.getMirror) plugin.getMirror({ nodeMirror: this.mirror });\n    }\n    this.emitter.on(ReplayerEvents.Flush, () => {\n      if (this.usingVirtualDom) {\n        const replayerHandler = {\n          mirror: this.mirror,\n          applyCanvas: (canvasEvent, canvasMutationData2, target) => {\n            void canvasMutation({\n              event: canvasEvent,\n              mutation: canvasMutationData2,\n              target,\n              imageMap: this.imageMap,\n              canvasEventMap: this.canvasEventMap,\n              errorHandler: this.warnCanvasMutationFailed.bind(this)\n            });\n          },\n          applyInput: this.applyInput.bind(this),\n          applyScroll: this.applyScroll.bind(this),\n          applyStyleSheetMutation: (data, styleSheet) => {\n            if (data.source === IncrementalSource.StyleSheetRule)\n              this.applyStyleSheetRule(data, styleSheet);\n            else if (data.source === IncrementalSource.StyleDeclaration)\n              this.applyStyleDeclaration(data, styleSheet);\n          },\n          afterAppend: (node, id) => {\n            for (const plugin of this.config.plugins || []) {\n              if (plugin.onBuild) plugin.onBuild(node, { id, replayer: this });\n            }\n          }\n        };\n        const iframeDoc = getIFrameContentDocument(this.iframe);\n        if (iframeDoc)\n          try {\n            diff(\n              iframeDoc,\n              this.virtualDom,\n              replayerHandler,\n              this.virtualDom.mirror\n            );\n          } catch (e2) {\n            console.warn(e2);\n          }\n        this.virtualDom.destroyTree();\n        this.usingVirtualDom = false;\n        if (Object.keys(this.legacy_missingNodeRetryMap).length) {\n          for (const key in this.legacy_missingNodeRetryMap) {\n            try {\n              const value = this.legacy_missingNodeRetryMap[key];\n              const realNode = createOrGetNode(\n                value.node,\n                this.mirror,\n                this.virtualDom.mirror\n              );\n              diff(\n                realNode,\n                value.node,\n                replayerHandler,\n                this.virtualDom.mirror\n              );\n              value.node = realNode;\n            } catch (error) {\n              this.warn(error);\n            }\n          }\n        }\n        this.constructedStyleMutations.forEach((data) => {\n          this.applyStyleSheetMutation(data);\n        });\n        this.constructedStyleMutations = [];\n        this.adoptedStyleSheets.forEach((data) => {\n          this.applyAdoptedStyleSheet(data);\n        });\n        this.adoptedStyleSheets = [];\n      }\n      for (const [\n        pointerId,\n        { pointerPosition, touchActive }\n      ] of Object.entries(this.pointers)) {\n        const id = parseInt(pointerId);\n        const pointer = this.pointers[id];\n        if (pointerPosition) {\n          this.moveAndHover(\n            pointerPosition.x,\n            pointerPosition.y,\n            pointerPosition.id,\n            true,\n            pointerPosition.debugData,\n            id\n          );\n          pointer.pointerPosition = null;\n        }\n        if (touchActive === true) {\n          pointer.pointerEl.classList.add(\"touch-active\");\n        } else if (touchActive === false) {\n          pointer.pointerEl.classList.remove(\"touch-active\");\n        }\n        pointer.touchActive = null;\n      }\n      if (this.lastMouseDownEvent) {\n        const [target, event] = this.lastMouseDownEvent;\n        target.dispatchEvent(event);\n      }\n      this.lastMouseDownEvent = null;\n      if (this.lastSelectionData) {\n        this.applySelection(this.lastSelectionData);\n        this.lastSelectionData = null;\n      }\n    });\n    this.emitter.on(ReplayerEvents.PlayBack, () => {\n      this.firstFullSnapshot = null;\n      this.mirror.reset();\n      this.styleMirror.reset();\n    });\n    const timer = new Timer([], {\n      speed: this.config.speed\n    });\n    this.service = createPlayerService(\n      {\n        events: events.map((e2) => {\n          if (config && config.unpackFn) {\n            return config.unpackFn(e2);\n          }\n          return e2;\n        }).sort((a1, a2) => a1.timestamp - a2.timestamp),\n        timer,\n        timeOffset: 0,\n        baselineTime: 0,\n        lastPlayedEvent: null\n      },\n      {\n        getCastFn: this.getCastFn,\n        applyEventsSynchronously: this.applyEventsSynchronously,\n        emitter: this.emitter\n      }\n    );\n    this.service.start();\n    this.service.subscribe((state) => {\n      this.emitter.emit(ReplayerEvents.StateChange, {\n        player: state\n      });\n    });\n    this.speedService = createSpeedService({\n      normalSpeed: -1,\n      timer\n    });\n    this.speedService.start();\n    this.speedService.subscribe((state) => {\n      this.emitter.emit(ReplayerEvents.StateChange, {\n        speed: state\n      });\n    });\n    const firstMeta = this.service.state.context.events.find(\n      (e2) => e2.type === EventType.Meta\n    );\n    const firstFullsnapshot = this.service.state.context.events.find(\n      (e2) => e2.type === EventType.FullSnapshot\n    );\n    if (firstMeta) {\n      const { width, height } = firstMeta.data;\n      setTimeout$1(() => {\n        this.emitter.emit(ReplayerEvents.Resize, {\n          width,\n          height\n        });\n      }, 0);\n    }\n    if (firstFullsnapshot) {\n      setTimeout$1(() => {\n        if (this.firstFullSnapshot) {\n          return;\n        }\n        this.firstFullSnapshot = firstFullsnapshot;\n        this.rebuildFullSnapshot(\n          firstFullsnapshot\n        );\n        this.iframe.contentWindow?.scrollTo(\n          firstFullsnapshot.data.initialOffset\n        );\n      }, 1);\n    }\n  }\n  get timer() {\n    return this.service.state.context.timer;\n  }\n  createPointer(pointerId, event) {\n    const mouseTail = document.createElement(\"canvas\");\n    mouseTail.classList.add(\"replayer-mouse-tail\");\n    mouseTail.width = Number.parseFloat(this.iframe.width);\n    mouseTail.height = Number.parseFloat(this.iframe.height);\n    this.wrapper.insertBefore(mouseTail, this.iframe);\n    mouseTail.style.display = this.config.mouseTail === false ? \"none\" : \"inherit\";\n    const newMouse = document.createElement(\"div\");\n    newMouse.classList.add(\"replayer-mouse\");\n    this.pointers[pointerId] = {\n      touchActive: null,\n      pointerEl: newMouse,\n      tailPositions: [],\n      pointerPosition: null,\n      mouseTail\n    };\n    if (indicatesTouchDevice(event)) {\n      newMouse.classList.add(\"touch-device\");\n    }\n    this.wrapper.appendChild(newMouse);\n  }\n  on(event, handler) {\n    this.emitter.on(event, handler);\n    return this;\n  }\n  off(event, handler) {\n    this.emitter.off(event, handler);\n    return this;\n  }\n  setConfig(config) {\n    Object.keys(config).forEach((key) => {\n      config[key];\n      this.config[key] = config[key];\n    });\n    if (!this.config.skipInactive) {\n      this.backToNormal();\n    }\n    if (typeof config.speed !== \"undefined\") {\n      this.speedService.send({\n        type: \"SET_SPEED\",\n        payload: {\n          speed: config.speed\n        }\n      });\n    }\n    if (typeof config.mouseTail !== \"undefined\") {\n      if (config.mouseTail === false) {\n        for (const { mouseTail } of Object.values(this.pointers)) {\n          if (mouseTail) {\n            mouseTail.style.display = \"none\";\n          }\n        }\n      } else {\n        for (let { mouseTail } of Object.values(this.pointers)) {\n          if (!mouseTail) {\n            mouseTail = document.createElement(\"canvas\");\n            mouseTail.width = Number.parseFloat(this.iframe.width);\n            mouseTail.height = Number.parseFloat(this.iframe.height);\n            mouseTail.classList.add(\"replayer-mouse-tail\");\n            this.wrapper.insertBefore(mouseTail, this.iframe);\n          }\n          mouseTail.style.display = \"inherit\";\n        }\n      }\n    }\n  }\n  getMetaData() {\n    const firstEvent = this.service.state.context.events[0];\n    const lastEvent = this.service.state.context.events[this.service.state.context.events.length - 1];\n    return {\n      startTime: firstEvent.timestamp,\n      endTime: lastEvent.timestamp,\n      totalTime: lastEvent.timestamp - firstEvent.timestamp\n    };\n  }\n  getCurrentTime() {\n    return this.timer.timeOffset + this.getTimeOffset();\n  }\n  getTimeOffset() {\n    const { baselineTime, events } = this.service.state.context;\n    return baselineTime - events[0].timestamp;\n  }\n  getMirror() {\n    return this.mirror;\n  }\n  /**\n   * This API was designed to be used as play at any time offset.\n   * Since we minimized the data collected from recorder, we do not\n   * have the ability of undo an event.\n   * So the implementation of play at any time offset will always iterate\n   * all of the events, cast event before the offset synchronously\n   * and cast event after the offset asynchronously with timer.\n   * @param timeOffset - number\n   */\n  play(timeOffset = 0) {\n    if (this.service.state.matches(\"paused\")) {\n      this.service.send({ type: \"PLAY\", payload: { timeOffset } });\n    } else {\n      this.service.send({ type: \"PAUSE\" });\n      this.service.send({ type: \"PLAY\", payload: { timeOffset } });\n    }\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    iframeDoc?.getElementsByTagName(\"html\")[0]?.classList.remove(\"rrweb-paused\");\n    this.emitter.emit(ReplayerEvents.Start);\n  }\n  pause(timeOffset) {\n    if (timeOffset === void 0 && this.service.state.matches(\"playing\")) {\n      this.service.send({ type: \"PAUSE\" });\n    }\n    if (typeof timeOffset === \"number\") {\n      this.play(timeOffset);\n      this.service.send({ type: \"PAUSE\" });\n    }\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    iframeDoc?.getElementsByTagName(\"html\")[0]?.classList.add(\"rrweb-paused\");\n    this.emitter.emit(ReplayerEvents.Pause);\n  }\n  resume(timeOffset = 0) {\n    this.warn(\n      `The 'resume' was deprecated in 1.0. Please use 'play' method which has the same interface.`\n    );\n    this.play(timeOffset);\n    this.emitter.emit(ReplayerEvents.Resume);\n  }\n  /**\n   * Totally destroy this replayer and please be careful that this operation is irreversible.\n   * Memory occupation can be released by removing all references to this replayer.\n   */\n  destroy() {\n    this.pause();\n    this.config.root.removeChild(this.wrapper);\n    this.emitter.emit(ReplayerEvents.Destroy);\n  }\n  startLive(baselineTime) {\n    this.service.send({ type: \"TO_LIVE\", payload: { baselineTime } });\n  }\n  addEvent(rawEvent) {\n    const event = this.config.unpackFn ? this.config.unpackFn(rawEvent) : rawEvent;\n    void Promise.resolve().then(\n      () => this.service.send({ type: \"ADD_EVENT\", payload: { event } })\n    );\n  }\n  enableInteract() {\n    this.iframe.setAttribute(\"scrolling\", \"auto\");\n    this.iframe.style.pointerEvents = \"auto\";\n  }\n  disableInteract() {\n    this.iframe.setAttribute(\"scrolling\", \"no\");\n    this.iframe.style.pointerEvents = \"none\";\n  }\n  /**\n   * Empties the replayer's cache and reclaims memory.\n   * The replayer will use this cache to speed up the playback.\n   */\n  resetCache() {\n    this.cache = createCache();\n  }\n  setupDom() {\n    this.wrapper = document.createElement(\"div\");\n    this.wrapper.classList.add(\"replayer-wrapper\");\n    this.config.root.appendChild(this.wrapper);\n    this.iframe = document.createElement(\"iframe\");\n    const attributes2 = [\"allow-same-origin\"];\n    if (this.config.UNSAFE_replayCanvas) {\n      attributes2.push(\"allow-scripts\");\n    }\n    this.iframe.style.display = \"none\";\n    this.iframe.setAttribute(\"sandbox\", attributes2.join(\" \"));\n    this.disableInteract();\n    this.wrapper.appendChild(this.iframe);\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    const iframeWindow = getIFrameContentWindow(this.iframe);\n    if (iframeWindow && iframeDoc) {\n      polyfill(iframeWindow, iframeDoc);\n      polyfill$1(iframeWindow);\n    }\n  }\n  rebuildFullSnapshot(event, isSync = false) {\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    if (!iframeDoc) {\n      return this.warn(\"Looks like your replayer has been destroyed.\");\n    }\n    if (Object.keys(this.legacy_missingNodeRetryMap).length) {\n      this.warn(\n        \"Found unresolved missing node map\",\n        this.legacy_missingNodeRetryMap\n      );\n    }\n    this.legacy_missingNodeRetryMap = {};\n    const collected = [];\n    const afterAppend = (builtNode, id) => {\n      this.collectIframeAndAttachDocument(collected, builtNode);\n      for (const plugin of this.config.plugins || []) {\n        if (plugin.onBuild)\n          plugin.onBuild(builtNode, {\n            id,\n            replayer: this\n          });\n      }\n    };\n    if (this.usingVirtualDom) {\n      this.virtualDom.destroyTree();\n      this.usingVirtualDom = false;\n    }\n    this.mirror.reset();\n    rebuild(event.data.node, {\n      doc: iframeDoc,\n      afterAppend,\n      cache: this.cache,\n      mirror: this.mirror\n    });\n    afterAppend(iframeDoc, event.data.node.id);\n    for (const { mutationInQueue, builtNode } of collected) {\n      this.attachDocumentToIframe(mutationInQueue, builtNode);\n      this.newDocumentQueue = this.newDocumentQueue.filter(\n        (m) => m !== mutationInQueue\n      );\n    }\n    const { documentElement, head } = iframeDoc;\n    this.insertStyleRules(documentElement, head);\n    if (!this.service.state.matches(\"playing\")) {\n      const iframeHtmlElement = iframeDoc.getElementsByTagName(\"html\")[0];\n      iframeHtmlElement && iframeHtmlElement.classList.add(\"rrweb-paused\");\n    }\n    this.emitter.emit(ReplayerEvents.FullsnapshotRebuilded, event);\n    if (!isSync) {\n      this.waitForStylesheetLoad();\n    }\n    if (this.config.UNSAFE_replayCanvas) {\n      void this.preloadAllImages();\n    }\n  }\n  insertStyleRules(documentElement, head) {\n    const injectStylesRules = rules(\n      this.config.blockClass\n    ).concat(this.config.insertStyleRules);\n    if (this.config.pauseAnimation) {\n      injectStylesRules.push(\n        \"html.rrweb-paused *, html.rrweb-paused *:before, html.rrweb-paused *:after { animation-play-state: paused !important; }\"\n      );\n    }\n    if (this.usingVirtualDom) {\n      const styleEl = this.virtualDom.createElement(\"style\");\n      this.virtualDom.mirror.add(\n        styleEl,\n        getDefaultSN(styleEl, this.virtualDom.unserializedId)\n      );\n      documentElement.insertBefore(styleEl, head);\n      styleEl.rules.push({\n        source: IncrementalSource.StyleSheetRule,\n        adds: injectStylesRules.map((cssText, index) => ({\n          rule: cssText,\n          index\n        }))\n      });\n    } else {\n      const styleEl = document.createElement(\"style\");\n      documentElement.insertBefore(\n        styleEl,\n        head\n      );\n      for (let idx = 0; idx < injectStylesRules.length; idx++) {\n        styleEl.sheet?.insertRule(injectStylesRules[idx], idx);\n      }\n    }\n  }\n  attachDocumentToIframe(mutation, iframeEl) {\n    const mirror2 = this.usingVirtualDom ? this.virtualDom.mirror : this.mirror;\n    const iframeContentDoc = getIFrameContentDocument(\n      iframeEl\n    );\n    const collected = [];\n    const afterAppend = (builtNode, id) => {\n      this.collectIframeAndAttachDocument(collected, builtNode);\n      const sn = mirror2.getMeta(builtNode);\n      if (sn?.type === NodeType$2.Element && sn?.tagName.toUpperCase() === \"HTML\" && iframeContentDoc) {\n        const { documentElement, head } = iframeContentDoc;\n        this.insertStyleRules(\n          documentElement,\n          head\n        );\n      }\n      if (this.usingVirtualDom) return;\n      for (const plugin of this.config.plugins || []) {\n        if (plugin.onBuild)\n          plugin.onBuild(builtNode, {\n            id,\n            replayer: this\n          });\n      }\n    };\n    buildNodeWithSN(mutation.node, {\n      doc: iframeContentDoc,\n      mirror: mirror2,\n      hackCss: true,\n      skipChild: false,\n      afterAppend,\n      cache: this.cache\n    });\n    afterAppend(iframeContentDoc, mutation.node.id);\n    for (const { mutationInQueue, builtNode } of collected) {\n      this.attachDocumentToIframe(mutationInQueue, builtNode);\n      this.newDocumentQueue = this.newDocumentQueue.filter(\n        (m) => m !== mutationInQueue\n      );\n    }\n  }\n  collectIframeAndAttachDocument(collected, builtNode) {\n    if (isSerializedIframe(builtNode, this.mirror)) {\n      const mutationInQueue = this.newDocumentQueue.find(\n        (m) => m.parentId === this.mirror.getId(builtNode)\n      );\n      if (mutationInQueue) {\n        collected.push({\n          mutationInQueue,\n          builtNode\n        });\n      }\n    }\n  }\n  /**\n   * pause when loading style sheet, resume when loaded all timeout exceed\n   */\n  waitForStylesheetLoad() {\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    const head = iframeDoc?.head;\n    if (head) {\n      const unloadSheets = /* @__PURE__ */ new Set();\n      let timer;\n      let beforeLoadState = this.service.state;\n      const stateHandler = () => {\n        beforeLoadState = this.service.state;\n      };\n      this.emitter.on(ReplayerEvents.Start, stateHandler);\n      this.emitter.on(ReplayerEvents.Pause, stateHandler);\n      const unsubscribe = () => {\n        this.emitter.off(ReplayerEvents.Start, stateHandler);\n        this.emitter.off(ReplayerEvents.Pause, stateHandler);\n      };\n      head.querySelectorAll('link[rel=\"stylesheet\"]').forEach((css) => {\n        if (!css.sheet) {\n          unloadSheets.add(css);\n          css.addEventListener(\"load\", () => {\n            unloadSheets.delete(css);\n            if (unloadSheets.size === 0 && timer !== -1) {\n              if (beforeLoadState.matches(\"playing\")) {\n                this.play(this.getCurrentTime());\n              }\n              this.emitter.emit(ReplayerEvents.LoadStylesheetEnd);\n              if (timer) {\n                clearTimeout(timer);\n              }\n              unsubscribe();\n            }\n          });\n        }\n      });\n      if (unloadSheets.size > 0) {\n        this.service.send({ type: \"PAUSE\" });\n        this.emitter.emit(ReplayerEvents.LoadStylesheetStart);\n        timer = setTimeout$1(() => {\n          if (beforeLoadState.matches(\"playing\")) {\n            this.play(this.getCurrentTime());\n          }\n          timer = -1;\n          unsubscribe();\n        }, this.config.loadTimeout);\n      }\n    }\n  }\n  /**\n   * pause when there are some canvas drawImage args need to be loaded\n   */\n  async preloadAllImages() {\n    const promises = [];\n    for (const event of this.service.state.context.events) {\n      if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.CanvasMutation) {\n        promises.push(\n          this.deserializeAndPreloadCanvasEvents(event.data, event)\n        );\n        const commands = \"commands\" in event.data ? event.data.commands : [event.data];\n        commands.forEach((c2) => {\n          this.preloadImages(c2, event);\n        });\n      }\n    }\n    return Promise.all(promises);\n  }\n  preloadImages(data, event) {\n    if (data.property === \"drawImage\" && typeof data.args[0] === \"string\" && !this.imageMap.has(event)) {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      const imgd = ctx?.createImageData(canvas.width, canvas.height);\n      ctx?.putImageData(imgd, 0, 0);\n    }\n  }\n  async deserializeAndPreloadCanvasEvents(data, event) {\n    if (!this.canvasEventMap.has(event)) {\n      const status = {\n        isUnchanged: true\n      };\n      if (\"commands\" in data) {\n        const commands = await Promise.all(\n          data.commands.map(async (c2) => {\n            const args = await Promise.all(\n              c2.args.map(deserializeArg(this.imageMap, null, status))\n            );\n            return { ...c2, args };\n          })\n        );\n        if (status.isUnchanged === false)\n          this.canvasEventMap.set(event, { ...data, commands });\n      } else {\n        const args = await Promise.all(\n          data.args.map(deserializeArg(this.imageMap, null, status))\n        );\n        if (status.isUnchanged === false)\n          this.canvasEventMap.set(event, { ...data, args });\n      }\n    }\n  }\n  applyIncremental(e2, isSync) {\n    const { data: d } = e2;\n    switch (d.source) {\n      case IncrementalSource.Mutation: {\n        try {\n          this.applyMutation(d, isSync);\n        } catch (error) {\n          this.warn(`Exception in mutation ${error.message || error}`, d);\n        }\n        break;\n      }\n      case IncrementalSource.Drag:\n      case IncrementalSource.TouchMove:\n      case IncrementalSource.MouseMove: {\n        const pointerId = getPointerId(d);\n        if (!this.pointers[pointerId]) {\n          this.createPointer(pointerId, e2);\n        }\n        const pointer = this.pointers[pointerId];\n        if (isSync) {\n          const lastPosition = d.positions[d.positions.length - 1];\n          pointer.pointerPosition = {\n            x: lastPosition.x,\n            y: lastPosition.y,\n            id: lastPosition.id,\n            debugData: d\n          };\n        } else {\n          d.positions.forEach((p) => {\n            const action = {\n              doAction: () => {\n                this.moveAndHover(p.x, p.y, p.id, isSync, d, pointerId);\n              },\n              delay: p.timeOffset + e2.timestamp - this.service.state.context.baselineTime\n            };\n            this.timer.addAction(action);\n          });\n          this.timer.addAction({\n            doAction() {\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            delay: e2.delay - d.positions[0]?.timeOffset\n          });\n        }\n        break;\n      }\n      case IncrementalSource.MouseInteraction: {\n        const pointerId = getPointerId(d);\n        if (!this.pointers[pointerId]) {\n          this.createPointer(pointerId, e2);\n        }\n        const pointer = this.pointers[pointerId];\n        if (d.id === -1) {\n          break;\n        }\n        const event = new Event(toLowerCase(MouseInteractions[d.type]));\n        const target = this.mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n        this.emitter.emit(ReplayerEvents.MouseInteraction, {\n          type: d.type,\n          target\n        });\n        const { triggerFocus } = this.config;\n        switch (d.type) {\n          case MouseInteractions.Blur:\n            if (\"blur\" in target) {\n              target.blur();\n            }\n            break;\n          case MouseInteractions.Focus:\n            if (triggerFocus && target.focus) {\n              target.focus({\n                preventScroll: true\n              });\n            }\n            break;\n          case MouseInteractions.Click:\n          case MouseInteractions.TouchStart:\n          case MouseInteractions.TouchEnd:\n          case MouseInteractions.MouseDown:\n          case MouseInteractions.MouseUp:\n            if (isSync) {\n              if (d.type === MouseInteractions.TouchStart) {\n                pointer.touchActive = true;\n                Object.values(this.pointers).forEach((p) => {\n                  if (p !== pointer && !p.touchActive) {\n                    p.touchActive = false;\n                  }\n                });\n              } else if (d.type === MouseInteractions.TouchEnd) {\n                pointer.touchActive = false;\n                pointer.pointerEl.remove();\n                if (pointer.mouseTail) {\n                  pointer.mouseTail.remove();\n                }\n                delete this.pointers[pointerId];\n              }\n              if (d.type === MouseInteractions.MouseDown) {\n                this.lastMouseDownEvent = [target, event];\n              } else if (d.type === MouseInteractions.MouseUp) {\n                this.lastMouseDownEvent = null;\n              }\n              pointer.pointerPosition = {\n                x: d.x || 0,\n                y: d.y || 0,\n                id: d.id,\n                debugData: d\n              };\n            } else {\n              if (d.type === MouseInteractions.TouchStart) {\n                pointer.tailPositions.length = 0;\n              }\n              this.moveAndHover(d.x || 0, d.y || 0, d.id, isSync, d, pointerId);\n              if (d.type === MouseInteractions.Click) {\n                pointer.pointerEl.classList.remove(\"active\");\n                void pointer.pointerEl.offsetWidth;\n                pointer.pointerEl.classList.add(\"active\");\n              } else if (d.type === MouseInteractions.TouchStart) {\n                void pointer.pointerEl.offsetWidth;\n                pointer.pointerEl.classList.add(\"touch-active\");\n              } else if (d.type === MouseInteractions.TouchEnd) {\n                pointer.pointerEl.remove();\n                if (pointer.mouseTail) {\n                  pointer.mouseTail.remove();\n                }\n                delete this.pointers[pointerId];\n              } else {\n                target.dispatchEvent(event);\n              }\n            }\n            break;\n          case MouseInteractions.TouchCancel:\n            if (isSync) {\n              pointer.touchActive = false;\n            } else {\n              pointer.pointerEl.classList.remove(\"touch-active\");\n            }\n            break;\n          default:\n            target.dispatchEvent(event);\n        }\n        break;\n      }\n      case IncrementalSource.Scroll: {\n        if (d.id === -1) {\n          break;\n        }\n        if (this.usingVirtualDom) {\n          const target = this.virtualDom.mirror.getNode(d.id);\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n          target.scrollData = d;\n          break;\n        }\n        this.applyScroll(d, isSync);\n        break;\n      }\n      case IncrementalSource.ViewportResize:\n        this.emitter.emit(ReplayerEvents.Resize, {\n          width: d.width,\n          height: d.height\n        });\n        break;\n      case IncrementalSource.Input: {\n        if (d.id === -1) {\n          break;\n        }\n        if (this.usingVirtualDom) {\n          const target = this.virtualDom.mirror.getNode(d.id);\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n          target.inputData = d;\n          break;\n        }\n        this.applyInput(d);\n        break;\n      }\n      case IncrementalSource.MediaInteraction: {\n        const target = this.usingVirtualDom ? this.virtualDom.mirror.getNode(d.id) : this.mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n        const mediaEl = target;\n        try {\n          if (d.currentTime !== void 0) {\n            mediaEl.currentTime = d.currentTime;\n          }\n          if (d.volume !== void 0) {\n            mediaEl.volume = d.volume;\n          }\n          if (d.muted !== void 0) {\n            mediaEl.muted = d.muted;\n          }\n          if (d.type === MediaInteractions.Pause) {\n            mediaEl.pause();\n          }\n          if (d.type === MediaInteractions.Play) {\n            void mediaEl.play();\n          }\n          if (d.type === MediaInteractions.RateChange) {\n            mediaEl.playbackRate = d.playbackRate;\n          }\n        } catch (error) {\n          this.warn(\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions\n            `Failed to replay media interactions: ${error.message || error}`\n          );\n        }\n        break;\n      }\n      case IncrementalSource.StyleSheetRule:\n      case IncrementalSource.StyleDeclaration: {\n        if (this.usingVirtualDom) {\n          if (d.styleId) this.constructedStyleMutations.push(d);\n          else if (d.id)\n            this.virtualDom.mirror.getNode(d.id)?.rules?.push(d);\n        } else this.applyStyleSheetMutation(d);\n        break;\n      }\n      case IncrementalSource.CanvasMutation: {\n        if (!this.config.UNSAFE_replayCanvas) {\n          return;\n        }\n        if (this.usingVirtualDom) {\n          const target = this.virtualDom.mirror.getNode(\n            d.id\n          );\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n          target.canvasMutations.push({\n            event: e2,\n            mutation: d\n          });\n        } else {\n          const target = this.mirror.getNode(d.id);\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n          void canvasMutation({\n            event: e2,\n            mutation: d,\n            target,\n            imageMap: this.imageMap,\n            canvasEventMap: this.canvasEventMap,\n            errorHandler: this.warnCanvasMutationFailed.bind(this)\n          });\n        }\n        break;\n      }\n      case IncrementalSource.Font: {\n        try {\n          const fontFace = new FontFace(\n            d.family,\n            d.buffer ? new Uint8Array(JSON.parse(d.fontSource)) : d.fontSource,\n            d.descriptors\n          );\n          getIFrameContentDocument(this.iframe)?.fonts.add(fontFace);\n        } catch (error) {\n          this.warn(error);\n        }\n        break;\n      }\n      case IncrementalSource.Selection: {\n        if (isSync) {\n          this.lastSelectionData = d;\n          break;\n        }\n        this.applySelection(d);\n        break;\n      }\n      case IncrementalSource.AdoptedStyleSheet: {\n        if (this.usingVirtualDom) this.adoptedStyleSheets.push(d);\n        else this.applyAdoptedStyleSheet(d);\n        break;\n      }\n    }\n  }\n  applyMutation(d, isSync) {\n    if (this.config.useVirtualDom && !this.usingVirtualDom && isSync) {\n      this.usingVirtualDom = true;\n      const iframeDoc = getIFrameContentDocument(this.iframe);\n      if (iframeDoc) {\n        buildFromDom(iframeDoc, this.mirror, this.virtualDom);\n      }\n      if (Object.keys(this.legacy_missingNodeRetryMap).length) {\n        for (const key in this.legacy_missingNodeRetryMap) {\n          try {\n            const value = this.legacy_missingNodeRetryMap[key];\n            const virtualNode = buildFromNode(\n              value.node,\n              this.virtualDom,\n              this.mirror\n            );\n            if (virtualNode) value.node = virtualNode;\n          } catch (error) {\n            this.warn(error);\n          }\n        }\n      }\n    }\n    const mirror2 = this.usingVirtualDom ? this.virtualDom.mirror : this.mirror;\n    d.removes = d.removes.filter((mutation) => {\n      if (!mirror2.getNode(mutation.id)) {\n        this.warnNodeNotFound(d, mutation.id);\n        return false;\n      }\n      return true;\n    });\n    d.removes.forEach((mutation) => {\n      const target = mirror2.getNode(mutation.id);\n      if (!target) {\n        return;\n      }\n      let parent = mirror2.getNode(\n        mutation.parentId\n      );\n      if (!parent) {\n        return this.warnNodeNotFound(d, mutation.parentId);\n      }\n      if (mutation.isShadow && hasShadowRoot(parent)) {\n        parent = parent.shadowRoot;\n      }\n      mirror2.removeNodeFromMap(target);\n      if (parent)\n        try {\n          parent.removeChild(target);\n          if (this.usingVirtualDom && target.nodeName === \"#text\" && parent.nodeName === \"STYLE\" && parent.rules?.length > 0)\n            parent.rules = [];\n        } catch (error) {\n          if (error instanceof DOMException) {\n            this.warn(\n              \"parent could not remove child in mutation\",\n              parent,\n              target,\n              d\n            );\n          } else {\n            throw error;\n          }\n        }\n    });\n    const legacy_missingNodeMap = {\n      ...this.legacy_missingNodeRetryMap\n    };\n    const queue = [];\n    const nextNotInDOM = (mutation) => {\n      let next = null;\n      if (mutation.nextId) {\n        next = mirror2.getNode(mutation.nextId);\n      }\n      if (mutation.nextId !== null && mutation.nextId !== void 0 && mutation.nextId !== -1 && !next) {\n        return true;\n      }\n      return false;\n    };\n    const appendNode = (mutation) => {\n      const iframeDoc = getIFrameContentDocument(this.iframe);\n      if (!iframeDoc) {\n        return this.warn(\"Looks like your replayer has been destroyed.\");\n      }\n      let parent = mirror2.getNode(\n        mutation.parentId\n      );\n      if (!parent) {\n        if (mutation.node.type === NodeType$2.Document) {\n          return this.newDocumentQueue.push(mutation);\n        }\n        return queue.push(mutation);\n      }\n      if (mutation.node.isShadow) {\n        if (!hasShadowRoot(parent)) {\n          parent.attachShadow({ mode: \"open\" });\n          parent = parent.shadowRoot;\n        } else parent = parent.shadowRoot;\n      }\n      let previous = null;\n      let next = null;\n      if (mutation.previousId) {\n        previous = mirror2.getNode(mutation.previousId);\n      }\n      if (mutation.nextId) {\n        next = mirror2.getNode(mutation.nextId);\n      }\n      if (nextNotInDOM(mutation)) {\n        return queue.push(mutation);\n      }\n      if (mutation.node.rootId && !mirror2.getNode(mutation.node.rootId)) {\n        return;\n      }\n      const targetDoc = mutation.node.rootId ? mirror2.getNode(mutation.node.rootId) : this.usingVirtualDom ? this.virtualDom : iframeDoc;\n      if (isSerializedIframe(parent, mirror2)) {\n        this.attachDocumentToIframe(\n          mutation,\n          parent\n        );\n        return;\n      }\n      const afterAppend = (node, id) => {\n        if (this.usingVirtualDom) return;\n        for (const plugin of this.config.plugins || []) {\n          if (plugin.onBuild) plugin.onBuild(node, { id, replayer: this });\n        }\n      };\n      const target = buildNodeWithSN(mutation.node, {\n        doc: targetDoc,\n        // can be Document or RRDocument\n        mirror: mirror2,\n        // can be this.mirror or virtualDom.mirror\n        skipChild: true,\n        hackCss: true,\n        cache: this.cache,\n        /**\n         * caveat: `afterAppend` only gets called on child nodes of target\n         * we have to call it again below when this target was added to the DOM\n         */\n        afterAppend\n      });\n      if (mutation.previousId === -1 || mutation.nextId === -1) {\n        legacy_missingNodeMap[mutation.node.id] = {\n          node: target,\n          mutation\n        };\n        return;\n      }\n      const parentSn = mirror2.getMeta(parent);\n      if (parentSn && parentSn.type === NodeType$2.Element && parentSn.tagName === \"textarea\" && mutation.node.type === NodeType$2.Text) {\n        const childNodeArray = Array.isArray(parent.childNodes) ? parent.childNodes : Array.from(parent.childNodes);\n        for (const c2 of childNodeArray) {\n          if (c2.nodeType === parent.TEXT_NODE) {\n            parent.removeChild(c2);\n          }\n        }\n      } else if (parentSn?.type === NodeType$2.Document) {\n        const parentDoc = parent;\n        if (mutation.node.type === NodeType$2.DocumentType && parentDoc.childNodes[0]?.nodeType === Node.DOCUMENT_TYPE_NODE)\n          parentDoc.removeChild(parentDoc.childNodes[0]);\n        if (target.nodeName === \"HTML\" && parentDoc.documentElement)\n          parentDoc.removeChild(\n            parentDoc.documentElement\n          );\n      }\n      if (previous && previous.nextSibling && previous.nextSibling.parentNode) {\n        parent.insertBefore(\n          target,\n          previous.nextSibling\n        );\n      } else if (next && next.parentNode) {\n        parent.contains(next) ? parent.insertBefore(target, next) : parent.insertBefore(target, null);\n      } else {\n        parent.appendChild(target);\n      }\n      afterAppend(target, mutation.node.id);\n      if (this.usingVirtualDom && target.nodeName === \"#text\" && parent.nodeName === \"STYLE\" && parent.rules?.length > 0)\n        parent.rules = [];\n      if (isSerializedIframe(target, this.mirror)) {\n        const targetId = this.mirror.getId(target);\n        const mutationInQueue = this.newDocumentQueue.find(\n          (m) => m.parentId === targetId\n        );\n        if (mutationInQueue) {\n          this.attachDocumentToIframe(\n            mutationInQueue,\n            target\n          );\n          this.newDocumentQueue = this.newDocumentQueue.filter(\n            (m) => m !== mutationInQueue\n          );\n        }\n      }\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(\n          legacy_missingNodeMap,\n          parent,\n          target,\n          mutation\n        );\n      }\n    };\n    d.adds.forEach((mutation) => {\n      appendNode(mutation);\n    });\n    const startTime = Date.now();\n    while (queue.length) {\n      const resolveTrees = queueToResolveTrees(queue);\n      queue.length = 0;\n      if (Date.now() - startTime > 500) {\n        this.warn(\n          \"Timeout in the loop, please check the resolve tree data:\",\n          resolveTrees\n        );\n        break;\n      }\n      for (const tree of resolveTrees) {\n        const parent = mirror2.getNode(tree.value.parentId);\n        if (!parent) {\n          this.debug(\n            \"Drop resolve tree since there is no parent for the root node.\",\n            tree\n          );\n        } else {\n          iterateResolveTree(tree, (mutation) => {\n            appendNode(mutation);\n          });\n        }\n      }\n    }\n    if (Object.keys(legacy_missingNodeMap).length) {\n      Object.assign(this.legacy_missingNodeRetryMap, legacy_missingNodeMap);\n    }\n    uniqueTextMutations(d.texts).forEach((mutation) => {\n      const target = mirror2.getNode(mutation.id);\n      if (!target) {\n        if (d.removes.find((r2) => r2.id === mutation.id)) {\n          return;\n        }\n        return this.warnNodeNotFound(d, mutation.id);\n      }\n      target.textContent = mutation.value;\n      if (this.usingVirtualDom) {\n        const parent = target.parentNode;\n        if (parent?.rules?.length > 0) parent.rules = [];\n      }\n    });\n    d.attributes.forEach((mutation) => {\n      const target = mirror2.getNode(mutation.id);\n      if (!target) {\n        if (d.removes.find((r2) => r2.id === mutation.id)) {\n          return;\n        }\n        return this.warnNodeNotFound(d, mutation.id);\n      }\n      for (const attributeName in mutation.attributes) {\n        if (typeof attributeName === \"string\") {\n          const value = mutation.attributes[attributeName];\n          if (value === null) {\n            target.removeAttribute(attributeName);\n          } else if (typeof value === \"string\") {\n            try {\n              if (attributeName === \"_cssText\" && (target.nodeName === \"LINK\" || target.nodeName === \"STYLE\")) {\n                try {\n                  const newSn = mirror2.getMeta(\n                    target\n                  );\n                  const newNode = buildNodeWithSN(\n                    {\n                      ...newSn,\n                      attributes: {\n                        ...newSn.attributes,\n                        ...mutation.attributes\n                      }\n                    },\n                    {\n                      doc: target.ownerDocument,\n                      // can be Document or RRDocument\n                      mirror: mirror2,\n                      skipChild: true,\n                      hackCss: true,\n                      cache: this.cache\n                    }\n                  );\n                  const siblingNode = target.nextSibling;\n                  const parentNode = target.parentNode;\n                  if (newNode && parentNode) {\n                    parentNode.removeChild(target);\n                    parentNode.insertBefore(\n                      newNode,\n                      siblingNode\n                    );\n                    mirror2.replace(mutation.id, newNode);\n                    break;\n                  }\n                } catch (e2) {\n                }\n              }\n              target.setAttribute(\n                attributeName,\n                value\n              );\n            } catch (error) {\n              this.warn(\n                \"An error occurred may due to the checkout feature.\",\n                error\n              );\n            }\n          } else if (attributeName === \"style\") {\n            const styleValues = value;\n            const targetEl = target;\n            for (const s2 in styleValues) {\n              if (styleValues[s2] === false) {\n                targetEl.style.removeProperty(s2);\n              } else if (styleValues[s2] instanceof Array) {\n                const svp = styleValues[s2];\n                targetEl.style.setProperty(s2, svp[0], svp[1]);\n              } else {\n                const svs = styleValues[s2];\n                targetEl.style.setProperty(s2, svs);\n              }\n            }\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Apply the scroll data on real elements.\n   * If the replayer is in sync mode, smooth scroll behavior should be disabled.\n   * @param d - the scroll data\n   * @param isSync - whether the replayer is in sync mode(fast-forward)\n   */\n  applyScroll(d, isSync) {\n    const target = this.mirror.getNode(d.id);\n    if (!target) {\n      return this.debugNodeNotFound(d, d.id);\n    }\n    const sn = this.mirror.getMeta(target);\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    if (target === iframeDoc) {\n      this.iframe.contentWindow?.scrollTo({\n        top: d.y,\n        left: d.x,\n        behavior: isSync ? \"auto\" : \"smooth\"\n      });\n    } else if (sn?.type === NodeType$2.Document) {\n      target.defaultView?.scrollTo({\n        top: d.y,\n        left: d.x,\n        behavior: isSync ? \"auto\" : \"smooth\"\n      });\n    } else {\n      try {\n        target.scrollTo({\n          top: d.y,\n          left: d.x,\n          behavior: isSync ? \"auto\" : \"smooth\"\n        });\n      } catch (error) {\n      }\n    }\n  }\n  applyInput(d) {\n    const target = this.mirror.getNode(d.id);\n    if (!target) {\n      return this.debugNodeNotFound(d, d.id);\n    }\n    try {\n      target.checked = d.isChecked;\n      target.value = d.text;\n    } catch (error) {\n    }\n  }\n  applySelection(d) {\n    try {\n      const selectionSet = /* @__PURE__ */ new Set();\n      const ranges = d.ranges.map(({ start, startOffset, end, endOffset }) => {\n        const startContainer = this.mirror.getNode(start);\n        const endContainer = this.mirror.getNode(end);\n        if (!startContainer || !endContainer) return;\n        const result = new Range();\n        result.setStart(startContainer, startOffset);\n        result.setEnd(endContainer, endOffset);\n        const doc = startContainer.ownerDocument;\n        const selection = doc?.getSelection();\n        selection && selectionSet.add(selection);\n        return {\n          range: result,\n          selection\n        };\n      });\n      selectionSet.forEach((s2) => s2.removeAllRanges());\n      ranges.forEach((r2) => r2 && r2.selection?.addRange(r2.range));\n    } catch (error) {\n    }\n  }\n  applyStyleSheetMutation(data) {\n    let styleSheet = null;\n    if (data.styleId) styleSheet = this.styleMirror.getStyle(data.styleId);\n    else if (data.id)\n      styleSheet = this.mirror.getNode(data.id)?.sheet || null;\n    if (!styleSheet) return;\n    if (data.source === IncrementalSource.StyleSheetRule)\n      this.applyStyleSheetRule(data, styleSheet);\n    else if (data.source === IncrementalSource.StyleDeclaration)\n      this.applyStyleDeclaration(data, styleSheet);\n  }\n  applyStyleSheetRule(data, styleSheet) {\n    data.adds?.forEach(({ rule, index: nestedIndex }) => {\n      try {\n        if (Array.isArray(nestedIndex)) {\n          const { positions, index } = getPositionsAndIndex(nestedIndex);\n          const nestedRule = getNestedRule(styleSheet.cssRules, positions);\n          nestedRule.insertRule(rule, index);\n        } else {\n          const index = nestedIndex === void 0 ? void 0 : Math.min(nestedIndex, styleSheet.cssRules.length);\n          styleSheet?.insertRule(rule, index);\n        }\n      } catch (e2) {\n      }\n    });\n    data.removes?.forEach(({ index: nestedIndex }) => {\n      try {\n        if (Array.isArray(nestedIndex)) {\n          const { positions, index } = getPositionsAndIndex(nestedIndex);\n          const nestedRule = getNestedRule(styleSheet.cssRules, positions);\n          nestedRule.deleteRule(index || 0);\n        } else {\n          styleSheet?.deleteRule(nestedIndex);\n        }\n      } catch (e2) {\n      }\n    });\n    if (data.replace)\n      try {\n        void styleSheet.replace?.(data.replace);\n      } catch (e2) {\n      }\n    if (data.replaceSync)\n      try {\n        styleSheet.replaceSync?.(data.replaceSync);\n      } catch (e2) {\n      }\n  }\n  applyStyleDeclaration(data, styleSheet) {\n    if (data.set) {\n      const rule = getNestedRule(\n        styleSheet.rules,\n        data.index\n      );\n      rule && rule.style && rule.style.setProperty(\n        data.set.property,\n        data.set.value,\n        data.set.priority\n      );\n    }\n    if (data.remove) {\n      const rule = getNestedRule(\n        styleSheet.rules,\n        data.index\n      );\n      rule && rule.style && rule.style.removeProperty(data.remove.property);\n    }\n  }\n  applyAdoptedStyleSheet(data) {\n    const targetHost = this.mirror.getNode(data.id);\n    if (!targetHost) return;\n    data.styles?.forEach((style) => {\n      let newStyleSheet = null;\n      let hostWindow = null;\n      if (hasShadowRoot(targetHost))\n        hostWindow = targetHost.ownerDocument?.defaultView || null;\n      else if (targetHost.nodeName === \"#document\")\n        hostWindow = targetHost.defaultView;\n      if (!hostWindow) return;\n      try {\n        newStyleSheet = new hostWindow.CSSStyleSheet();\n        this.styleMirror.add(newStyleSheet, style.styleId);\n        this.applyStyleSheetRule(\n          {\n            source: IncrementalSource.StyleSheetRule,\n            adds: style.rules\n          },\n          newStyleSheet\n        );\n      } catch (e2) {\n      }\n    });\n    const MAX_RETRY_TIME = 10;\n    let count = 0;\n    const adoptStyleSheets = (targetHost2, styleIds) => {\n      const stylesToAdopt = styleIds.map((styleId) => this.styleMirror.getStyle(styleId)).filter((style) => style !== null);\n      if (hasShadowRoot(targetHost2))\n        targetHost2.shadowRoot.adoptedStyleSheets = stylesToAdopt;\n      else if (targetHost2.nodeName === \"#document\")\n        targetHost2.adoptedStyleSheets = stylesToAdopt;\n      if (stylesToAdopt.length !== styleIds.length && count < MAX_RETRY_TIME) {\n        setTimeout$1(\n          () => adoptStyleSheets(targetHost2, styleIds),\n          0 + 100 * count\n        );\n        count++;\n      }\n    };\n    adoptStyleSheets(targetHost, data.styleIds);\n  }\n  legacy_resolveMissingNode(map, parent, target, targetMutation) {\n    const { previousId, nextId } = targetMutation;\n    const previousInMap = previousId && map[previousId];\n    const nextInMap = nextId && map[nextId];\n    if (previousInMap) {\n      const { node, mutation } = previousInMap;\n      parent.insertBefore(node, target);\n      delete map[mutation.node.id];\n      delete this.legacy_missingNodeRetryMap[mutation.node.id];\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(map, parent, node, mutation);\n      }\n    }\n    if (nextInMap) {\n      const { node, mutation } = nextInMap;\n      parent.insertBefore(\n        node,\n        target.nextSibling\n      );\n      delete map[mutation.node.id];\n      delete this.legacy_missingNodeRetryMap[mutation.node.id];\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(map, parent, node, mutation);\n      }\n    }\n  }\n  moveAndHover(x, y, id, isSync, debugData, pointerId) {\n    const target = this.mirror.getNode(id);\n    if (!target) {\n      return this.debugNodeNotFound(debugData, id);\n    }\n    const base = getBaseDimension(target, this.iframe);\n    const _x = x * base.absoluteScale + base.x;\n    const _y = y * base.absoluteScale + base.y;\n    const pointer = this.pointers[pointerId];\n    if (pointer && pointer.pointerEl) {\n      pointer.pointerEl.style.left = `${_x}px`;\n      pointer.pointerEl.style.top = `${_y}px`;\n    }\n    if (!isSync) {\n      this.drawMouseTail({ x: _x, y: _y }, pointerId);\n    }\n    this.hoverElements(target);\n  }\n  drawMouseTail(position, pointerId) {\n    const pointer = this.pointers[pointerId];\n    if (!pointer || !pointer.mouseTail) {\n      return;\n    }\n    const { lineCap, lineWidth, strokeStyle, duration } = this.config.mouseTail === true ? defaultMouseTailConfig : Object.assign({}, defaultMouseTailConfig, this.config.mouseTail);\n    const draw = () => {\n      if (!pointer || !pointer.mouseTail) {\n        return;\n      }\n      const mouseTail = pointer.mouseTail;\n      const ctx = mouseTail.getContext(\"2d\");\n      if (!ctx || !pointer.tailPositions.length) {\n        return;\n      }\n      ctx.clearRect(0, 0, mouseTail.width, mouseTail.height);\n      ctx.beginPath();\n      ctx.lineWidth = lineWidth;\n      ctx.lineCap = lineCap;\n      ctx.strokeStyle = strokeStyle;\n      ctx.moveTo(pointer.tailPositions[0].x, pointer.tailPositions[0].y);\n      pointer.tailPositions.forEach((p) => ctx.lineTo(p.x, p.y));\n      ctx.stroke();\n    };\n    pointer.tailPositions.push(position);\n    draw();\n    setTimeout$1(() => {\n      if (pointerId in this.pointers) {\n        pointer.tailPositions = pointer.tailPositions.filter(\n          (p) => p !== position\n        );\n        draw();\n      }\n    }, duration / this.speedService.state.context.timer.speed);\n  }\n  hoverElements(el) {\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    const rootElement = this.lastHoveredRootNode || iframeDoc;\n    if (rootElement && typeof rootElement.querySelectorAll === \"function\") {\n      rootElement.querySelectorAll(\".\\\\:hover\").forEach((hoveredEl) => {\n        hoveredEl.classList.remove(\":hover\");\n      });\n    }\n    this.lastHoveredRootNode = el.getRootNode();\n    let currentEl = el;\n    while (currentEl) {\n      if (currentEl.classList) {\n        currentEl.classList.add(\":hover\");\n      }\n      currentEl = currentEl.parentElement;\n    }\n  }\n  isUserInteraction(event) {\n    if (event.type !== EventType.IncrementalSnapshot) {\n      return false;\n    }\n    return event.data.source > IncrementalSource.Mutation && event.data.source <= IncrementalSource.Input;\n  }\n  backToNormal() {\n    this.nextUserInteractionEvent = null;\n    if (this.speedService.state.matches(\"normal\")) {\n      return;\n    }\n    this.speedService.send({ type: \"BACK_TO_NORMAL\" });\n    this.emitter.emit(ReplayerEvents.SkipEnd, {\n      speed: this.speedService.state.context.normalSpeed\n    });\n  }\n  warnNodeNotFound(d, id) {\n    this.warn(`Node with id '${id}' not found. `, d);\n  }\n  warnCanvasMutationFailed(d, error) {\n    this.warn(`Has error on canvas update`, error, \"canvas mutation:\", d);\n  }\n  debugNodeNotFound(d, id) {\n    this.debug(`Node with id '${id}' not found. `, d);\n  }\n  warn(...args) {\n    if (!this.config.showWarning) {\n      return;\n    }\n    this.config.logger.warn(REPLAY_CONSOLE_PREFIX, ...args);\n  }\n  debug(...args) {\n    if (!this.config.showDebug) {\n      return;\n    }\n    this.config.logger.log(REPLAY_CONSOLE_PREFIX, ...args);\n  }\n}\nexport {\n  CanvasManager,\n  EventType,\n  IncrementalSource,\n  MouseInteractions,\n  Replayer,\n  ReplayerEvents,\n  addCustomEvent,\n  canvasMutation,\n  deserializeArg,\n  freezePage,\n  record,\n  takeFullSnapshot,\n  utils\n};\n//# sourceMappingURL=rrweb.js.map\n","type ClassOption = string | RegExp;\n\n/** Duplicate this from @sentry-internal/rrweb so we can export this as well. */\nexport const ReplayEventTypeDomContentLoaded = 0;\nexport const ReplayEventTypeLoad = 1;\nexport const ReplayEventTypeFullSnapshot = 2;\nexport const ReplayEventTypeIncrementalSnapshot = 3;\nexport const ReplayEventTypeMeta = 4;\nexport const ReplayEventTypeCustom = 5;\nexport const ReplayEventTypePlugin = 6;\n\nexport type ReplayEventType =\n  | typeof ReplayEventTypeDomContentLoaded\n  | typeof ReplayEventTypeLoad\n  | typeof ReplayEventTypeFullSnapshot\n  | typeof ReplayEventTypeIncrementalSnapshot\n  | typeof ReplayEventTypeMeta\n  | typeof ReplayEventTypeCustom\n  | typeof ReplayEventTypePlugin;\n\n/**\n * This is a partial copy of rrweb's eventWithTime type which only contains the properties\n * we specifically need in the SDK.\n */\nexport type ReplayEventWithTime = {\n  type: ReplayEventType;\n  data: unknown;\n  timestamp: number;\n  delay?: number;\n};\n\n/**\n * This is a partial copy of rrweb's recording options which only contains the properties\n * we specifically use in the SDK. Users can specify additional properties, hence we add the\n * Record<string, unknown> union type.\n */\nexport type RrwebRecordOptions = {\n  maskAllText?: boolean;\n  maskAllInputs?: boolean;\n  blockClass?: ClassOption;\n  ignoreClass?: string;\n  maskTextClass?: ClassOption;\n  maskTextSelector?: string;\n  blockSelector?: string;\n  maskInputOptions?: Record<string, boolean>;\n  recordCrossOriginIframes?: boolean;\n} & Record<string, unknown>;\n\nexport interface CanvasManagerInterface {\n  reset(): void;\n  freeze(): void;\n  unfreeze(): void;\n  lock(): void;\n  unlock(): void;\n  snapshot(): void;\n  addWindow(win: typeof globalThis & Window): void;\n  addShadowRoot(shadowRoot: ShadowRoot): void;\n  resetShadowRoots(): void;\n}\n\nexport interface CanvasManagerOptions {\n  recordCanvas: boolean;\n  enableManualSnapshot?: boolean;\n  blockClass: string | RegExp;\n  blockSelector: string | null;\n  unblockSelector: string | null;\n  sampling?: 'all' | number;\n  dataURLOptions: Partial<{\n    type: string;\n    quality: number;\n  }>;\n  mutationCb: (p: any) => void;\n  win: typeof globalThis & Window;\n  mirror: any;\n}\n","/**\n * Converts a timestamp to ms, if it was in s, or keeps it as ms.\n */\nexport function timestampToMs(timestamp: number): number {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp : timestamp * 1000;\n}\n\n/**\n * Converts a timestamp to s, if it was in ms, or keeps it as s.\n */\nexport function timestampToS(timestamp: number): number {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n","import { EventType } from '@sentry-internal/rrweb';\nimport { normalize } from '@sentry/core';\nimport type { Breadcrumb } from '@sentry/core';\n\nimport type { ReplayContainer } from '../../types';\n\n/**\n * Add a breadcrumb event to replay.\n */\nexport function addBreadcrumbEvent(replay: ReplayContainer, breadcrumb: Breadcrumb): void {\n  if (breadcrumb.category === 'sentry.transaction') {\n    return;\n  }\n\n  if (['ui.click', 'ui.input'].includes(breadcrumb.category as string)) {\n    replay.triggerUserActivity();\n  } else {\n    replay.checkAndHandleExpiredSession();\n  }\n\n  replay.addUpdate(() => {\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      // TODO: We were converting from ms to seconds for breadcrumbs, spans,\n      // but maybe we should just keep them as milliseconds\n      timestamp: (breadcrumb.timestamp || 0) * 1000,\n      data: {\n        tag: 'breadcrumb',\n        // normalize to max. 10 depth and 1_000 properties per object\n        payload: normalize(breadcrumb, 10, 1_000),\n      },\n    });\n\n    // Do not flush after console log messages\n    return breadcrumb.category === 'console';\n  });\n}\n","import type { INode } from '@sentry-internal/rrweb-snapshot';\n\nconst INTERACTIVE_SELECTOR = 'button,a';\n\n/** Get the closest interactive parent element, or else return the given element. */\nexport function getClosestInteractive(element: Element): Element {\n  const closestInteractive = element.closest(INTERACTIVE_SELECTOR);\n  return closestInteractive || element;\n}\n\n/**\n * For clicks, we check if the target is inside of a button or link\n * If so, we use this as the target instead\n * This is useful because if you click on the image in <button><img></button>,\n * The target will be the image, not the button, which we don't want here\n */\nexport function getClickTargetNode(event: Event | MouseEvent | Node): Node | INode | null {\n  const target = getTargetNode(event);\n\n  if (!target || !(target instanceof Element)) {\n    return target;\n  }\n\n  return getClosestInteractive(target);\n}\n\n/** Get the event target node. */\nexport function getTargetNode(event: Node | { target: EventTarget | null }): Node | INode | null {\n  if (isEventWithTarget(event)) {\n    return event.target as Node | null;\n  }\n\n  return event;\n}\n\nfunction isEventWithTarget(event: unknown): event is { target: EventTarget | null } {\n  return typeof event === 'object' && !!event && 'target' in event;\n}\n","import { fill } from '@sentry/core';\n\nimport { WINDOW } from '../../constants';\n\ntype WindowOpenHandler = () => void;\n\nlet handlers: undefined | WindowOpenHandler[];\n\n/**\n * Register a handler to be called when `window.open()` is called.\n * Returns a cleanup function.\n */\nexport function onWindowOpen(cb: WindowOpenHandler): () => void {\n  // Ensure to only register this once\n  if (!handlers) {\n    handlers = [];\n    monkeyPatchWindowOpen();\n  }\n\n  handlers.push(cb);\n\n  return () => {\n    const pos = handlers ? handlers.indexOf(cb) : -1;\n    if (pos > -1) {\n      (handlers as WindowOpenHandler[]).splice(pos, 1);\n    }\n  };\n}\n\nfunction monkeyPatchWindowOpen(): void {\n  fill(WINDOW, 'open', function (originalWindowOpen: () => void): () => void {\n    return function (...args: unknown[]): void {\n      if (handlers) {\n        try {\n          handlers.forEach(handler => handler());\n        } catch (e) {\n          // ignore errors in here\n        }\n      }\n\n      return originalWindowOpen.apply(WINDOW, args);\n    };\n  });\n}\n","import { setTimeout } from '@sentry-internal/browser-utils';\nimport { IncrementalSource, MouseInteractions, record } from '@sentry-internal/rrweb';\nimport type { Breadcrumb } from '@sentry/core';\n\nimport { WINDOW } from '../constants';\nimport type {\n  RecordingEvent,\n  ReplayClickDetector,\n  ReplayContainer,\n  ReplayMultiClickFrame,\n  ReplaySlowClickFrame,\n  SlowClickConfig,\n} from '../types';\nimport { ReplayEventTypeIncrementalSnapshot } from '../types';\nimport { timestampToS } from '../util/timestamp';\nimport { addBreadcrumbEvent } from './util/addBreadcrumbEvent';\nimport { getClosestInteractive } from './util/domUtils';\nimport { onWindowOpen } from './util/onWindowOpen';\n\ntype ClickBreadcrumb = Breadcrumb & {\n  timestamp: number;\n};\n\ninterface Click {\n  timestamp: number;\n  mutationAfter?: number;\n  scrollAfter?: number;\n  clickBreadcrumb: ClickBreadcrumb;\n  clickCount: number;\n  node: HTMLElement;\n}\n\ntype IncrementalRecordingEvent = RecordingEvent & {\n  type: typeof ReplayEventTypeIncrementalSnapshot;\n  data: { source: IncrementalSource };\n};\n\ntype IncrementalMouseInteractionRecordingEvent = IncrementalRecordingEvent & {\n  type: typeof ReplayEventTypeIncrementalSnapshot;\n  data: { type: MouseInteractions; id: number };\n};\n\n/** Any IncrementalSource for rrweb that we interpret as a kind of mutation. */\nconst IncrementalMutationSources = new Set([\n  IncrementalSource.Mutation,\n  IncrementalSource.StyleSheetRule,\n  IncrementalSource.StyleDeclaration,\n  IncrementalSource.AdoptedStyleSheet,\n  IncrementalSource.CanvasMutation,\n  IncrementalSource.Selection,\n  IncrementalSource.MediaInteraction,\n]);\n\n/** Handle a click. */\nexport function handleClick(clickDetector: ReplayClickDetector, clickBreadcrumb: Breadcrumb, node: HTMLElement): void {\n  clickDetector.handleClick(clickBreadcrumb, node);\n}\n\n/** A click detector class that can be used to detect slow or rage clicks on elements. */\nexport class ClickDetector implements ReplayClickDetector {\n  // protected for testing\n  protected _lastMutation: number;\n  protected _lastScroll: number;\n\n  private _clicks: Click[];\n  private _teardown: undefined | (() => void);\n\n  private _threshold: number;\n  private _scrollTimeout: number;\n  private _timeout: number;\n  private _ignoreSelector: string;\n\n  private _replay: ReplayContainer;\n  private _checkClickTimeout?: ReturnType<typeof setTimeout>;\n  private _addBreadcrumbEvent: typeof addBreadcrumbEvent;\n\n  public constructor(\n    replay: ReplayContainer,\n    slowClickConfig: SlowClickConfig,\n    // Just for easier testing\n    _addBreadcrumbEvent = addBreadcrumbEvent,\n  ) {\n    this._lastMutation = 0;\n    this._lastScroll = 0;\n    this._clicks = [];\n\n    // We want everything in s, but options are in ms\n    this._timeout = slowClickConfig.timeout / 1000;\n    this._threshold = slowClickConfig.threshold / 1000;\n    this._scrollTimeout = slowClickConfig.scrollTimeout / 1000;\n    this._replay = replay;\n    this._ignoreSelector = slowClickConfig.ignoreSelector;\n    this._addBreadcrumbEvent = _addBreadcrumbEvent;\n  }\n\n  /** Register click detection handlers on mutation or scroll. */\n  public addListeners(): void {\n    const cleanupWindowOpen = onWindowOpen(() => {\n      // Treat window.open as mutation\n      this._lastMutation = nowInSeconds();\n    });\n\n    this._teardown = () => {\n      cleanupWindowOpen();\n\n      this._clicks = [];\n      this._lastMutation = 0;\n      this._lastScroll = 0;\n    };\n  }\n\n  /** Clean up listeners. */\n  public removeListeners(): void {\n    if (this._teardown) {\n      this._teardown();\n    }\n\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n  }\n\n  /** @inheritDoc */\n  public handleClick(breadcrumb: Breadcrumb, node: HTMLElement): void {\n    if (ignoreElement(node, this._ignoreSelector) || !isClickBreadcrumb(breadcrumb)) {\n      return;\n    }\n\n    const newClick: Click = {\n      timestamp: timestampToS(breadcrumb.timestamp),\n      clickBreadcrumb: breadcrumb,\n      // Set this to 0 so we know it originates from the click breadcrumb\n      clickCount: 0,\n      node,\n    };\n\n    // If there was a click in the last 1s on the same element, ignore it - only keep a single reference per second\n    if (\n      this._clicks.some(click => click.node === newClick.node && Math.abs(click.timestamp - newClick.timestamp) < 1)\n    ) {\n      return;\n    }\n\n    this._clicks.push(newClick);\n\n    // If this is the first new click, set a timeout to check for multi clicks\n    if (this._clicks.length === 1) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** @inheritDoc */\n  public registerMutation(timestamp = Date.now()): void {\n    this._lastMutation = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n  public registerScroll(timestamp = Date.now()): void {\n    this._lastScroll = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n  public registerClick(element: HTMLElement): void {\n    const node = getClosestInteractive(element);\n    this._handleMultiClick(node as HTMLElement);\n  }\n\n  /** Count multiple clicks on elements. */\n  private _handleMultiClick(node: HTMLElement): void {\n    this._getClicks(node).forEach(click => {\n      click.clickCount++;\n    });\n  }\n\n  /** Get all pending clicks for a given node. */\n  private _getClicks(node: HTMLElement): Click[] {\n    return this._clicks.filter(click => click.node === node);\n  }\n\n  /** Check the clicks that happened. */\n  private _checkClicks(): void {\n    const timedOutClicks: Click[] = [];\n\n    const now = nowInSeconds();\n\n    this._clicks.forEach(click => {\n      if (!click.mutationAfter && this._lastMutation) {\n        click.mutationAfter = click.timestamp <= this._lastMutation ? this._lastMutation - click.timestamp : undefined;\n      }\n      if (!click.scrollAfter && this._lastScroll) {\n        click.scrollAfter = click.timestamp <= this._lastScroll ? this._lastScroll - click.timestamp : undefined;\n      }\n\n      // All of these are in seconds!\n      if (click.timestamp + this._timeout <= now) {\n        timedOutClicks.push(click);\n      }\n    });\n\n    // Remove \"old\" clicks\n    for (const click of timedOutClicks) {\n      const pos = this._clicks.indexOf(click);\n\n      if (pos > -1) {\n        this._generateBreadcrumbs(click);\n        this._clicks.splice(pos, 1);\n      }\n    }\n\n    // Trigger new check, unless no clicks left\n    if (this._clicks.length) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** Generate matching breadcrumb(s) for the click. */\n  private _generateBreadcrumbs(click: Click): void {\n    const replay = this._replay;\n    const hadScroll = click.scrollAfter && click.scrollAfter <= this._scrollTimeout;\n    const hadMutation = click.mutationAfter && click.mutationAfter <= this._threshold;\n\n    const isSlowClick = !hadScroll && !hadMutation;\n    const { clickCount, clickBreadcrumb } = click;\n\n    // Slow click\n    if (isSlowClick) {\n      // If `mutationAfter` is set, it means a mutation happened after the threshold, but before the timeout\n      // If not, it means we just timed out without scroll & mutation\n      const timeAfterClickMs = Math.min(click.mutationAfter || this._timeout, this._timeout) * 1000;\n      const endReason = timeAfterClickMs < this._timeout * 1000 ? 'mutation' : 'timeout';\n\n      const breadcrumb: ReplaySlowClickFrame = {\n        type: 'default',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: 'ui.slowClickDetected',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          timeAfterClickMs,\n          endReason,\n          // If clickCount === 0, it means multiClick was not correctly captured here\n          // - we still want to send 1 in this case\n          clickCount: clickCount || 1,\n        },\n      };\n\n      this._addBreadcrumbEvent(replay, breadcrumb);\n      return;\n    }\n\n    // Multi click\n    if (clickCount > 1) {\n      const breadcrumb: ReplayMultiClickFrame = {\n        type: 'default',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: 'ui.multiClick',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          clickCount,\n          metric: true,\n        },\n      };\n\n      this._addBreadcrumbEvent(replay, breadcrumb);\n    }\n  }\n\n  /** Schedule to check current clicks. */\n  private _scheduleCheckClicks(): void {\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n\n    this._checkClickTimeout = setTimeout(() => this._checkClicks(), 1000);\n  }\n}\n\nconst SLOW_CLICK_TAGS = ['A', 'BUTTON', 'INPUT'];\n\n/** exported for tests only */\nexport function ignoreElement(node: HTMLElement, ignoreSelector: string): boolean {\n  if (!SLOW_CLICK_TAGS.includes(node.tagName)) {\n    return true;\n  }\n\n  // If <input> tag, we only want to consider input[type='submit'] & input[type='button']\n  if (node.tagName === 'INPUT' && !['submit', 'button'].includes(node.getAttribute('type') || '')) {\n    return true;\n  }\n\n  // If <a> tag, detect special variants that may not lead to an action\n  // If target !== _self, we may open the link somewhere else, which would lead to no action\n  // Also, when downloading a file, we may not leave the page, but still not trigger an action\n  if (\n    node.tagName === 'A' &&\n    (node.hasAttribute('download') || (node.hasAttribute('target') && node.getAttribute('target') !== '_self'))\n  ) {\n    return true;\n  }\n\n  if (ignoreSelector && node.matches(ignoreSelector)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isClickBreadcrumb(breadcrumb: Breadcrumb): breadcrumb is ClickBreadcrumb {\n  return !!(breadcrumb.data && typeof breadcrumb.data.nodeId === 'number' && breadcrumb.timestamp);\n}\n\n// This is good enough for us, and is easier to test/mock than `timestampInSeconds`\nfunction nowInSeconds(): number {\n  return Date.now() / 1000;\n}\n\n/** Update the click detector based on a recording event of rrweb. */\nexport function updateClickDetectorForRecordingEvent(clickDetector: ReplayClickDetector, event: RecordingEvent): void {\n  try {\n    // note: We only consider incremental snapshots here\n    // This means that any full snapshot is ignored for mutation detection - the reason is that we simply cannot know if a mutation happened here.\n    // E.g. think that we are buffering, an error happens and we take a full snapshot because we switched to session mode -\n    // in this scenario, we would not know if a dead click happened because of the error, which is a key dead click scenario.\n    // Instead, by ignoring full snapshots, we have the risk that we generate a false positive\n    // (if a mutation _did_ happen but was \"swallowed\" by the full snapshot)\n    // But this should be more unlikely as we'd generally capture the incremental snapshot right away\n\n    if (!isIncrementalEvent(event)) {\n      return;\n    }\n\n    const { source } = event.data;\n    if (IncrementalMutationSources.has(source)) {\n      clickDetector.registerMutation(event.timestamp);\n    }\n\n    if (source === IncrementalSource.Scroll) {\n      clickDetector.registerScroll(event.timestamp);\n    }\n\n    if (isIncrementalMouseInteraction(event)) {\n      const { type, id } = event.data;\n      const node = record.mirror.getNode(id);\n\n      if (node instanceof HTMLElement && type === MouseInteractions.Click) {\n        clickDetector.registerClick(node);\n      }\n    }\n  } catch {\n    // ignore errors here, e.g. if accessing something that does not exist\n  }\n}\n\nfunction isIncrementalEvent(event: RecordingEvent): event is IncrementalRecordingEvent {\n  return event.type === ReplayEventTypeIncrementalSnapshot;\n}\n\nfunction isIncrementalMouseInteraction(\n  event: IncrementalRecordingEvent,\n): event is IncrementalMouseInteractionRecordingEvent {\n  return event.data.source === IncrementalSource.MouseInteraction;\n}\n","import type { ReplayBreadcrumbFrame } from '../types/replayFrame';\n\n/**\n * Create a breadcrumb for a replay.\n */\nexport function createBreadcrumb(\n  breadcrumb: Omit<ReplayBreadcrumbFrame, 'timestamp' | 'type'> & Partial<Pick<ReplayBreadcrumbFrame, 'timestamp'>>,\n): ReplayBreadcrumbFrame {\n  return {\n    timestamp: Date.now() / 1000,\n    type: 'default',\n    ...breadcrumb,\n  };\n}\n","var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar NodeType = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType || {});\nfunction isElement(n) {\n  return n.nodeType === n.ELEMENT_NODE;\n}\nfunction isShadowRoot(n) {\n  const host = n?.host;\n  return Boolean(host?.shadowRoot === n);\n}\nfunction isNativeShadowDom(shadowRoot) {\n  return Object.prototype.toString.call(shadowRoot) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n  if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n    cssText = cssText.replace(\n      /\\sbackground-clip:\\s*text;/g,\n      \" -webkit-background-clip: text; background-clip: text;\"\n    );\n  }\n  return cssText;\n}\nfunction escapeImportStatement(rule) {\n  const { cssText } = rule;\n  if (cssText.split('\"').length < 3) return cssText;\n  const statement = [\"@import\", `url(${JSON.stringify(rule.href)})`];\n  if (rule.layerName === \"\") {\n    statement.push(`layer`);\n  } else if (rule.layerName) {\n    statement.push(`layer(${rule.layerName})`);\n  }\n  if (rule.supportsText) {\n    statement.push(`supports(${rule.supportsText})`);\n  }\n  if (rule.media.length) {\n    statement.push(rule.media.mediaText);\n  }\n  return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s) {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules ? fixBrowserCompatibilityIssuesInCSS(\n      Array.from(rules, stringifyRule).join(\"\")\n    ) : null;\n  } catch (error) {\n    return null;\n  }\n}\nfunction fixAllCssProperty(rule) {\n  let styles = \"\";\n  for (let i = 0; i < rule.style.length; i++) {\n    const styleDeclaration = rule.style;\n    const attribute = styleDeclaration[i];\n    const isImportant = styleDeclaration.getPropertyPriority(attribute);\n    styles += `${attribute}:${styleDeclaration.getPropertyValue(attribute)}${isImportant ? ` !important` : \"\"};`;\n  }\n  return `${rule.selectorText} { ${styles} }`;\n}\nfunction stringifyRule(rule) {\n  let importStringified;\n  if (isCSSImportRule(rule)) {\n    try {\n      importStringified = // for same-origin stylesheets,\n      // we can access the imported stylesheet rules directly\n      stringifyStylesheet(rule.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement\n      escapeImportStatement(rule);\n    } catch (error) {\n    }\n  } else if (isCSSStyleRule(rule)) {\n    let cssText = rule.cssText;\n    const needsSafariColonFix = rule.selectorText.includes(\":\");\n    const needsAllFix = typeof rule.style[\"all\"] === \"string\" && rule.style[\"all\"];\n    if (needsAllFix) {\n      cssText = fixAllCssProperty(rule);\n    }\n    if (needsSafariColonFix) {\n      cssText = fixSafariColons(cssText);\n    }\n    if (needsSafariColonFix || needsAllFix) {\n      return cssText;\n    }\n  }\n  return importStringified || rule.cssText;\n}\nfunction fixSafariColons(cssStringified) {\n  const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n  return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule) {\n  return \"styleSheet\" in rule;\n}\nfunction isCSSStyleRule(rule) {\n  return \"selectorText\" in rule;\n}\nclass Mirror {\n  constructor() {\n    __publicField(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n) {\n    if (!n) return -1;\n    const id = this.getMeta(n)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n) {\n    return this.nodeMetaMap.get(n) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n) {\n    const id = this.getId(n);\n    this.idNodeMap.delete(id);\n    if (n.childNodes) {\n      n.childNodes.forEach(\n        (childNode) => this.removeNodeFromMap(childNode)\n      );\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n);\n    this.nodeMetaMap.set(n, meta);\n  }\n  replace(id, n) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n, meta);\n    }\n    this.idNodeMap.set(id, n);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n}\nfunction createMirror() {\n  return new Mirror();\n}\nfunction shouldMaskInput({\n  maskInputOptions,\n  tagName,\n  type\n}) {\n  if (tagName === \"OPTION\") {\n    tagName = \"SELECT\";\n  }\n  return Boolean(\n    maskInputOptions[tagName.toLowerCase()] || type && maskInputOptions[type] || type === \"password\" || // Default to \"text\" option for inputs without a \"type\" attribute defined\n    tagName === \"INPUT\" && !type && maskInputOptions[\"text\"]\n  );\n}\nfunction maskInputValue({\n  isMasked,\n  element,\n  value,\n  maskInputFn\n}) {\n  let text = value || \"\";\n  if (!isMasked) {\n    return text;\n  }\n  if (maskInputFn) {\n    text = maskInputFn(text, element);\n  }\n  return \"*\".repeat(text.length);\n}\nfunction toLowerCase(str) {\n  return str.toLowerCase();\n}\nfunction toUpperCase(str) {\n  return str.toUpperCase();\n}\nconst ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return true;\n  const chunkSize = 50;\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData;\n      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n      const pixelBuffer = new Uint32Array(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y)\n        ).data.buffer\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\nfunction isNodeMetaEqual(a, b) {\n  if (!a || !b || a.type !== b.type) return false;\n  if (a.type === NodeType.Document)\n    return a.compatMode === b.compatMode;\n  else if (a.type === NodeType.DocumentType)\n    return a.name === b.name && a.publicId === b.publicId && a.systemId === b.systemId;\n  else if (a.type === NodeType.Comment || a.type === NodeType.Text || a.type === NodeType.CDATA)\n    return a.textContent === b.textContent;\n  else if (a.type === NodeType.Element)\n    return a.tagName === b.tagName && JSON.stringify(a.attributes) === JSON.stringify(b.attributes) && a.isSVG === b.isSVG && a.needBlock === b.needBlock;\n  return false;\n}\nfunction getInputType(element) {\n  const type = element.type;\n  return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    toLowerCase(type)\n  ) : null;\n}\nfunction getInputValue(el, tagName, type) {\n  if (tagName === \"INPUT\" && (type === \"radio\" || type === \"checkbox\")) {\n    return el.getAttribute(\"value\") || \"\";\n  }\n  return el.value;\n}\nfunction extractFileExtension(path, baseURL) {\n  let url;\n  try {\n    url = new URL(path, baseURL ?? window.location.href);\n  } catch (err) {\n    return null;\n  }\n  const regex = /\\.([0-9a-z]+)(?:$)/i;\n  const match = url.pathname.match(regex);\n  return match?.[1] ?? null;\n}\nconst cachedImplementations = {};\nfunction getImplementation(name) {\n  const cached = cachedImplementations[name];\n  if (cached) {\n    return cached;\n  }\n  const document = window.document;\n  let impl = window[name];\n  if (document && typeof document.createElement === \"function\") {\n    try {\n      const sandbox = document.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n    }\n  }\n  return cachedImplementations[name] = impl.bind(\n    window\n  );\n}\nfunction onRequestAnimationFrame(...rest) {\n  return getImplementation(\"requestAnimationFrame\")(...rest);\n}\nfunction setTimeout(...rest) {\n  return getImplementation(\"setTimeout\")(...rest);\n}\nfunction clearTimeout(...rest) {\n  return getImplementation(\"clearTimeout\")(...rest);\n}\nfunction getIframeContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e) {\n  }\n}\nlet _id = 1;\nconst tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nconst IGNORED_NODE = -2;\nfunction genId() {\n  return _id++;\n}\nfunction getValidTagName(element) {\n  if (element instanceof HTMLFormElement) {\n    return \"form\";\n  }\n  const processedTagName = toLowerCase(element.tagName);\n  if (tagNameRegex.test(processedTagName)) {\n    return \"div\";\n  }\n  return processedTagName;\n}\nfunction extractOrigin(url) {\n  let origin = \"\";\n  if (url.indexOf(\"//\") > -1) {\n    origin = url.split(\"/\").slice(0, 3).join(\"/\");\n  } else {\n    origin = url.split(\"/\")[0];\n  }\n  origin = origin.split(\"?\")[0];\n  return origin;\n}\nlet canvasService;\nlet canvasCtx;\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n  return (cssText || \"\").replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || \"\";\n      if (!filePath) {\n        return origin;\n      }\n      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === \"/\") {\n        return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\n      }\n      const stack = href.split(\"/\");\n      const parts = filePath.split(\"/\");\n      stack.pop();\n      for (const part of parts) {\n        if (part === \".\") {\n          continue;\n        } else if (part === \"..\") {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join(\"/\")}${maybeQuote})`;\n    }\n  );\n}\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n  if (attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  let pos = 0;\n  function collectCharacters(regEx) {\n    let chars;\n    const match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return \"\";\n  }\n  const output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === \",\") {\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      output.push(url);\n    } else {\n      let descriptorsStr = \"\";\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        const c = attributeValue.charAt(pos);\n        if (c === \"\") {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === \",\") {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break;\n          } else if (c === \"(\") {\n            inParens = true;\n          }\n        } else {\n          if (c === \")\") {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(\", \");\n}\nconst cachedDocument = /* @__PURE__ */ new WeakMap();\nfunction absoluteToDoc(doc, attributeValue) {\n  if (!attributeValue || attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  return getHref(doc, attributeValue);\n}\nfunction isSVGElement(el) {\n  return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref(doc, customHref) {\n  let a = cachedDocument.get(doc);\n  if (!a) {\n    a = doc.createElement(\"a\");\n    cachedDocument.set(doc, a);\n  }\n  if (!customHref) {\n    customHref = \"\";\n  } else if (customHref.startsWith(\"blob:\") || customHref.startsWith(\"data:\")) {\n    return customHref;\n  }\n  a.setAttribute(\"href\", customHref);\n  return a.href;\n}\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn) {\n  if (!value) {\n    return value;\n  }\n  if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"srcset\") {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === \"style\") {\n    return absoluteToStylesheet(value, getHref(doc));\n  } else if (tagName === \"object\" && name === \"data\") {\n    return absoluteToDoc(doc, value);\n  }\n  if (typeof maskAttributeFn === \"function\") {\n    return maskAttributeFn(name, value, element);\n  }\n  return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n  return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\n  try {\n    if (unblockSelector && element.matches(unblockSelector)) {\n      return false;\n    }\n    if (typeof blockClass === \"string\") {\n      if (element.classList.contains(blockClass)) {\n        return true;\n      }\n    } else {\n      for (let eIndex = element.classList.length; eIndex--; ) {\n        const className = element.classList[eIndex];\n        if (blockClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (blockSelector) {\n      return element.matches(blockSelector);\n    }\n  } catch (e) {\n  }\n  return false;\n}\nfunction elementClassMatchesRegex(el, regex) {\n  for (let eIndex = el.classList.length; eIndex--; ) {\n    const className = el.classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction classMatchesRegex(node, regex, checkAncestors) {\n  if (!node) return false;\n  if (checkAncestors) {\n    return distanceToMatch(\n      node,\n      (node2) => elementClassMatchesRegex(node2, regex)\n    ) >= 0;\n  } else if (node.nodeType === node.ELEMENT_NODE) {\n    return elementClassMatchesRegex(node, regex);\n  }\n  return false;\n}\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\n  if (!node) return -1;\n  if (node.nodeType !== node.ELEMENT_NODE) return -1;\n  if (distance > limit) return -1;\n  if (matchPredicate(node)) return distance;\n  return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\n}\nfunction createMatchPredicate(className, selector) {\n  return (node) => {\n    const el = node;\n    if (el === null) return false;\n    try {\n      if (className) {\n        if (typeof className === \"string\") {\n          if (el.matches(`.${className}`)) return true;\n        } else if (elementClassMatchesRegex(el, className)) {\n          return true;\n        }\n      }\n      if (selector && el.matches(selector)) return true;\n      return false;\n    } catch {\n      return false;\n    }\n  };\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    if (el === null) return false;\n    if (el.tagName === \"INPUT\") {\n      const autocomplete = el.getAttribute(\"autocomplete\");\n      const disallowedAutocompleteValues = [\n        \"current-password\",\n        \"new-password\",\n        \"cc-number\",\n        \"cc-exp\",\n        \"cc-exp-month\",\n        \"cc-exp-year\",\n        \"cc-csc\"\n      ];\n      if (disallowedAutocompleteValues.includes(autocomplete)) {\n        return true;\n      }\n    }\n    let maskDistance = -1;\n    let unmaskDistance = -1;\n    if (maskAllText) {\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector)\n      );\n      if (unmaskDistance < 0) {\n        return true;\n      }\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector),\n        unmaskDistance >= 0 ? unmaskDistance : Infinity\n      );\n    } else {\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector)\n      );\n      if (maskDistance < 0) {\n        return false;\n      }\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector),\n        maskDistance >= 0 ? maskDistance : Infinity\n      );\n    }\n    return maskDistance >= 0 ? unmaskDistance >= 0 ? maskDistance <= unmaskDistance : true : unmaskDistance >= 0 ? false : !!maskAllText;\n  } catch (e) {\n  }\n  return !!maskAllText;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  let fired = false;\n  let readyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== \"complete\") {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener(\"load\", () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  const blankUrl = \"about:blank\";\n  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n    setTimeout(listener, 0);\n    return iframeEl.addEventListener(\"load\", listener);\n  }\n  iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n  let fired = false;\n  let styleSheetLoaded;\n  try {\n    styleSheetLoaded = link.sheet;\n  } catch (error) {\n    return;\n  }\n  if (styleSheetLoaded) return;\n  const timer = setTimeout(() => {\n    if (!fired) {\n      listener();\n      fired = true;\n    }\n  }, styleSheetLoadTimeout);\n  link.addEventListener(\"load\", () => {\n    clearTimeout(timer);\n    fired = true;\n    listener();\n  });\n}\nfunction serializeNode(n, options) {\n  const {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskAttributeFn,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false\n  } = options;\n  const rootId = getRootId(doc, mirror);\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      if (n.compatMode !== \"CSS1Compat\") {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          compatMode: n.compatMode\n          // probably \"BackCompat\"\n        };\n      } else {\n        return {\n          type: NodeType.Document,\n          childNodes: []\n        };\n      }\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: n.name,\n        publicId: n.publicId,\n        systemId: n.systemId,\n        rootId\n      };\n    case n.ELEMENT_NODE:\n      return serializeElementNode(n, {\n        doc,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        inlineStylesheet,\n        maskAttributeFn,\n        maskInputOptions,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement,\n        rootId,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector\n      });\n    case n.TEXT_NODE:\n      return serializeTextNode(n, {\n        doc,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        maskTextFn,\n        maskInputOptions,\n        maskInputFn,\n        rootId\n      });\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: \"\",\n        rootId\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: n.textContent || \"\",\n        rootId\n      };\n    default:\n      return false;\n  }\n}\nfunction getRootId(doc, mirror) {\n  if (!mirror.hasNode(doc)) return void 0;\n  const docId = mirror.getId(doc);\n  return docId === 1 ? void 0 : docId;\n}\nfunction serializeTextNode(n, options) {\n  const {\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    maskTextFn,\n    maskInputOptions,\n    maskInputFn,\n    rootId\n  } = options;\n  const parentTagName = n.parentNode && n.parentNode.tagName;\n  let textContent = n.textContent;\n  const isStyle = parentTagName === \"STYLE\" ? true : void 0;\n  const isScript = parentTagName === \"SCRIPT\" ? true : void 0;\n  const isTextarea = parentTagName === \"TEXTAREA\" ? true : void 0;\n  if (isStyle && textContent) {\n    try {\n      if (n.nextSibling || n.previousSibling) {\n      } else if (n.parentNode.sheet?.cssRules) {\n        textContent = stringifyStylesheet(\n          n.parentNode.sheet\n        );\n      }\n    } catch (err) {\n      console.warn(\n        `Cannot get CSS styles from text's parentNode. Error: ${err}`,\n        n\n      );\n    }\n    textContent = absoluteToStylesheet(textContent, getHref(options.doc));\n  }\n  if (isScript) {\n    textContent = \"SCRIPT_PLACEHOLDER\";\n  }\n  const forceMask = needMaskingText(\n    n,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextClass,\n    unmaskTextSelector,\n    maskAllText\n  );\n  if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\n    textContent = maskTextFn ? maskTextFn(textContent, n.parentElement) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\n    textContent = maskInputFn ? maskInputFn(textContent, n.parentNode) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (parentTagName === \"OPTION\" && textContent) {\n    const isInputMasked = shouldMaskInput({\n      type: null,\n      tagName: parentTagName,\n      maskInputOptions\n    });\n    textContent = maskInputValue({\n      isMasked: needMaskingText(\n        n,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        isInputMasked\n      ),\n      element: n,\n      value: textContent,\n      maskInputFn\n    });\n  }\n  return {\n    type: NodeType.Text,\n    textContent: textContent || \"\",\n    isStyle,\n    rootId\n  };\n}\nfunction serializeElementNode(n, options) {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    rootId,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector\n  } = options;\n  const needBlock = _isBlockedElement(\n    n,\n    blockClass,\n    blockSelector,\n    unblockSelector\n  );\n  const tagName = getValidTagName(n);\n  let attributes2 = {};\n  const len = n.attributes.length;\n  for (let i = 0; i < len; i++) {\n    const attr = n.attributes[i];\n    if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\n      attributes2[attr.name] = transformAttribute(\n        doc,\n        tagName,\n        toLowerCase(attr.name),\n        attr.value,\n        n,\n        maskAttributeFn\n      );\n    }\n  }\n  if (tagName === \"link\" && inlineStylesheet) {\n    const stylesheet = Array.from(doc.styleSheets).find((s) => {\n      return s.href === n.href;\n    });\n    let cssText = null;\n    if (stylesheet) {\n      cssText = stringifyStylesheet(stylesheet);\n    }\n    if (cssText) {\n      attributes2.rel = null;\n      attributes2.href = null;\n      attributes2.crossorigin = null;\n      attributes2._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n    }\n  }\n  if (tagName === \"style\" && n.sheet && // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n  !(n.innerText || n.textContent || \"\").trim().length) {\n    const cssText = stringifyStylesheet(\n      n.sheet\n    );\n    if (cssText) {\n      attributes2._cssText = absoluteToStylesheet(cssText, getHref(doc));\n    }\n  }\n  if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\" || tagName === \"option\") {\n    const el = n;\n    const type = getInputType(el);\n    const value = getInputValue(el, toUpperCase(tagName), type);\n    const checked = el.checked;\n    if (type !== \"submit\" && type !== \"button\" && value) {\n      const forceMask = needMaskingText(\n        el,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        shouldMaskInput({\n          type,\n          tagName: toUpperCase(tagName),\n          maskInputOptions\n        })\n      );\n      attributes2.value = maskInputValue({\n        isMasked: forceMask,\n        element: el,\n        value,\n        maskInputFn\n      });\n    }\n    if (checked) {\n      attributes2.checked = checked;\n    }\n  }\n  if (tagName === \"option\") {\n    if (n.selected && !maskInputOptions[\"select\"]) {\n      attributes2.selected = true;\n    } else {\n      delete attributes2.selected;\n    }\n  }\n  if (tagName === \"canvas\" && recordCanvas) {\n    if (n.__context === \"2d\") {\n      if (!is2DCanvasBlank(n)) {\n        attributes2.rr_dataURL = n.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      }\n    } else if (!(\"__context\" in n)) {\n      const canvasDataURL = n.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      const blankCanvas = doc.createElement(\"canvas\");\n      blankCanvas.width = n.width;\n      blankCanvas.height = n.height;\n      const blankCanvasDataURL = blankCanvas.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      if (canvasDataURL !== blankCanvasDataURL) {\n        attributes2.rr_dataURL = canvasDataURL;\n      }\n    }\n  }\n  if (tagName === \"img\" && inlineImages) {\n    if (!canvasService) {\n      canvasService = doc.createElement(\"canvas\");\n      canvasCtx = canvasService.getContext(\"2d\");\n    }\n    const image = n;\n    const imageSrc = image.currentSrc || image.getAttribute(\"src\") || \"<unknown-src>\";\n    const priorCrossOrigin = image.crossOrigin;\n    const recordInlineImage = () => {\n      image.removeEventListener(\"load\", recordInlineImage);\n      try {\n        canvasService.width = image.naturalWidth;\n        canvasService.height = image.naturalHeight;\n        canvasCtx.drawImage(image, 0, 0);\n        attributes2.rr_dataURL = canvasService.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      } catch (err) {\n        if (image.crossOrigin !== \"anonymous\") {\n          image.crossOrigin = \"anonymous\";\n          if (image.complete && image.naturalWidth !== 0)\n            recordInlineImage();\n          else image.addEventListener(\"load\", recordInlineImage);\n          return;\n        } else {\n          console.warn(\n            `Cannot inline img src=${imageSrc}! Error: ${err}`\n          );\n        }\n      }\n      if (image.crossOrigin === \"anonymous\") {\n        priorCrossOrigin ? attributes2.crossOrigin = priorCrossOrigin : image.removeAttribute(\"crossorigin\");\n      }\n    };\n    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n    else image.addEventListener(\"load\", recordInlineImage);\n  }\n  if (tagName === \"audio\" || tagName === \"video\") {\n    attributes2.rr_mediaState = n.paused ? \"paused\" : \"played\";\n    attributes2.rr_mediaCurrentTime = n.currentTime;\n  }\n  if (!newlyAddedElement) {\n    if (n.scrollLeft) {\n      attributes2.rr_scrollLeft = n.scrollLeft;\n    }\n    if (n.scrollTop) {\n      attributes2.rr_scrollTop = n.scrollTop;\n    }\n  }\n  if (needBlock) {\n    const { width, height } = n.getBoundingClientRect();\n    attributes2 = {\n      class: attributes2.class,\n      rr_width: `${width}px`,\n      rr_height: `${height}px`\n    };\n  }\n  if (tagName === \"iframe\" && !keepIframeSrcFn(attributes2.src)) {\n    if (!needBlock && !getIframeContentDocument(n)) {\n      attributes2.rr_src = attributes2.src;\n    }\n    delete attributes2.src;\n  }\n  let isCustomElement;\n  try {\n    if (customElements.get(tagName)) isCustomElement = true;\n  } catch (e) {\n  }\n  return {\n    type: NodeType.Element,\n    tagName,\n    attributes: attributes2,\n    childNodes: [],\n    isSVG: isSVGElement(n) || void 0,\n    needBlock,\n    rootId,\n    isCustom: isCustomElement\n  };\n}\nfunction lowerIfExists(maybeAttr) {\n  if (maybeAttr === void 0 || maybeAttr === null) {\n    return \"\";\n  } else {\n    return maybeAttr.toLowerCase();\n  }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (slimDOMOptions.script && // script tag\n    (sn.tagName === \"script\" || // (module)preload link\n    sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" || sn.attributes.rel === \"modulepreload\") || // prefetch link\n    sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n      return true;\n    } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(\n      /^msapplication-tile(image|color)$/\n    ) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n      return true;\n    } else if (sn.tagName === \"meta\") {\n      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n        return true;\n      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n      lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== void 0) {\n        return true;\n      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n        return true;\n      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction serializeNodeWithId(n, options) {\n  const {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5e3,\n    onStylesheetLoad,\n    stylesheetLoadTimeout = 5e3,\n    keepIframeSrcFn = () => false,\n    newlyAddedElement = false\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n, {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    maskAllText,\n    unblockSelector,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement\n  });\n  if (!_serializedNode) {\n    console.warn(n, \"not serialized\");\n    return null;\n  }\n  let id;\n  if (mirror.hasNode(n)) {\n    id = mirror.getId(n);\n  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode2 = Object.assign(_serializedNode, { id });\n  mirror.add(n, serializedNode2);\n  if (id === IGNORED_NODE) {\n    return null;\n  }\n  if (onSerialize) {\n    onSerialize(n);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode2.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode2.needBlock;\n    delete serializedNode2.needBlock;\n    const shadowRoot = n.shadowRoot;\n    if (shadowRoot && isNativeShadowDom(shadowRoot))\n      serializedNode2.isShadowHost = true;\n  }\n  if ((serializedNode2.type === NodeType.Document || serializedNode2.type === NodeType.Element) && recordChild) {\n    if (slimDOMOptions.headWhitespace && serializedNode2.type === NodeType.Element && serializedNode2.tagName === \"head\") {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      mirror,\n      blockClass,\n      blockSelector,\n      maskAllText,\n      unblockSelector,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      onStylesheetLoad,\n      stylesheetLoadTimeout,\n      keepIframeSrcFn\n    };\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode2.childNodes.push(serializedChildNode);\n      }\n    }\n    if (isElement(n) && n.shadowRoot) {\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          isNativeShadowDom(n.shadowRoot) && (serializedChildNode.isShadow = true);\n          serializedNode2.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n  if (n.parentNode && isShadowRoot(n.parentNode) && isNativeShadowDom(n.parentNode)) {\n    serializedNode2.isShadow = true;\n  }\n  if (serializedNode2.type === NodeType.Element && serializedNode2.tagName === \"iframe\" && !_isBlockedElement(\n    n,\n    blockClass,\n    blockSelector,\n    unblockSelector\n  )) {\n    onceIframeLoaded(\n      n,\n      () => {\n        const iframeDoc = getIframeContentDocument(n);\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            mirror,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n          });\n          if (serializedIframeNode) {\n            onIframeLoad(\n              n,\n              serializedIframeNode\n            );\n          }\n        }\n      },\n      iframeLoadTimeout\n    );\n  }\n  if (serializedNode2.type === NodeType.Element && serializedNode2.tagName === \"link\" && typeof serializedNode2.attributes.rel === \"string\" && (serializedNode2.attributes.rel === \"stylesheet\" || serializedNode2.attributes.rel === \"preload\" && typeof serializedNode2.attributes.href === \"string\" && extractFileExtension(serializedNode2.attributes.href) === \"css\")) {\n    onceStylesheetLoaded(\n      n,\n      () => {\n        if (onStylesheetLoad) {\n          const serializedLinkNode = serializeNodeWithId(n, {\n            doc,\n            mirror,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n          });\n          if (serializedLinkNode) {\n            onStylesheetLoad(\n              n,\n              serializedLinkNode\n            );\n          }\n        }\n      },\n      stylesheetLoadTimeout\n    );\n  }\n  return serializedNode2;\n}\nfunction snapshot(n, options) {\n  const {\n    mirror = new Mirror(),\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn = () => false\n  } = options || {};\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true\n  } : maskAllInputs === false ? {} : maskAllInputs;\n  const slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? (\n    // if true: set of sensible options that should not throw away any information\n    {\n      script: true,\n      comment: true,\n      headFavicon: true,\n      headWhitespace: true,\n      headMetaDescKeywords: slimDOM === \"all\",\n      // destructive\n      headMetaSocial: true,\n      headMetaRobots: true,\n      headMetaHttpEquiv: true,\n      headMetaAuthorship: true,\n      headMetaVerification: true\n    }\n  ) : slimDOM === false ? {} : slimDOM;\n  return serializeNodeWithId(n, {\n    doc: n,\n    mirror,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild: false,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn,\n    newlyAddedElement: false\n  });\n}\nfunction visitSnapshot(node, onVisit) {\n  function walk(current) {\n    onVisit(current);\n    if (current.type === NodeType.Document || current.type === NodeType.Element) {\n      current.childNodes.forEach(walk);\n    }\n  }\n  walk(node);\n}\nfunction cleanupSnapshot() {\n  _id = 1;\n}\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\nfunction parse(css, options = {}) {\n  let lineno = 1;\n  let column = 1;\n  function updatePosition(str) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    const i = str.lastIndexOf(\"\\n\");\n    column = i === -1 ? column + str.length : str.length - i;\n  }\n  function position() {\n    const start = { line: lineno, column };\n    return (node) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n  const _Position = class _Position {\n    constructor(start) {\n      __publicField(this, \"content\");\n      __publicField(this, \"start\");\n      __publicField(this, \"end\");\n      __publicField(this, \"source\");\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n      this.content = _Position.content;\n    }\n  };\n  __publicField(_Position, \"content\");\n  let Position = _Position;\n  Position.content = css;\n  const errorsList = [];\n  function error(msg) {\n    const err = new Error(\n      `${options.source || \"\"}:${lineno}:${column}: ${msg}`\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n  function stylesheet() {\n    const rulesList = rules();\n    return {\n      type: \"stylesheet\",\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList\n      }\n    };\n  }\n  function open() {\n    return match(/^{\\s*/);\n  }\n  function close() {\n    return match(/^}/);\n  }\n  function rules() {\n    let node;\n    const rules2 = [];\n    whitespace();\n    comments(rules2);\n    while (css.length && css.charAt(0) !== \"}\" && (node = atrule() || rule())) {\n      if (node) {\n        rules2.push(node);\n        comments(rules2);\n      }\n    }\n    return rules2;\n  }\n  function match(re) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n  function whitespace() {\n    match(/^\\s*/);\n  }\n  function comments(rules2 = []) {\n    let c;\n    while (c = comment()) {\n      if (c) {\n        rules2.push(c);\n      }\n      c = comment();\n    }\n    return rules2;\n  }\n  function comment() {\n    const pos = position();\n    if (\"/\" !== css.charAt(0) || \"*\" !== css.charAt(1)) {\n      return;\n    }\n    let i = 2;\n    while (\"\" !== css.charAt(i) && (\"*\" !== css.charAt(i) || \"/\" !== css.charAt(i + 1))) {\n      ++i;\n    }\n    i += 2;\n    if (\"\" === css.charAt(i - 1)) {\n      return error(\"End of comment missing\");\n    }\n    const str = css.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i);\n    column += 2;\n    return pos({\n      type: \"comment\",\n      comment: str\n    });\n  }\n  function selector() {\n    const m = match(/^([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const splitSelectors = trim(m[0]).replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, \"\").replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m2) => {\n      return m2.replace(/,/g, \"‌\");\n    }).split(/\\s*(?![^(]*\\)),\\s*/);\n    if (splitSelectors.length <= 1) {\n      return splitSelectors.map((s) => {\n        return s.replace(/\\u200C/g, \",\");\n      });\n    }\n    let i = 0;\n    let j = 0;\n    const len = splitSelectors.length;\n    const finalSelectors = [];\n    while (i < len) {\n      const openingParensCount = (splitSelectors[i].match(/\\(/g) || []).length;\n      const closingParensCount = (splitSelectors[i].match(/\\)/g) || []).length;\n      let unbalancedParens = openingParensCount - closingParensCount;\n      if (unbalancedParens >= 1) {\n        let foundClosingSelector = false;\n        j = i + 1;\n        while (j < len) {\n          const nextOpeningParensCount = (splitSelectors[j].match(/\\(/g) || []).length;\n          const nextClosingParensCount = (splitSelectors[j].match(/\\)/g) || []).length;\n          const nextUnbalancedParens = nextClosingParensCount - nextOpeningParensCount;\n          if (nextUnbalancedParens === unbalancedParens) {\n            finalSelectors.push(splitSelectors.slice(i, j + 1).join(\",\"));\n            i = j + 1;\n            foundClosingSelector = true;\n            break;\n          }\n          j++;\n          unbalancedParens -= nextUnbalancedParens;\n        }\n        if (foundClosingSelector) {\n          continue;\n        }\n        splitSelectors.slice(i, len).forEach((selector2) => selector2 && finalSelectors.push(selector2));\n        break;\n      }\n      splitSelectors[i] && finalSelectors.push(splitSelectors[i]);\n      i++;\n    }\n    return finalSelectors.map((s) => {\n      return s.replace(/\\u200C/g, \",\");\n    });\n  }\n  function declaration() {\n    const pos = position();\n    const propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n    const ret = pos({\n      type: \"declaration\",\n      property: prop.replace(commentre, \"\"),\n      value: val ? trim(val[0]).replace(commentre, \"\") : \"\"\n    });\n    match(/^[;\\s]*/);\n    return ret;\n  }\n  function declarations() {\n    const decls = [];\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n    let decl;\n    while (decl = declaration()) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n    while (m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/)) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n    if (!vals.length) {\n      return;\n    }\n    return pos({\n      type: \"keyframe\",\n      values: vals,\n      declarations: declarations()\n    });\n  }\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error(\"@keyframes missing name\");\n    }\n    const name = m[1];\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n    let frame;\n    let frames = comments();\n    while (frame = keyframe()) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n    return pos({\n      type: \"keyframes\",\n      name,\n      vendor,\n      keyframes: frames\n    });\n  }\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n    const style = comments().concat(rules());\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n    return pos({\n      type: \"supports\",\n      supports,\n      rules: style\n    });\n  }\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n    if (!m) {\n      return;\n    }\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n    const style = comments().concat(rules());\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n    return pos({\n      type: \"host\",\n      rules: style\n    });\n  }\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n    const style = comments().concat(rules());\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n    return pos({\n      type: \"media\",\n      media,\n      rules: style\n    });\n  }\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n    return pos({\n      type: \"custom-media\",\n      name: trim(m[1]),\n      media: trim(m[2])\n    });\n  }\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n    const sel = selector() || [];\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n    let decl;\n    while (decl = declaration()) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n    return pos({\n      type: \"page\",\n      selectors: sel,\n      declarations: decls\n    });\n  }\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n    const style = comments().concat(rules());\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n    return pos({\n      type: \"document\",\n      document: doc,\n      vendor,\n      rules: style\n    });\n  }\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n    let decl;\n    while (decl = declaration()) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n    return pos({\n      type: \"font-face\",\n      declarations: decls\n    });\n  }\n  const atimport = _compileAtrule(\"import\");\n  const atcharset = _compileAtrule(\"charset\");\n  const atnamespace = _compileAtrule(\"namespace\");\n  function _compileAtrule(name) {\n    const re = new RegExp(\n      \"^@\" + name + \"\\\\s*((?:\" + [\n        /[^\\\\]\"(?:\\\\\"|[^\"])*\"/.source,\n        // consume any quoted parts (checking that the double quote isn't itself escaped)\n        /[^\\\\]'(?:\\\\'|[^'])*'/.source,\n        // same but for single quotes\n        \"[^;]\"\n      ].join(\"|\") + \")+);\"\n    );\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n  function atrule() {\n    if (css[0] !== \"@\") {\n      return;\n    }\n    return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();\n  }\n  function rule() {\n    const pos = position();\n    const sel = selector();\n    if (!sel) {\n      return error(\"selector missing\");\n    }\n    comments();\n    return pos({\n      type: \"rule\",\n      selectors: sel,\n      declarations: declarations()\n    });\n  }\n  return addParent(stylesheet());\n}\nfunction trim(str) {\n  return str ? str.replace(/^\\s+|\\s+$/g, \"\") : \"\";\n}\nfunction addParent(obj, parent) {\n  const isNode = obj && typeof obj.type === \"string\";\n  const childParent = isNode ? obj : parent;\n  for (const k of Object.keys(obj)) {\n    const value = obj[k];\n    if (Array.isArray(value)) {\n      value.forEach((v) => {\n        addParent(v, childParent);\n      });\n    } else if (value && typeof value === \"object\") {\n      addParent(value, childParent);\n    }\n  }\n  if (isNode) {\n    Object.defineProperty(obj, \"parent\", {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null\n    });\n  }\n  return obj;\n}\nconst tagMap = {\n  script: \"noscript\",\n  // camel case svg element tag names\n  altglyph: \"altGlyph\",\n  altglyphdef: \"altGlyphDef\",\n  altglyphitem: \"altGlyphItem\",\n  animatecolor: \"animateColor\",\n  animatemotion: \"animateMotion\",\n  animatetransform: \"animateTransform\",\n  clippath: \"clipPath\",\n  feblend: \"feBlend\",\n  fecolormatrix: \"feColorMatrix\",\n  fecomponenttransfer: \"feComponentTransfer\",\n  fecomposite: \"feComposite\",\n  feconvolvematrix: \"feConvolveMatrix\",\n  fediffuselighting: \"feDiffuseLighting\",\n  fedisplacementmap: \"feDisplacementMap\",\n  fedistantlight: \"feDistantLight\",\n  fedropshadow: \"feDropShadow\",\n  feflood: \"feFlood\",\n  fefunca: \"feFuncA\",\n  fefuncb: \"feFuncB\",\n  fefuncg: \"feFuncG\",\n  fefuncr: \"feFuncR\",\n  fegaussianblur: \"feGaussianBlur\",\n  feimage: \"feImage\",\n  femerge: \"feMerge\",\n  femergenode: \"feMergeNode\",\n  femorphology: \"feMorphology\",\n  feoffset: \"feOffset\",\n  fepointlight: \"fePointLight\",\n  fespecularlighting: \"feSpecularLighting\",\n  fespotlight: \"feSpotLight\",\n  fetile: \"feTile\",\n  feturbulence: \"feTurbulence\",\n  foreignobject: \"foreignObject\",\n  glyphref: \"glyphRef\",\n  lineargradient: \"linearGradient\",\n  radialgradient: \"radialGradient\"\n};\nfunction getTagName(n) {\n  let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n  if (tagName === \"link\" && n.attributes._cssText) {\n    tagName = \"style\";\n  }\n  return tagName;\n}\nfunction escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, \"g\");\nfunction addHoverClass(cssText, cache) {\n  const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\n  if (cachedStyle) return cachedStyle;\n  if (cssText.length >= 1e6) {\n    return cssText;\n  }\n  const ast = parse(cssText, {\n    silent: true\n  });\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n  const selectors = [];\n  ast.stylesheet.rules.forEach((rule) => {\n    if (\"selectors\" in rule) {\n      (rule.selectors || []).forEach((selector) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          selectors.push(selector);\n        }\n      });\n    }\n  });\n  if (selectors.length === 0) {\n    return cssText;\n  }\n  const selectorMatcher = new RegExp(\n    selectors.filter((selector, index) => selectors.indexOf(selector) === index).sort((a, b) => b.length - a.length).map((selector) => {\n      return escapeRegExp(selector);\n    }).join(\"|\"),\n    \"g\"\n  );\n  const result = cssText.replace(selectorMatcher, (selector) => {\n    const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, \"$1.\\\\:hover\");\n    return `${selector}, ${newSelector}`;\n  });\n  cache?.stylesWithHoverClass.set(cssText, result);\n  return result;\n}\nfunction createCache() {\n  const stylesWithHoverClass = /* @__PURE__ */ new Map();\n  return {\n    stylesWithHoverClass\n  };\n}\nfunction buildNode(n, options) {\n  const { doc, hackCss, cache } = options;\n  switch (n.type) {\n    case NodeType.Document:\n      return doc.implementation.createDocument(null, \"\", null);\n    case NodeType.DocumentType:\n      return doc.implementation.createDocumentType(\n        n.name || \"html\",\n        n.publicId,\n        n.systemId\n      );\n    case NodeType.Element: {\n      const tagName = getTagName(n);\n      let node;\n      if (n.isSVG) {\n        node = doc.createElementNS(\"http://www.w3.org/2000/svg\", tagName);\n      } else {\n        if (\n          // If the tag name is a custom element name\n          n.isCustom && // If the browser supports custom elements\n          doc.defaultView?.customElements && // If the custom element hasn't been defined yet\n          !doc.defaultView.customElements.get(n.tagName)\n        )\n          doc.defaultView.customElements.define(\n            n.tagName,\n            class extends doc.defaultView.HTMLElement {\n            }\n          );\n        node = doc.createElement(tagName);\n      }\n      const specialAttributes = {};\n      for (const name in n.attributes) {\n        if (!Object.prototype.hasOwnProperty.call(n.attributes, name)) {\n          continue;\n        }\n        let value = n.attributes[name];\n        if (tagName === \"option\" && name === \"selected\" && value === false) {\n          continue;\n        }\n        if (value === null) {\n          continue;\n        }\n        if (value === true) value = \"\";\n        if (name.startsWith(\"rr_\")) {\n          specialAttributes[name] = value;\n          continue;\n        }\n        const isTextarea = tagName === \"textarea\" && name === \"value\";\n        const isRemoteOrDynamicCss = tagName === \"style\" && name === \"_cssText\";\n        if (isRemoteOrDynamicCss && hackCss && typeof value === \"string\") {\n          value = addHoverClass(value, cache);\n        }\n        if ((isTextarea || isRemoteOrDynamicCss) && typeof value === \"string\") {\n          const child = doc.createTextNode(value);\n          for (const c of Array.from(node.childNodes)) {\n            if (c.nodeType === node.TEXT_NODE) {\n              node.removeChild(c);\n            }\n          }\n          node.appendChild(child);\n          continue;\n        }\n        try {\n          if (n.isSVG && name === \"xlink:href\") {\n            node.setAttributeNS(\n              \"http://www.w3.org/1999/xlink\",\n              name,\n              value.toString()\n            );\n          } else if (name === \"onload\" || name === \"onclick\" || name.substring(0, 7) === \"onmouse\") {\n            node.setAttribute(\"_\" + name, value.toString());\n          } else if (tagName === \"meta\" && n.attributes[\"http-equiv\"] === \"Content-Security-Policy\" && name === \"content\") {\n            node.setAttribute(\"csp-content\", value.toString());\n            continue;\n          } else if (tagName === \"link\" && (n.attributes.rel === \"preload\" || n.attributes.rel === \"modulepreload\")) {\n          } else if (tagName === \"link\" && n.attributes.rel === \"prefetch\" && typeof n.attributes.href === \"string\" && extractFileExtension(n.attributes.href) === \"js\") {\n          } else if (tagName === \"img\" && n.attributes.srcset && n.attributes.rr_dataURL) {\n            node.setAttribute(\n              \"rrweb-original-srcset\",\n              n.attributes.srcset\n            );\n          } else {\n            node.setAttribute(name, value.toString());\n          }\n        } catch (error) {\n        }\n      }\n      for (const name in specialAttributes) {\n        const value = specialAttributes[name];\n        if (tagName === \"canvas\" && name === \"rr_dataURL\") {\n          const image = doc.createElement(\"img\");\n          image.onload = () => {\n            const ctx = node.getContext(\"2d\");\n            if (ctx) {\n              ctx.drawImage(image, 0, 0, image.width, image.height);\n            }\n          };\n          image.src = value.toString();\n          if (node.RRNodeType)\n            node.rr_dataURL = value.toString();\n        } else if (tagName === \"img\" && name === \"rr_dataURL\") {\n          const image = node;\n          if (!image.currentSrc.startsWith(\"data:\")) {\n            image.setAttribute(\n              \"rrweb-original-src\",\n              n.attributes.src\n            );\n            image.src = value.toString();\n          }\n        }\n        if (name === \"rr_width\") {\n          node.style.setProperty(\"width\", value.toString());\n        } else if (name === \"rr_height\") {\n          node.style.setProperty(\"height\", value.toString());\n        } else if (name === \"rr_mediaCurrentTime\" && typeof value === \"number\") {\n          node.currentTime = value;\n        } else if (name === \"rr_mediaState\") {\n          switch (value) {\n            case \"played\":\n              node.play().catch((e) => console.warn(\"media playback error\", e));\n              break;\n            case \"paused\":\n              node.pause();\n              break;\n          }\n        }\n      }\n      if (n.isShadowHost) {\n        if (!node.shadowRoot) {\n          node.attachShadow({ mode: \"open\" });\n        } else {\n          while (node.shadowRoot.firstChild) {\n            node.shadowRoot.removeChild(node.shadowRoot.firstChild);\n          }\n        }\n      }\n      return node;\n    }\n    case NodeType.Text:\n      return doc.createTextNode(\n        n.isStyle && hackCss ? addHoverClass(n.textContent, cache) : n.textContent\n      );\n    case NodeType.CDATA:\n      if (!(doc instanceof XMLDocument)) {\n        return null;\n      }\n      return doc.createCDATASection(n.textContent);\n    case NodeType.Comment:\n      return doc.createComment(n.textContent);\n    default:\n      return null;\n  }\n}\nfunction buildNodeWithSN(n, options) {\n  const {\n    doc,\n    mirror,\n    skipChild = false,\n    hackCss = true,\n    afterAppend,\n    cache\n  } = options;\n  if (mirror.has(n.id)) {\n    const nodeInMirror = mirror.getNode(n.id);\n    const meta = mirror.getMeta(nodeInMirror);\n    if (isNodeMetaEqual(meta, n)) return mirror.getNode(n.id);\n  }\n  let node = buildNode(n, { doc, hackCss, cache });\n  if (!node) {\n    return null;\n  }\n  if (n.rootId && mirror.getNode(n.rootId) !== doc) {\n    mirror.replace(n.rootId, doc);\n  }\n  if (n.type === NodeType.Document) {\n    doc.close();\n    doc.open();\n    if (n.compatMode === \"BackCompat\" && n.childNodes && n.childNodes[0].type !== NodeType.DocumentType) {\n      if (n.childNodes[0].type === NodeType.Element && \"xmlns\" in n.childNodes[0].attributes && n.childNodes[0].attributes.xmlns === \"http://www.w3.org/1999/xhtml\") {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">'\n        );\n      } else {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">'\n        );\n      }\n    }\n    node = doc;\n  }\n  mirror.add(node, n);\n  if ((n.type === NodeType.Document || n.type === NodeType.Element) && !skipChild) {\n    for (const childN of n.childNodes) {\n      const childNode = buildNodeWithSN(childN, {\n        doc,\n        mirror,\n        skipChild: false,\n        hackCss,\n        afterAppend,\n        cache\n      });\n      if (!childNode) {\n        console.warn(\"Failed to rebuild\", childN);\n        continue;\n      }\n      if (childN.isShadow && isElement(node) && node.shadowRoot) {\n        node.shadowRoot.appendChild(childNode);\n      } else if (n.type === NodeType.Document && childN.type == NodeType.Element) {\n        const htmlElement = childNode;\n        let body = null;\n        htmlElement.childNodes.forEach((child) => {\n          if (child.nodeName === \"BODY\") body = child;\n        });\n        if (body) {\n          htmlElement.removeChild(body);\n          node.appendChild(childNode);\n          htmlElement.appendChild(body);\n        } else {\n          node.appendChild(childNode);\n        }\n      } else {\n        node.appendChild(childNode);\n      }\n      if (afterAppend) {\n        afterAppend(childNode, childN.id);\n      }\n    }\n  }\n  return node;\n}\nfunction visit(mirror, onVisit) {\n  function walk(node) {\n    onVisit(node);\n  }\n  for (const id of mirror.getIds()) {\n    if (mirror.has(id)) {\n      walk(mirror.getNode(id));\n    }\n  }\n}\nfunction handleScroll(node, mirror) {\n  const n = mirror.getMeta(node);\n  if (n?.type !== NodeType.Element) {\n    return;\n  }\n  const el = node;\n  for (const name in n.attributes) {\n    if (!(Object.prototype.hasOwnProperty.call(n.attributes, name) && name.startsWith(\"rr_\"))) {\n      continue;\n    }\n    const value = n.attributes[name];\n    if (name === \"rr_scrollLeft\") {\n      el.scrollLeft = value;\n    }\n    if (name === \"rr_scrollTop\") {\n      el.scrollTop = value;\n    }\n  }\n}\nfunction rebuild(n, options) {\n  const {\n    doc,\n    onVisit,\n    hackCss = true,\n    afterAppend,\n    cache,\n    mirror = new Mirror()\n  } = options;\n  const node = buildNodeWithSN(n, {\n    doc,\n    mirror,\n    skipChild: false,\n    hackCss,\n    afterAppend,\n    cache\n  });\n  visit(mirror, (visitedNode) => {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n    handleScroll(visitedNode, mirror);\n  });\n  return node;\n}\nexport {\n  IGNORED_NODE,\n  Mirror,\n  NodeType,\n  addHoverClass,\n  buildNodeWithSN,\n  classMatchesRegex,\n  cleanupSnapshot,\n  clearTimeout,\n  createCache,\n  createMatchPredicate,\n  createMirror,\n  distanceToMatch,\n  escapeImportStatement,\n  extractFileExtension,\n  fixAllCssProperty,\n  fixSafariColons,\n  genId,\n  getIframeContentDocument,\n  getInputType,\n  getInputValue,\n  ignoreAttribute,\n  is2DCanvasBlank,\n  isCSSImportRule,\n  isCSSStyleRule,\n  isElement,\n  isNativeShadowDom,\n  isNodeMetaEqual,\n  isShadowRoot,\n  maskInputValue,\n  needMaskingText,\n  onRequestAnimationFrame,\n  rebuild,\n  serializeNodeWithId,\n  setTimeout,\n  shouldMaskInput,\n  snapshot,\n  stringifyRule,\n  stringifyStylesheet,\n  toLowerCase,\n  toUpperCase,\n  transformAttribute,\n  visitSnapshot\n};\n//# sourceMappingURL=rrweb-snapshot.js.map\n","// Note that these are the serialized attributes and not attributes directly on\n// the DOM Node. Attributes we are interested in:\nconst ATTRIBUTES_TO_RECORD = new Set([\n  'id',\n  'class',\n  'aria-label',\n  'role',\n  'name',\n  'alt',\n  'title',\n  'data-test-id',\n  'data-testid',\n  'disabled',\n  'aria-disabled',\n  'data-sentry-component',\n]);\n\n/**\n * Inclusion list of attributes that we want to record from the DOM element\n */\nexport function getAttributesToRecord(attributes: Record<string, unknown>): Record<string, unknown> {\n  const obj: Record<string, unknown> = {};\n  if (!attributes['data-sentry-component'] && attributes['data-sentry-element']) {\n    attributes['data-sentry-component'] = attributes['data-sentry-element'];\n  }\n  for (const key in attributes) {\n    if (ATTRIBUTES_TO_RECORD.has(key)) {\n      let normalizedKey = key;\n\n      if (key === 'data-testid' || key === 'data-test-id') {\n        normalizedKey = 'testId';\n      }\n\n      obj[normalizedKey] = attributes[key];\n    }\n  }\n\n  return obj;\n}\n","import { record } from '@sentry-internal/rrweb';\nimport type { serializedElementNodeWithId, serializedNodeWithId } from '@sentry-internal/rrweb-snapshot';\nimport { NodeType } from '@sentry-internal/rrweb-snapshot';\nimport { htmlTreeAsString } from '@sentry/core';\nimport type { Breadcrumb, HandlerDataDom } from '@sentry/core';\n\nimport type { ReplayContainer } from '../types';\nimport { createBreadcrumb } from '../util/createBreadcrumb';\nimport { handleClick } from './handleClick';\nimport { addBreadcrumbEvent } from './util/addBreadcrumbEvent';\nimport { getClickTargetNode, getTargetNode } from './util/domUtils';\nimport { getAttributesToRecord } from './util/getAttributesToRecord';\n\nexport const handleDomListener: (replay: ReplayContainer) => (handlerData: HandlerDataDom) => void = (\n  replay: ReplayContainer,\n) => {\n  return (handlerData: HandlerDataDom): void => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleDom(handlerData);\n\n    if (!result) {\n      return;\n    }\n\n    const isClick = handlerData.name === 'click';\n    const event = isClick ? (handlerData.event as PointerEvent) : undefined;\n    // Ignore clicks if ctrl/alt/meta/shift keys are held down as they alter behavior of clicks (e.g. open in new tab)\n    if (\n      isClick &&\n      replay.clickDetector &&\n      event &&\n      event.target &&\n      !event.altKey &&\n      !event.metaKey &&\n      !event.ctrlKey &&\n      !event.shiftKey\n    ) {\n      handleClick(\n        replay.clickDetector,\n        result as Breadcrumb & { timestamp: number; data: { nodeId: number } },\n        getClickTargetNode(handlerData.event as Event) as HTMLElement,\n      );\n    }\n\n    addBreadcrumbEvent(replay, result);\n  };\n};\n\n/** Get the base DOM breadcrumb. */\nexport function getBaseDomBreadcrumb(target: Node | null, message: string): Breadcrumb {\n  const nodeId = record.mirror.getId(target);\n  const node = nodeId && record.mirror.getNode(nodeId);\n  const meta = node && record.mirror.getMeta(node);\n  const element = meta && isElement(meta) ? meta : null;\n\n  return {\n    message,\n    data: element\n      ? {\n          nodeId,\n          node: {\n            id: nodeId,\n            tagName: element.tagName,\n            textContent: Array.from(element.childNodes)\n              .map((node: serializedNodeWithId) => node.type === NodeType.Text && node.textContent)\n              .filter(Boolean) // filter out empty values\n              .map(text => (text as string).trim())\n              .join(''),\n            attributes: getAttributesToRecord(element.attributes),\n          },\n        }\n      : {},\n  };\n}\n\n/**\n * An event handler to react to DOM events.\n * Exported for tests.\n */\nexport function handleDom(handlerData: HandlerDataDom): Breadcrumb | null {\n  const { target, message } = getDomTarget(handlerData);\n\n  return createBreadcrumb({\n    category: `ui.${handlerData.name}`,\n    ...getBaseDomBreadcrumb(target, message),\n  });\n}\n\nfunction getDomTarget(handlerData: HandlerDataDom): { target: Node | null; message: string } {\n  const isClick = handlerData.name === 'click';\n\n  let message: string | undefined;\n  let target: Node | null = null;\n\n  // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n  try {\n    target = isClick ? getClickTargetNode(handlerData.event as Event) : getTargetNode(handlerData.event as Event);\n    message = htmlTreeAsString(target, { maxStringLength: 200 }) || '<unknown>';\n  } catch (e) {\n    message = '<unknown>';\n  }\n\n  return { target, message };\n}\n\nfunction isElement(node: serializedNodeWithId): node is serializedElementNodeWithId {\n  return node.type === NodeType.Element;\n}\n","import { htmlTreeAsString } from '@sentry/core';\nimport type { Breadcrumb } from '@sentry/core';\n\nimport type { ReplayContainer } from '../types';\nimport { createBreadcrumb } from '../util/createBreadcrumb';\nimport { getBaseDomBreadcrumb } from './handleDom';\nimport { addBreadcrumbEvent } from './util/addBreadcrumbEvent';\n\n/** Handle keyboard events & create breadcrumbs. */\nexport function handleKeyboardEvent(replay: ReplayContainer, event: KeyboardEvent): void {\n  if (!replay.isEnabled()) {\n    return;\n  }\n\n  // Update user activity, but do not restart recording as it can create\n  // noisy/low-value replays (e.g. user comes back from idle, hits alt-tab, new\n  // session with a single \"keydown\" breadcrumb is created)\n  replay.updateUserActivity();\n\n  const breadcrumb = getKeyboardBreadcrumb(event);\n\n  if (!breadcrumb) {\n    return;\n  }\n\n  addBreadcrumbEvent(replay, breadcrumb);\n}\n\n/** exported only for tests */\nexport function getKeyboardBreadcrumb(event: KeyboardEvent): Breadcrumb | null {\n  const { metaKey, shiftKey, ctrlKey, altKey, key, target } = event;\n\n  // never capture for input fields\n  if (!target || isInputElement(target as HTMLElement) || !key) {\n    return null;\n  }\n\n  // Note: We do not consider shift here, as that means \"uppercase\"\n  const hasModifierKey = metaKey || ctrlKey || altKey;\n  const isCharacterKey = key.length === 1; // other keys like Escape, Tab, etc have a longer length\n\n  // Do not capture breadcrumb if only a word key is pressed\n  // This could leak e.g. user input\n  if (!hasModifierKey && isCharacterKey) {\n    return null;\n  }\n\n  const message = htmlTreeAsString(target, { maxStringLength: 200 }) || '<unknown>';\n  const baseBreadcrumb = getBaseDomBreadcrumb(target as Node, message);\n\n  return createBreadcrumb({\n    category: 'ui.keyDown',\n    message,\n    data: {\n      ...baseBreadcrumb.data,\n      metaKey,\n      shiftKey,\n      ctrlKey,\n      altKey,\n      key,\n    },\n  });\n}\n\nfunction isInputElement(target: HTMLElement): boolean {\n  return target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;\n}\n","import { record } from '@sentry-internal/rrweb';\nimport { browserPerformanceTimeOrigin } from '@sentry/core';\n\nimport { WINDOW } from '../constants';\nimport type {\n  AllPerformanceEntry,\n  AllPerformanceEntryData,\n  ExperimentalPerformanceResourceTiming,\n  NavigationData,\n  PaintData,\n  ReplayContainer,\n  ReplayPerformanceEntry,\n  ResourceData,\n  WebVitalData,\n} from '../types';\n\n// Map entryType -> function to normalize data for event\nconst ENTRY_TYPES: Record<\n  string,\n  (entry: AllPerformanceEntry) => null | ReplayPerformanceEntry<AllPerformanceEntryData>\n> = {\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  resource: createResourceEntry,\n  paint: createPaintEntry,\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  navigation: createNavigationEntry,\n};\n\nexport interface Metric {\n  /**\n   * The current value of the metric.\n   */\n  value: number;\n\n  /**\n   * The rating as to whether the metric value is within the \"good\",\n   * \"needs improvement\", or \"poor\" thresholds of the metric.\n   */\n  rating: 'good' | 'needs-improvement' | 'poor';\n\n  /**\n   * Any performance entries relevant to the metric value calculation.\n   * The array may also be empty if the metric value was not based on any\n   * entries (e.g. a CLS value of 0 given no layout shifts).\n   */\n  entries: PerformanceEntry[] | LayoutShift[];\n}\n\ninterface LayoutShift extends PerformanceEntry {\n  value: number;\n  sources: LayoutShiftAttribution[];\n  hadRecentInput: boolean;\n}\n\ninterface LayoutShiftAttribution {\n  node?: Node;\n  previousRect: DOMRectReadOnly;\n  currentRect: DOMRectReadOnly;\n}\n\n/**\n * Handler creater for web vitals\n */\nexport function webVitalHandler(\n  getter: (metric: Metric) => ReplayPerformanceEntry<AllPerformanceEntryData>,\n  replay: ReplayContainer,\n): (data: { metric: Metric }) => void {\n  return ({ metric }) => void replay.replayPerformanceEntries.push(getter(metric));\n}\n\n/**\n * Create replay performance entries from the browser performance entries.\n */\nexport function createPerformanceEntries(\n  entries: AllPerformanceEntry[],\n): ReplayPerformanceEntry<AllPerformanceEntryData>[] {\n  return entries.map(createPerformanceEntry).filter(Boolean) as ReplayPerformanceEntry<AllPerformanceEntryData>[];\n}\n\nfunction createPerformanceEntry(entry: AllPerformanceEntry): ReplayPerformanceEntry<AllPerformanceEntryData> | null {\n  const entryType = ENTRY_TYPES[entry.entryType];\n  if (!entryType) {\n    return null;\n  }\n\n  return entryType(entry);\n}\n\nfunction getAbsoluteTime(time: number): number {\n  // browserPerformanceTimeOrigin can be undefined if `performance` or\n  // `performance.now` doesn't exist, but this is already checked by this integration\n  return ((browserPerformanceTimeOrigin() || WINDOW.performance.timeOrigin) + time) / 1000;\n}\n\nfunction createPaintEntry(entry: PerformancePaintTiming): ReplayPerformanceEntry<PaintData> {\n  const { duration, entryType, name, startTime } = entry;\n\n  const start = getAbsoluteTime(startTime);\n  return {\n    type: entryType,\n    name,\n    start,\n    end: start + duration,\n    data: undefined,\n  };\n}\n\nfunction createNavigationEntry(entry: PerformanceNavigationTiming): ReplayPerformanceEntry<NavigationData> | null {\n  const {\n    entryType,\n    name,\n    decodedBodySize,\n    duration,\n    domComplete,\n    encodedBodySize,\n    domContentLoadedEventStart,\n    domContentLoadedEventEnd,\n    domInteractive,\n    loadEventStart,\n    loadEventEnd,\n    redirectCount,\n    startTime,\n    transferSize,\n    type,\n  } = entry;\n\n  // Ignore entries with no duration, they do not seem to be useful and cause dupes\n  if (duration === 0) {\n    return null;\n  }\n\n  return {\n    type: `${entryType}.${type}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(domComplete),\n    name,\n    data: {\n      size: transferSize,\n      decodedBodySize,\n      encodedBodySize,\n      duration,\n      domInteractive,\n      domContentLoadedEventStart,\n      domContentLoadedEventEnd,\n      loadEventStart,\n      loadEventEnd,\n      domComplete,\n      redirectCount,\n    },\n  };\n}\n\nfunction createResourceEntry(\n  entry: ExperimentalPerformanceResourceTiming,\n): ReplayPerformanceEntry<ResourceData> | null {\n  const {\n    entryType,\n    initiatorType,\n    name,\n    responseEnd,\n    startTime,\n    decodedBodySize,\n    encodedBodySize,\n    responseStatus,\n    transferSize,\n  } = entry;\n\n  // Core SDK handles these\n  if (['fetch', 'xmlhttprequest'].includes(initiatorType)) {\n    return null;\n  }\n\n  return {\n    type: `${entryType}.${initiatorType}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(responseEnd),\n    name,\n    data: {\n      size: transferSize,\n      statusCode: responseStatus,\n      decodedBodySize,\n      encodedBodySize,\n    },\n  };\n}\n\n/**\n * Add a LCP event to the replay based on a LCP metric.\n */\nexport function getLargestContentfulPaint(metric: Metric): ReplayPerformanceEntry<WebVitalData> {\n  const lastEntry = metric.entries[metric.entries.length - 1] as (PerformanceEntry & { element?: Node }) | undefined;\n  const node = lastEntry?.element ? [lastEntry.element] : undefined;\n  return getWebVital(metric, 'largest-contentful-paint', node);\n}\n\nfunction isLayoutShift(entry: PerformanceEntry): entry is LayoutShift {\n  return (entry as LayoutShift).sources !== undefined;\n}\n\n/**\n * Add a CLS event to the replay based on a CLS metric.\n */\nexport function getCumulativeLayoutShift(metric: Metric): ReplayPerformanceEntry<WebVitalData> {\n  const layoutShifts: WebVitalData['attributions'] = [];\n  const nodes: Node[] = [];\n  for (const entry of metric.entries) {\n    if (isLayoutShift(entry)) {\n      const nodeIds = [];\n      for (const source of entry.sources) {\n        if (source.node) {\n          nodes.push(source.node);\n          const nodeId = record.mirror.getId(source.node);\n          if (nodeId) {\n            nodeIds.push(nodeId);\n          }\n        }\n      }\n      layoutShifts.push({ value: entry.value, nodeIds: nodeIds.length ? nodeIds : undefined });\n    }\n  }\n\n  return getWebVital(metric, 'cumulative-layout-shift', nodes, layoutShifts);\n}\n\n/**\n * Add a FID event to the replay based on a FID metric.\n */\nexport function getFirstInputDelay(metric: Metric): ReplayPerformanceEntry<WebVitalData> {\n  const lastEntry = metric.entries[metric.entries.length - 1] as (PerformanceEntry & { target?: Node }) | undefined;\n  const node = lastEntry?.target ? [lastEntry.target] : undefined;\n  return getWebVital(metric, 'first-input-delay', node);\n}\n\n/**\n * Add an INP event to the replay based on an INP metric.\n */\nexport function getInteractionToNextPaint(metric: Metric): ReplayPerformanceEntry<WebVitalData> {\n  const lastEntry = metric.entries[metric.entries.length - 1] as (PerformanceEntry & { target?: Node }) | undefined;\n  const node = lastEntry?.target ? [lastEntry.target] : undefined;\n  return getWebVital(metric, 'interaction-to-next-paint', node);\n}\n\n/**\n * Add an web vital event to the replay based on the web vital metric.\n */\nfunction getWebVital(\n  metric: Metric,\n  name: string,\n  nodes: Node[] | undefined,\n  attributions?: WebVitalData['attributions'],\n): ReplayPerformanceEntry<WebVitalData> {\n  const value = metric.value;\n  const rating = metric.rating;\n\n  const end = getAbsoluteTime(value);\n\n  return {\n    type: 'web-vital',\n    name,\n    start: end,\n    end,\n    data: {\n      value,\n      size: value,\n      rating,\n      nodeIds: nodes ? nodes.map(node => record.mirror.getId(node)) : undefined,\n      attributions,\n    },\n  };\n}\n","import {\n  addClsInstrumentationHandler,\n  addFidInstrumentationHandler,\n  addInpInstrumentationHandler,\n  addLcpInstrumentationHandler,\n  addPerformanceInstrumentationHandler,\n} from '@sentry-internal/browser-utils';\nimport type { ReplayContainer } from '../types';\nimport {\n  getCumulativeLayoutShift,\n  getFirstInputDelay,\n  getInteractionToNextPaint,\n  getLargestContentfulPaint,\n  webVitalHandler,\n} from '../util/createPerformanceEntries';\n\n/**\n * Sets up a PerformanceObserver to listen to all performance entry types.\n * Returns a callback to stop observing.\n */\nexport function setupPerformanceObserver(replay: ReplayContainer): () => void {\n  function addPerformanceEntry(entry: PerformanceEntry): void {\n    // It is possible for entries to come up multiple times\n    if (!replay.performanceEntries.includes(entry)) {\n      replay.performanceEntries.push(entry);\n    }\n  }\n\n  function onEntries({ entries }: { entries: PerformanceEntry[] }): void {\n    entries.forEach(addPerformanceEntry);\n  }\n\n  const clearCallbacks: (() => void)[] = [];\n\n  (['navigation', 'paint', 'resource'] as const).forEach(type => {\n    clearCallbacks.push(addPerformanceInstrumentationHandler(type, onEntries));\n  });\n\n  clearCallbacks.push(\n    addLcpInstrumentationHandler(webVitalHandler(getLargestContentfulPaint, replay)),\n    addClsInstrumentationHandler(webVitalHandler(getCumulativeLayoutShift, replay)),\n    addFidInstrumentationHandler(webVitalHandler(getFirstInputDelay, replay)),\n    addInpInstrumentationHandler(webVitalHandler(getInteractionToNextPaint, replay)),\n  );\n\n  // A callback to cleanup all handlers\n  return () => {\n    clearCallbacks.forEach(clearCallback => clearCallback());\n  };\n}\n","declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n","export default `var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),s=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),a=function(t,e){for(var i=new n(31),s=0;s<31;++s)i[s]=e+=1<<t[s-1];var a=new r(i[30]);for(s=1;s<30;++s)for(var o=i[s];o<i[s+1];++o)a[o]=o-i[s]<<5|s;return{b:i,r:a}},o=a(e,2),h=o.b,f=o.r;h[28]=258,f[258]=28;for(var l=a(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,s=0,a=new n(r);s<i;++s)t[s]&&++a[t[s]-1];var o,h=new n(r);for(s=1;s<r;++s)h[s]=h[s-1]+a[s-1]<<1;if(e){o=new n(1<<r);var f=15-r;for(s=0;s<i;++s)if(t[s])for(var l=s<<4|t[s],c=r-t[s],v=h[t[s]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>f]=l}else for(o=new n(i),s=0;s<i;++s)t[s]&&(o[s]=u[h[t[s]-1]++]>>15-t[s]);return o},p=new t(288);for(c=0;c<144;++c)p[c]=8;for(c=144;c<256;++c)p[c]=9;for(c=256;c<280;++c)p[c]=7;for(c=280;c<288;++c)p[c]=8;var g=new t(32);for(c=0;c<32;++c)g[c]=5;var w=d(p,9,0),y=d(g,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},_=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},x=function(r,e){for(var i=[],s=0;s<r.length;++s)r[s]&&i.push({s:s,f:r[s]});var a=i.length,o=i.slice();if(!a)return{t:F,l:0};if(1==a){var h=new t(i[0].s+1);return h[i[0].s]=1,{t:h,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var f=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:f.f+l.f,l:f,r:l};c!=a-1;)f=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:f.f+l.f,l:f,r:l};var d=o[0].s;for(s=1;s<a;++s)o[s].s>d&&(d=o[s].s);var p=new n(d+1),g=A(i[c-1],p,0);if(g>e){s=0;var w=0,y=g-e,m=1<<y;for(o.sort((function(t,n){return p[n.s]-p[t.s]||t.f-n.f}));s<a;++s){var b=o[s].s;if(!(p[b]>e))break;w+=m-(1<<g-p[b]),p[b]=e}for(w>>=y;w>0;){var M=o[s].s;p[M]<e?w-=1<<e-p[M]++-1:++s}for(;s>=0&&w;--s){var E=o[s].s;p[E]==e&&(--p[E],++w)}g=e}return{t:new t(p),l:g}},A=function(t,n,r){return-1==t.s?Math.max(A(t.l,n,r+1),A(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,s=t[0],a=1,o=function(t){e[i++]=t},h=1;h<=r;++h)if(t[h]==s&&h!=r)++a;else{if(!s&&a>2){for(;a>138;a-=138)o(32754);a>2&&(o(a>10?a-11<<5|28690:a-3<<5|12305),a=0)}else if(a>3){for(o(s),--a;a>6;a-=6)o(8304);a>2&&(o(a-3<<5|8208),a=0)}for(;a--;)o(s);a=1,s=t[h]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var s=0;s<e;++s)t[i+s+4]=r[s];return 8*(i+4+e)},U=function(t,r,a,o,h,f,l,u,c,v,m){z(r,m++,a),++h[256];for(var b=x(h,15),M=b.t,E=b.l,A=x(f,15),U=A.t,C=A.l,F=D(M),I=F.c,S=F.n,L=D(U),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=x(q,7),H=G.t,J=G.l,K=19;K>4&&!H[s[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(h,p)+T(f,g)+l,X=T(h,M)+T(f,U)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(U,C,0),R=U;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[s[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=w,P=p,Q=y,R=g;for(B=0;B<u;++B){var rt=o[B];if(rt>255){_(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;_(r,m,Q[et]),m+=R[et],et>3&&(_(r,m,rt>>5&8191),m+=i[et])}else _(r,m,N[rt]),m+=P[rt]}return _(r,m,N[256]),m+P[256]},C=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}},L=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,s=0|r.length,a=0;a!=s;){for(var o=Math.min(a+2655,s);a<o;++a)i+=e+=r[a];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},O=function(s,a,o,h,u){if(!u&&(u={l:1},a.dictionary)){var c=a.dictionary.subarray(-32768),v=new t(c.length+s.length);v.set(c),v.set(s,c.length),s=v,u.w=c.length}return function(s,a,o,h,u,c){var v=c.z||s.length,d=new t(h+v+5*(1+Math.ceil(v/7e3))+u),p=d.subarray(h,d.length-u),g=c.l,w=7&(c.r||0);if(a){w&&(p[0]=c.r>>3);for(var y=C[a-1],M=y>>13,E=8191&y,z=(1<<o)-1,_=c.p||new n(32768),x=c.h||new n(z+1),A=Math.ceil(o/3),D=2*A,T=function(t){return(s[t]^s[t+1]<<A^s[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=x[H];if(_[J]=K,x[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!g)){w=U(s,p,0,F,I,S,O,q,G,j-G,w),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(s[j+Q]==s[j+Q-W]){for(var $=0;$<Z&&s[j+$]==s[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-_[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=_[J])&32767}if(R){F[q++]=268435456|f[Q]<<18|l[R];var it=31&f[Q],st=31&l[R];O+=e[it]+i[st],++I[257+it],++S[st],B=j+Q,++L}else F[q++]=s[j],++I[s[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=s[j],++I[s[j]];w=U(s,p,g,F,I,S,O,q,G,j-G,w),g||(c.r=7&w|p[w/8|0]<<3,w-=7,c.h=x,c.p=_,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+g;j+=65535){var at=j+65535;at>=v&&(p[w/8|0]=g,at=v),w=k(p,w+1,s.subarray(j,at))}c.i=v}return b(d,0,h+m(w)+u)}(s,null==a.level?6:a.level,null==a.mem?u.l?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(s.length)))):20:12+a.mem,o,h,u)},j=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},q=function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&j(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}},B=function(t){return 10+(t.filename?t.filename.length+1:0)},G=function(){function n(n,r){if(\"function\"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(O(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var s=this.b.length-this.s.z;this.b.set(n.subarray(0,s),this.s.z),this.s.z=this.b.length,this.p(this.b,!1),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(s),32768),this.s.z=n.length-s+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n.prototype.flush=function(){this.ondata||E(5),this.s.l&&E(4),this.p(this.b,!1),this.s.w=this.s.i,this.s.i-=2},n}();var H=function(){function t(t,n){this.c=L(),this.v=1,G.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),G.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=O(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=L();i.p(n.dictionary),j(t,2,i.d())}}(r,this.o),this.v=0),n&&j(r,r.length-4,this.c.d()),this.ondata(r,n)},t.prototype.flush=function(){G.prototype.flush.call(this)},t}(),J=\"undefined\"!=typeof TextEncoder&&new TextEncoder,K=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{K.decode(F,{stream:!0})}catch(t){}var N=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(P(t),this.d=n||!1)},t}();function P(n,r){if(J)return J.encode(n);for(var e=n.length,i=new t(n.length+(n.length>>1)),s=0,a=function(t){i[s++]=t},o=0;o<e;++o){if(s+5>i.length){var h=new t(s+8+(e-o<<1));h.set(i),i=h}var f=n.charCodeAt(o);f<128||r?a(f):f<2048?(a(192|f>>6),a(128|63&f)):f>55295&&f<57344?(a(240|(f=65536+(1047552&f)|1023&n.charCodeAt(++o))>>18),a(128|f>>12&63),a(128|f>>6&63),a(128|63&f)):(a(224|f>>12),a(128|f>>6&63),a(128|63&f))}return b(i,0,s)}function Q(t){return function(t,n){n||(n={});var r=S(),e=t.length;r.p(t);var i=O(t,n,B(n),8),s=i.length;return q(i,n),j(i,s-8,r.d()),j(i,s-4,e),i}(P(t))}const R=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error(\"Adding invalid event\");const n=this._hasEvents?\",\":\"\";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push(\"]\",!0);const t=function(t){let n=0;for(const r of t)n+=r.length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new H,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new N(((t,n)=>{this.deflate.push(t,n)})),this.stream.push(\"[\")}},V={clear:()=>{R.clear()},addEvent:t=>R.addEvent(t),finish:()=>R.finish(),compress:t=>Q(t)};addEventListener(\"message\",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in V&&\"function\"==typeof V[n])try{const t=V[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:\"init\",success:!0,response:void 0});`;\n","import r from\"./worker\";function e(){const e=new Blob([r]);return URL.createObjectURL(e)}export{e as getWorkerURL};\n","import type { ConsoleLevel, Logger, SeverityLevel } from '@sentry/core';\nimport { addBreadcrumb, captureException, logger as coreLogger, severityLevelFromString } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\n\ntype ReplayConsoleLevels = Extract<ConsoleLevel, 'info' | 'warn' | 'error' | 'log'>;\nconst CONSOLE_LEVELS: readonly ReplayConsoleLevels[] = ['info', 'warn', 'error', 'log'] as const;\nconst PREFIX = '[Replay] ';\n\ntype LoggerMethod = (...args: unknown[]) => void;\n\ninterface LoggerConfig {\n  captureExceptions: boolean;\n  traceInternals: boolean;\n}\n\ninterface ReplayLogger extends Logger {\n  /**\n   * Calls `logger.info` but saves breadcrumb in the next tick due to race\n   * conditions before replay is initialized.\n   */\n  infoTick: LoggerMethod;\n  /**\n   * Captures exceptions (`Error`) if \"capture internal exceptions\" is enabled\n   */\n  exception: LoggerMethod;\n  /**\n   * Configures the logger with additional debugging behavior\n   */\n  setConfig(config: Partial<LoggerConfig>): void;\n}\n\nfunction _addBreadcrumb(message: unknown, level: SeverityLevel = 'info'): void {\n  addBreadcrumb(\n    {\n      category: 'console',\n      data: {\n        logger: 'replay',\n      },\n      level,\n      message: `${PREFIX}${message}`,\n    },\n    { level },\n  );\n}\n\nfunction makeReplayLogger(): ReplayLogger {\n  let _capture = false;\n  let _trace = false;\n\n  const _logger: Partial<ReplayLogger> = {\n    exception: () => undefined,\n    infoTick: () => undefined,\n    setConfig: (opts: Partial<LoggerConfig>) => {\n      _capture = !!opts.captureExceptions;\n      _trace = !!opts.traceInternals;\n    },\n  };\n\n  if (DEBUG_BUILD) {\n    CONSOLE_LEVELS.forEach(name => {\n      _logger[name] = (...args: unknown[]) => {\n        coreLogger[name](PREFIX, ...args);\n        if (_trace) {\n          _addBreadcrumb(args.join(''), severityLevelFromString(name));\n        }\n      };\n    });\n\n    _logger.exception = (error: unknown, ...message: unknown[]) => {\n      if (message.length && _logger.error) {\n        _logger.error(...message);\n      }\n\n      coreLogger.error(PREFIX, error);\n\n      if (_capture) {\n        captureException(error);\n      } else if (_trace) {\n        // No need for a breadcrumb if `_capture` is enabled since it should be\n        // captured as an exception\n        _addBreadcrumb(error, 'error');\n      }\n    };\n\n    _logger.infoTick = (...args: unknown[]) => {\n      coreLogger.info(PREFIX, ...args);\n      if (_trace) {\n        // Wait a tick here to avoid race conditions for some initial logs\n        // which may be added before replay is initialized\n        setTimeout(() => _addBreadcrumb(args[0]), 0);\n      }\n    };\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      _logger[name] = () => undefined;\n    });\n  }\n\n  return _logger as ReplayLogger;\n}\n\nexport const logger = makeReplayLogger();\n","import { REPLAY_MAX_EVENT_BUFFER_SIZE } from '../constants';\n\n/** This error indicates that the event buffer size exceeded the limit.. */\nexport class EventBufferSizeExceededError extends Error {\n  public constructor() {\n    super(`Event buffer exceeded maximum size of ${REPLAY_MAX_EVENT_BUFFER_SIZE}.`);\n  }\n}\n","import { REPLAY_MAX_EVENT_BUFFER_SIZE } from '../constants';\nimport type { AddEventResult, EventBuffer, EventBufferType, RecordingEvent } from '../types';\nimport { timestampToMs } from '../util/timestamp';\nimport { EventBufferSizeExceededError } from './error';\n\n/**\n * A basic event buffer that does not do any compression.\n * Used as fallback if the compression worker cannot be loaded or is disabled.\n */\nexport class EventBufferArray implements EventBuffer {\n  /** All the events that are buffered to be sent. */\n  public events: RecordingEvent[];\n\n  /** @inheritdoc */\n  public hasCheckout: boolean;\n\n  /** @inheritdoc */\n  public waitForCheckout: boolean;\n\n  private _totalSize: number;\n\n  public constructor() {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n    this.waitForCheckout = false;\n  }\n\n  /** @inheritdoc */\n  public get hasEvents(): boolean {\n    return this.events.length > 0;\n  }\n\n  /** @inheritdoc */\n  public get type(): EventBufferType {\n    return 'sync';\n  }\n\n  /** @inheritdoc */\n  public destroy(): void {\n    this.events = [];\n  }\n\n  /** @inheritdoc */\n  public async addEvent(event: RecordingEvent): Promise<AddEventResult> {\n    const eventSize = JSON.stringify(event).length;\n    this._totalSize += eventSize;\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      throw new EventBufferSizeExceededError();\n    }\n\n    this.events.push(event);\n  }\n\n  /** @inheritdoc */\n  public finish(): Promise<string> {\n    return new Promise<string>(resolve => {\n      // Make a copy of the events array reference and immediately clear the\n      // events member so that we do not lose new events while uploading\n      // attachment.\n      const eventsRet = this.events;\n      this.clear();\n      resolve(JSON.stringify(eventsRet));\n    });\n  }\n\n  /** @inheritdoc */\n  public clear(): void {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n  }\n\n  /** @inheritdoc */\n  public getEarliestTimestamp(): number | null {\n    const timestamp = this.events.map(event => event.timestamp).sort()[0];\n\n    if (!timestamp) {\n      return null;\n    }\n\n    return timestampToMs(timestamp);\n  }\n}\n","import { DEBUG_BUILD } from '../debug-build';\nimport type { WorkerRequest, WorkerResponse } from '../types';\nimport { logger } from '../util/logger';\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nexport class WorkerHandler {\n  private _worker: Worker;\n  private _id: number;\n  private _ensureReadyPromise?: Promise<void>;\n\n  public constructor(worker: Worker) {\n    this._worker = worker;\n    this._id = 0;\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occurred.\n   */\n  public ensureReady(): Promise<void> {\n    // Ensure we only check once\n    if (this._ensureReadyPromise) {\n      return this._ensureReadyPromise;\n    }\n\n    this._ensureReadyPromise = new Promise((resolve, reject) => {\n      this._worker.addEventListener(\n        'message',\n        ({ data }: MessageEvent) => {\n          if ((data as WorkerResponse).success) {\n            resolve();\n          } else {\n            reject();\n          }\n        },\n        { once: true },\n      );\n\n      this._worker.addEventListener(\n        'error',\n        error => {\n          reject(error);\n        },\n        { once: true },\n      );\n    });\n\n    return this._ensureReadyPromise;\n  }\n\n  /**\n   * Destroy the worker.\n   */\n  public destroy(): void {\n    DEBUG_BUILD && logger.info('Destroying compression worker');\n    this._worker.terminate();\n  }\n\n  /**\n   * Post message to worker and wait for response before resolving promise.\n   */\n  public postMessage<T>(method: WorkerRequest['method'], arg?: WorkerRequest['arg']): Promise<T> {\n    const id = this._getAndIncrementId();\n\n    return new Promise((resolve, reject) => {\n      const listener = ({ data }: MessageEvent): void => {\n        const response = data as WorkerResponse;\n        if (response.method !== method) {\n          return;\n        }\n\n        // There can be multiple listeners for a single method, the id ensures\n        // that the response matches the caller.\n        if (response.id !== id) {\n          return;\n        }\n\n        // At this point, we'll always want to remove listener regardless of result status\n        this._worker.removeEventListener('message', listener);\n\n        if (!response.success) {\n          // TODO: Do some error handling, not sure what\n          DEBUG_BUILD && logger.error('Error in compression worker: ', response.response);\n\n          reject(new Error('Error in compression worker'));\n          return;\n        }\n\n        resolve(response.response as T);\n      };\n\n      // Note: we can't use `once` option because it's possible it needs to\n      // listen to multiple messages\n      this._worker.addEventListener('message', listener);\n      this._worker.postMessage({ id, method, arg });\n    });\n  }\n\n  /** Get the current ID and increment it for the next call. */\n  private _getAndIncrementId(): number {\n    return this._id++;\n  }\n}\n","import type { ReplayRecordingData } from '@sentry/core';\n\nimport { REPLAY_MAX_EVENT_BUFFER_SIZE } from '../constants';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { AddEventResult, EventBuffer, EventBufferType, RecordingEvent } from '../types';\nimport { logger } from '../util/logger';\nimport { timestampToMs } from '../util/timestamp';\nimport { WorkerHandler } from './WorkerHandler';\nimport { EventBufferSizeExceededError } from './error';\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nexport class EventBufferCompressionWorker implements EventBuffer {\n  /** @inheritdoc */\n  public hasCheckout: boolean;\n\n  /** @inheritdoc */\n  public waitForCheckout: boolean;\n\n  private _worker: WorkerHandler;\n  private _earliestTimestamp: number | null;\n  private _totalSize;\n\n  public constructor(worker: Worker) {\n    this._worker = new WorkerHandler(worker);\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n    this.waitForCheckout = false;\n  }\n\n  /** @inheritdoc */\n  public get hasEvents(): boolean {\n    return !!this._earliestTimestamp;\n  }\n\n  /** @inheritdoc */\n  public get type(): EventBufferType {\n    return 'worker';\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occurred.\n   */\n  public ensureReady(): Promise<void> {\n    return this._worker.ensureReady();\n  }\n\n  /**\n   * Destroy the event buffer.\n   */\n  public destroy(): void {\n    this._worker.destroy();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfully received and processed by worker.\n   */\n  public addEvent(event: RecordingEvent): Promise<AddEventResult> {\n    const timestamp = timestampToMs(event.timestamp);\n    if (!this._earliestTimestamp || timestamp < this._earliestTimestamp) {\n      this._earliestTimestamp = timestamp;\n    }\n\n    const data = JSON.stringify(event);\n    this._totalSize += data.length;\n\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      return Promise.reject(new EventBufferSizeExceededError());\n    }\n\n    return this._sendEventToWorker(data);\n  }\n\n  /**\n   * Finish the event buffer and return the compressed data.\n   */\n  public finish(): Promise<ReplayRecordingData> {\n    return this._finishRequest();\n  }\n\n  /** @inheritdoc */\n  public clear(): void {\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n\n    // We do not wait on this, as we assume the order of messages is consistent for the worker\n    this._worker.postMessage('clear').then(null, e => {\n      DEBUG_BUILD && logger.exception(e, 'Sending \"clear\" message to worker failed', e);\n    });\n  }\n\n  /** @inheritdoc */\n  public getEarliestTimestamp(): number | null {\n    return this._earliestTimestamp;\n  }\n\n  /**\n   * Send the event to the worker.\n   */\n  private _sendEventToWorker(data: string): Promise<AddEventResult> {\n    return this._worker.postMessage<void>('addEvent', data);\n  }\n\n  /**\n   * Finish the request and return the compressed data from the worker.\n   */\n  private async _finishRequest(): Promise<Uint8Array> {\n    const response = await this._worker.postMessage<Uint8Array>('finish');\n\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n\n    return response;\n  }\n}\n","import type { ReplayRecordingData } from '@sentry/core';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { AddEventResult, EventBuffer, EventBufferType, RecordingEvent } from '../types';\nimport { logger } from '../util/logger';\nimport { EventBufferArray } from './EventBufferArray';\nimport { EventBufferCompressionWorker } from './EventBufferCompressionWorker';\n\n/**\n * This proxy will try to use the compression worker, and fall back to use the simple buffer if an error occurs there.\n * This can happen e.g. if the worker cannot be loaded.\n * Exported only for testing.\n */\nexport class EventBufferProxy implements EventBuffer {\n  private _fallback: EventBufferArray;\n  private _compression: EventBufferCompressionWorker;\n  private _used: EventBuffer;\n  private _ensureWorkerIsLoadedPromise: Promise<void>;\n\n  public constructor(worker: Worker) {\n    this._fallback = new EventBufferArray();\n    this._compression = new EventBufferCompressionWorker(worker);\n    this._used = this._fallback;\n\n    this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded();\n  }\n\n  /** @inheritdoc */\n  public get waitForCheckout(): boolean {\n    return this._used.waitForCheckout;\n  }\n\n  /** @inheritdoc */\n  public get type(): EventBufferType {\n    return this._used.type;\n  }\n\n  /** @inheritDoc */\n  public get hasEvents(): boolean {\n    return this._used.hasEvents;\n  }\n\n  /** @inheritdoc */\n  public get hasCheckout(): boolean {\n    return this._used.hasCheckout;\n  }\n  /** @inheritdoc */\n  public set hasCheckout(value: boolean) {\n    this._used.hasCheckout = value;\n  }\n\n  /** @inheritdoc */\n  // eslint-disable-next-line @typescript-eslint/adjacent-overload-signatures\n  public set waitForCheckout(value: boolean) {\n    this._used.waitForCheckout = value;\n  }\n\n  /** @inheritDoc */\n  public destroy(): void {\n    this._fallback.destroy();\n    this._compression.destroy();\n  }\n\n  /** @inheritdoc */\n  public clear(): void {\n    return this._used.clear();\n  }\n\n  /** @inheritdoc */\n  public getEarliestTimestamp(): number | null {\n    return this._used.getEarliestTimestamp();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfully added.\n   */\n  public addEvent(event: RecordingEvent): Promise<AddEventResult> {\n    return this._used.addEvent(event);\n  }\n\n  /** @inheritDoc */\n  public async finish(): Promise<ReplayRecordingData> {\n    // Ensure the worker is loaded, so the sent event is compressed\n    await this.ensureWorkerIsLoaded();\n\n    return this._used.finish();\n  }\n\n  /** Ensure the worker has loaded. */\n  public ensureWorkerIsLoaded(): Promise<void> {\n    return this._ensureWorkerIsLoadedPromise;\n  }\n\n  /** Actually check if the worker has been loaded. */\n  private async _ensureWorkerIsLoaded(): Promise<void> {\n    try {\n      await this._compression.ensureReady();\n    } catch (error) {\n      // If the worker fails to load, we fall back to the simple buffer.\n      // Nothing more to do from our side here\n      DEBUG_BUILD && logger.exception(error, 'Failed to load the compression worker, falling back to simple buffer');\n      return;\n    }\n\n    // Now we need to switch over the array buffer to the compression worker\n    await this._switchToCompressionWorker();\n  }\n\n  /** Switch the used buffer to the compression worker. */\n  private async _switchToCompressionWorker(): Promise<void> {\n    const { events, hasCheckout, waitForCheckout } = this._fallback;\n\n    const addEventPromises: Promise<void>[] = [];\n    for (const event of events) {\n      addEventPromises.push(this._compression.addEvent(event));\n    }\n\n    this._compression.hasCheckout = hasCheckout;\n    this._compression.waitForCheckout = waitForCheckout;\n\n    // We switch over to the new buffer immediately - any further events will be added\n    // after the previously buffered ones\n    this._used = this._compression;\n\n    // Wait for original events to be re-added before resolving\n    try {\n      await Promise.all(addEventPromises);\n\n      // Can now clear fallback buffer as it's no longer necessary\n      this._fallback.clear();\n    } catch (error) {\n      DEBUG_BUILD && logger.exception(error, 'Failed to add events when switching buffers.');\n    }\n  }\n}\n","import { getWorkerURL } from '@sentry-internal/replay-worker';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { EventBuffer } from '../types';\nimport { logger } from '../util/logger';\nimport { EventBufferArray } from './EventBufferArray';\nimport { EventBufferProxy } from './EventBufferProxy';\n\ninterface CreateEventBufferParams {\n  useCompression: boolean;\n  workerUrl?: string;\n}\n\n// Treeshakable guard to remove the code of the included compression worker\ndeclare const __SENTRY_EXCLUDE_REPLAY_WORKER__: boolean;\n\n/**\n * Create an event buffer for replays.\n */\nexport function createEventBuffer({\n  useCompression,\n  workerUrl: customWorkerUrl,\n}: CreateEventBufferParams): EventBuffer {\n  if (\n    useCompression &&\n    // eslint-disable-next-line no-restricted-globals\n    window.Worker\n  ) {\n    const worker = _loadWorker(customWorkerUrl);\n\n    if (worker) {\n      return worker;\n    }\n  }\n\n  DEBUG_BUILD && logger.info('Using simple buffer');\n  return new EventBufferArray();\n}\n\nfunction _loadWorker(customWorkerUrl?: string): EventBufferProxy | void {\n  try {\n    const workerUrl = customWorkerUrl || _getWorkerUrl();\n\n    if (!workerUrl) {\n      return;\n    }\n\n    DEBUG_BUILD && logger.info(`Using compression worker${customWorkerUrl ? ` from ${customWorkerUrl}` : ''}`);\n    const worker = new Worker(workerUrl);\n    return new EventBufferProxy(worker);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to create compression worker');\n    // Fall back to use simple event buffer array\n  }\n}\n\nfunction _getWorkerUrl(): string {\n  if (typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ === 'undefined' || !__SENTRY_EXCLUDE_REPLAY_WORKER__) {\n    return getWorkerURL();\n  }\n\n  return '';\n}\n","import { WINDOW } from '../constants';\n\n/** If sessionStorage is available. */\nexport function hasSessionStorage(): boolean {\n  try {\n    // This can throw, e.g. when being accessed in a sandboxed iframe\n    return 'sessionStorage' in WINDOW && !!WINDOW.sessionStorage;\n  } catch {\n    return false;\n  }\n}\n","import { REPLAY_SESSION_KEY, WINDOW } from '../../src/constants';\nimport type { ReplayContainer } from '../../src/types';\nimport { hasSessionStorage } from '../util/hasSessionStorage';\n\n/**\n * Removes the session from Session Storage and unsets session in replay instance\n */\nexport function clearSession(replay: ReplayContainer): void {\n  deleteSession();\n  replay.session = undefined;\n}\n\n/**\n * Deletes a session from storage\n */\nfunction deleteSession(): void {\n  if (!hasSessionStorage()) {\n    return;\n  }\n\n  try {\n    WINDOW.sessionStorage.removeItem(REPLAY_SESSION_KEY);\n  } catch {\n    // Ignore potential SecurityError exceptions\n  }\n}\n","/**\n * Given a sample rate, returns true if replay should be sampled.\n *\n * 1.0 = 100% sampling\n * 0.0 = 0% sampling\n */\nexport function isSampled(sampleRate?: number): boolean {\n  if (sampleRate === undefined) {\n    return false;\n  }\n\n  // Math.random() returns a number in range of 0 to 1 (inclusive of 0, but not 1)\n  return Math.random() < sampleRate;\n}\n","import { uuid4 } from '@sentry/core';\n\nimport type { Sampled, Session } from '../types';\n\n/**\n * Get a session with defaults & applied sampling.\n */\nexport function makeSession(session: Partial<Session> & { sampled: Sampled }): Session {\n  const now = Date.now();\n  const id = session.id || uuid4();\n  // Note that this means we cannot set a started/lastActivity of `0`, but this should not be relevant outside of tests.\n  const started = session.started || now;\n  const lastActivity = session.lastActivity || now;\n  const segmentId = session.segmentId || 0;\n  const sampled = session.sampled;\n  const previousSessionId = session.previousSessionId;\n\n  return {\n    id,\n    started,\n    lastActivity,\n    segmentId,\n    sampled,\n    previousSessionId,\n  };\n}\n","import { REPLAY_SESSION_KEY, WINDOW } from '../constants';\nimport type { Session } from '../types';\nimport { hasSessionStorage } from '../util/hasSessionStorage';\n\n/**\n * Save a session to session storage.\n */\nexport function saveSession(session: Session): void {\n  if (!hasSessionStorage()) {\n    return;\n  }\n\n  try {\n    WINDOW.sessionStorage.setItem(REPLAY_SESSION_KEY, JSON.stringify(session));\n  } catch {\n    // Ignore potential SecurityError exceptions\n  }\n}\n","import type { Sampled, Session, SessionOptions } from '../types';\nimport { isSampled } from '../util/isSampled';\nimport { makeSession } from './Session';\nimport { saveSession } from './saveSession';\n\n/**\n * Get the sampled status for a session based on sample rates & current sampled status.\n */\nexport function getSessionSampleType(sessionSampleRate: number, allowBuffering: boolean): Sampled {\n  return isSampled(sessionSampleRate) ? 'session' : allowBuffering ? 'buffer' : false;\n}\n\n/**\n * Create a new session, which in its current implementation is a Sentry event\n * that all replays will be saved to as attachments. Currently, we only expect\n * one of these Sentry events per \"replay session\".\n */\nexport function createSession(\n  { sessionSampleRate, allowBuffering, stickySession = false }: SessionOptions,\n  { previousSessionId }: { previousSessionId?: string } = {},\n): Session {\n  const sampled = getSessionSampleType(sessionSampleRate, allowBuffering);\n  const session = makeSession({\n    sampled,\n    previousSessionId,\n  });\n\n  if (stickySession) {\n    saveSession(session);\n  }\n\n  return session;\n}\n","import { REPLAY_SESSION_KEY, WINDOW } from '../constants';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { Session } from '../types';\nimport { hasSessionStorage } from '../util/hasSessionStorage';\nimport { logger } from '../util/logger';\nimport { makeSession } from './Session';\n\n/**\n * Fetches a session from storage\n */\nexport function fetchSession(): Session | null {\n  if (!hasSessionStorage()) {\n    return null;\n  }\n\n  try {\n    // This can throw if cookies are disabled\n    const sessionStringFromStorage = WINDOW.sessionStorage.getItem(REPLAY_SESSION_KEY);\n\n    if (!sessionStringFromStorage) {\n      return null;\n    }\n\n    const sessionObj = JSON.parse(sessionStringFromStorage) as Session;\n\n    DEBUG_BUILD && logger.infoTick('Loading existing session');\n\n    return makeSession(sessionObj);\n  } catch {\n    return null;\n  }\n}\n","/**\n * Given an initial timestamp and an expiry duration, checks to see if current\n * time should be considered as expired.\n */\nexport function isExpired(\n  initialTime: null | number,\n  expiry: undefined | number,\n  targetTime: number = +new Date(),\n): boolean {\n  // Always expired if < 0\n  if (initialTime === null || expiry === undefined || expiry < 0) {\n    return true;\n  }\n\n  // Never expires if == 0\n  if (expiry === 0) {\n    return false;\n  }\n\n  return initialTime + expiry <= targetTime;\n}\n","import type { Session } from '../types';\nimport { isExpired } from './isExpired';\n\n/**\n * Checks to see if session is expired\n */\nexport function isSessionExpired(\n  session: Session,\n  {\n    maxReplayDuration,\n    sessionIdleExpire,\n    targetTime = Date.now(),\n  }: { maxReplayDuration: number; sessionIdleExpire: number; targetTime?: number },\n): boolean {\n  return (\n    // First, check that maximum session length has not been exceeded\n    isExpired(session.started, maxReplayDuration, targetTime) ||\n    // check that the idle timeout has not been exceeded (i.e. user has\n    // performed an action within the last `sessionIdleExpire` ms)\n    isExpired(session.lastActivity, sessionIdleExpire, targetTime)\n  );\n}\n","import type { Session } from '../types';\nimport { isSessionExpired } from '../util/isSessionExpired';\n\n/** If the session should be refreshed or not. */\nexport function shouldRefreshSession(\n  session: Session,\n  { sessionIdleExpire, maxReplayDuration }: { sessionIdleExpire: number; maxReplayDuration: number },\n): boolean {\n  // If not expired, all good, just keep the session\n  if (!isSessionExpired(session, { sessionIdleExpire, maxReplayDuration })) {\n    return false;\n  }\n\n  // If we are buffering & haven't ever flushed yet, always continue\n  if (session.sampled === 'buffer' && session.segmentId === 0) {\n    return false;\n  }\n\n  return true;\n}\n","import { DEBUG_BUILD } from '../debug-build';\nimport type { Session, SessionOptions } from '../types';\nimport { logger } from '../util/logger';\nimport { createSession } from './createSession';\nimport { fetchSession } from './fetchSession';\nimport { shouldRefreshSession } from './shouldRefreshSession';\n\n/**\n * Get or create a session, when initializing the replay.\n * Returns a session that may be unsampled.\n */\nexport function loadOrCreateSession(\n  {\n    sessionIdleExpire,\n    maxReplayDuration,\n    previousSessionId,\n  }: {\n    sessionIdleExpire: number;\n    maxReplayDuration: number;\n    previousSessionId?: string;\n  },\n  sessionOptions: SessionOptions,\n): Session {\n  const existingSession = sessionOptions.stickySession && fetchSession();\n\n  // No session exists yet, just create a new one\n  if (!existingSession) {\n    DEBUG_BUILD && logger.infoTick('Creating new session');\n    return createSession(sessionOptions, { previousSessionId });\n  }\n\n  if (!shouldRefreshSession(existingSession, { sessionIdleExpire, maxReplayDuration })) {\n    return existingSession;\n  }\n\n  DEBUG_BUILD && logger.infoTick('Session in sessionStorage is expired, creating new one...');\n  return createSession(sessionOptions, { previousSessionId: existingSession.id });\n}\n","import { EventType } from '@sentry-internal/rrweb';\nimport { getClient } from '@sentry/core';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport { EventBufferSizeExceededError } from '../eventBuffer/error';\nimport type { AddEventResult, RecordingEvent, ReplayContainer, ReplayFrameEvent, ReplayPluginOptions } from '../types';\nimport { logger } from './logger';\nimport { timestampToMs } from './timestamp';\n\nfunction isCustomEvent(event: RecordingEvent): event is ReplayFrameEvent {\n  return event.type === EventType.Custom;\n}\n\n/**\n * Add an event to the event buffer.\n * In contrast to `addEvent`, this does not return a promise & does not wait for the adding of the event to succeed/fail.\n * Instead this returns `true` if we tried to add the event, else false.\n * It returns `false` e.g. if we are paused, disabled, or out of the max replay duration.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nexport function addEventSync(replay: ReplayContainer, event: RecordingEvent, isCheckout?: boolean): boolean {\n  if (!shouldAddEvent(replay, event)) {\n    return false;\n  }\n\n  // This should never reject\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  _addEvent(replay, event, isCheckout);\n\n  return true;\n}\n\n/**\n * Add an event to the event buffer.\n * Resolves to `null` if no event was added, else to `void`.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nexport function addEvent(\n  replay: ReplayContainer,\n  event: RecordingEvent,\n  isCheckout?: boolean,\n): Promise<AddEventResult | null> {\n  if (!shouldAddEvent(replay, event)) {\n    return Promise.resolve(null);\n  }\n\n  return _addEvent(replay, event, isCheckout);\n}\n\nasync function _addEvent(\n  replay: ReplayContainer,\n  event: RecordingEvent,\n  isCheckout?: boolean,\n): Promise<AddEventResult | null> {\n  const { eventBuffer } = replay;\n\n  if (!eventBuffer || (eventBuffer.waitForCheckout && !isCheckout)) {\n    return null;\n  }\n\n  const isBufferMode = replay.recordingMode === 'buffer';\n\n  try {\n    if (isCheckout && isBufferMode) {\n      eventBuffer.clear();\n    }\n\n    if (isCheckout) {\n      eventBuffer.hasCheckout = true;\n      eventBuffer.waitForCheckout = false;\n    }\n\n    const replayOptions = replay.getOptions();\n\n    const eventAfterPossibleCallback = maybeApplyCallback(event, replayOptions.beforeAddRecordingEvent);\n\n    if (!eventAfterPossibleCallback) {\n      return;\n    }\n\n    return await eventBuffer.addEvent(eventAfterPossibleCallback);\n  } catch (error) {\n    const isExceeded = error && error instanceof EventBufferSizeExceededError;\n    const reason = isExceeded ? 'addEventSizeExceeded' : 'addEvent';\n\n    if (isExceeded && isBufferMode) {\n      // Clear buffer and wait for next checkout\n      eventBuffer.clear();\n      eventBuffer.waitForCheckout = true;\n\n      return null;\n    }\n\n    replay.handleException(error);\n\n    await replay.stop({ reason });\n\n    const client = getClient();\n\n    if (client) {\n      client.recordDroppedEvent('internal_sdk_error', 'replay');\n    }\n  }\n}\n\n/** Exported only for tests. */\nexport function shouldAddEvent(replay: ReplayContainer, event: RecordingEvent): boolean {\n  if (!replay.eventBuffer || replay.isPaused() || !replay.isEnabled()) {\n    return false;\n  }\n\n  const timestampInMs = timestampToMs(event.timestamp);\n\n  // Throw out events that happen more than 5 minutes ago. This can happen if\n  // page has been left open and idle for a long period of time and user\n  // comes back to trigger a new session. The performance entries rely on\n  // `performance.timeOrigin`, which is when the page first opened.\n  if (timestampInMs + replay.timeouts.sessionIdlePause < Date.now()) {\n    return false;\n  }\n\n  // Throw out events that are +60min from the initial timestamp\n  if (timestampInMs > replay.getContext().initialTimestamp + replay.getOptions().maxReplayDuration) {\n    DEBUG_BUILD &&\n      logger.infoTick(`Skipping event with timestamp ${timestampInMs} because it is after maxReplayDuration`);\n    return false;\n  }\n\n  return true;\n}\n\nfunction maybeApplyCallback(\n  event: RecordingEvent,\n  callback: ReplayPluginOptions['beforeAddRecordingEvent'],\n): RecordingEvent | null | undefined {\n  try {\n    if (typeof callback === 'function' && isCustomEvent(event)) {\n      return callback(event);\n    }\n  } catch (error) {\n    DEBUG_BUILD &&\n      logger.exception(error, 'An error occurred in the `beforeAddRecordingEvent` callback, skipping the event...');\n    return null;\n  }\n\n  return event;\n}\n","import type { ErrorEvent, Event, FeedbackEvent, ReplayEvent, TransactionEvent } from '@sentry/core';\n\n/** If the event is an error event */\nexport function isErrorEvent(event: Event): event is ErrorEvent {\n  return !event.type;\n}\n\n/** If the event is a transaction event */\nexport function isTransactionEvent(event: Event): event is TransactionEvent {\n  return event.type === 'transaction';\n}\n\n/** If the event is an replay event */\nexport function isReplayEvent(event: Event): event is ReplayEvent {\n  return event.type === 'replay_event';\n}\n\n/** If the event is a feedback event */\nexport function isFeedbackEvent(event: Event): event is FeedbackEvent {\n  return event.type === 'feedback';\n}\n","import { setTimeout } from '@sentry-internal/browser-utils';\nimport type { ErrorEvent, Event, TransactionEvent, TransportMakeRequestResponse } from '@sentry/core';\n\nimport type { ReplayContainer } from '../types';\nimport { isErrorEvent, isTransactionEvent } from '../util/eventUtils';\n\ntype AfterSendEventCallback = (event: Event, sendResponse: TransportMakeRequestResponse) => void;\n\n/**\n * Returns a listener to be added to `client.on('afterSendErrorEvent, listener)`.\n */\nexport function handleAfterSendEvent(replay: ReplayContainer): AfterSendEventCallback {\n  return (event: Event, sendResponse: TransportMakeRequestResponse) => {\n    if (!replay.isEnabled() || (!isErrorEvent(event) && !isTransactionEvent(event))) {\n      return;\n    }\n\n    const statusCode = sendResponse?.statusCode;\n\n    // We only want to do stuff on successful error sending, otherwise you get error replays without errors attached\n    // If not using the base transport, we allow `undefined` response (as a custom transport may not implement this correctly yet)\n    // If we do use the base transport, we skip if we encountered an non-OK status code\n    if (!statusCode || statusCode < 200 || statusCode >= 300) {\n      return;\n    }\n\n    if (isTransactionEvent(event)) {\n      handleTransactionEvent(replay, event);\n      return;\n    }\n\n    handleErrorEvent(replay, event);\n  };\n}\n\nfunction handleTransactionEvent(replay: ReplayContainer, event: TransactionEvent): void {\n  const replayContext = replay.getContext();\n\n  // Collect traceIds in _context regardless of `recordingMode`\n  // In error mode, _context gets cleared on every checkout\n  // We limit to max. 100 transactions linked\n  if (event.contexts?.trace?.trace_id && replayContext.traceIds.size < 100) {\n    replayContext.traceIds.add(event.contexts.trace.trace_id);\n  }\n}\n\nfunction handleErrorEvent(replay: ReplayContainer, event: ErrorEvent): void {\n  const replayContext = replay.getContext();\n\n  // Add error to list of errorIds of replay. This is ok to do even if not\n  // sampled because context will get reset at next checkout.\n  // XXX: There is also a race condition where it's possible to capture an\n  // error to Sentry before Replay SDK has loaded, but response returns after\n  // it was loaded, and this gets called.\n  // We limit to max. 100 errors linked\n  if (event.event_id && replayContext.errorIds.size < 100) {\n    replayContext.errorIds.add(event.event_id);\n  }\n\n  // If error event is tagged with replay id it means it was sampled (when in buffer mode)\n  // Need to be very careful that this does not cause an infinite loop\n  if (replay.recordingMode !== 'buffer' || !event.tags || !event.tags.replayId) {\n    return;\n  }\n\n  const { beforeErrorSampling } = replay.getOptions();\n  if (typeof beforeErrorSampling === 'function' && !beforeErrorSampling(event)) {\n    return;\n  }\n\n  setTimeout(async () => {\n    try {\n      // Capture current event buffer as new replay\n      await replay.sendBufferedReplayOrFlush();\n    } catch (err) {\n      replay.handleException(err);\n    }\n  });\n}\n","import { getLocationHref } from '@sentry/core';\nimport type { ErrorEvent, Event } from '@sentry/core';\n\nimport type { ReplayContainer } from '../types';\nimport { createBreadcrumb } from '../util/createBreadcrumb';\nimport { isErrorEvent } from '../util/eventUtils';\nimport { addBreadcrumbEvent } from './util/addBreadcrumbEvent';\n\ntype BeforeSendEventCallback = (event: Event) => void;\n\n/**\n * Returns a listener to be added to `client.on('afterSendErrorEvent, listener)`.\n */\nexport function handleBeforeSendEvent(replay: ReplayContainer): BeforeSendEventCallback {\n  return (event: Event) => {\n    if (!replay.isEnabled() || !isErrorEvent(event)) {\n      return;\n    }\n\n    handleHydrationError(replay, event);\n  };\n}\n\nfunction handleHydrationError(replay: ReplayContainer, event: ErrorEvent): void {\n  const exceptionValue = event.exception?.values?.[0]?.value;\n  if (typeof exceptionValue !== 'string') {\n    return;\n  }\n\n  if (\n    // Only matches errors in production builds of react-dom\n    // Example https://reactjs.org/docs/error-decoder.html?invariant=423\n    // With newer React versions, the messages changed to a different website https://react.dev/errors/418\n    exceptionValue.match(\n      /(reactjs\\.org\\/docs\\/error-decoder\\.html\\?invariant=|react\\.dev\\/errors\\/)(418|419|422|423|425)/,\n    ) ||\n    // Development builds of react-dom\n    // Error 1: Hydration failed because the initial UI does not match what was rendered on the server.\n    // Error 2: Text content does not match server-rendered HTML. Warning: Text content did not match.\n    exceptionValue.match(/(does not match server-rendered HTML|Hydration failed because)/i)\n  ) {\n    const breadcrumb = createBreadcrumb({\n      category: 'replay.hydrate-error',\n      data: {\n        url: getLocationHref(),\n      },\n    });\n    addBreadcrumbEvent(replay, breadcrumb);\n  }\n}\n","import type { Breadcrumb } from '@sentry/core';\nimport { getClient, normalize } from '@sentry/core';\nimport { CONSOLE_ARG_MAX_SIZE } from '../constants';\nimport type { ReplayContainer } from '../types';\nimport type { ReplayFrame } from '../types/replayFrame';\nimport { createBreadcrumb } from '../util/createBreadcrumb';\nimport { addBreadcrumbEvent } from './util/addBreadcrumbEvent';\n\ntype BreadcrumbWithCategory = Required<Pick<Breadcrumb, 'category'>>;\n\n/**\n * Handle breadcrumbs that Sentry captures, and make sure to capture relevant breadcrumbs to Replay as well.\n */\nexport function handleBreadcrumbs(replay: ReplayContainer): void {\n  const client = getClient();\n\n  if (!client) {\n    return;\n  }\n\n  client.on('beforeAddBreadcrumb', breadcrumb => beforeAddBreadcrumb(replay, breadcrumb));\n}\n\nfunction beforeAddBreadcrumb(replay: ReplayContainer, breadcrumb: Breadcrumb): void {\n  if (!replay.isEnabled() || !isBreadcrumbWithCategory(breadcrumb)) {\n    return;\n  }\n\n  const result = normalizeBreadcrumb(breadcrumb);\n  if (result) {\n    addBreadcrumbEvent(replay, result);\n  }\n}\n\n/** Exported only for tests. */\nexport function normalizeBreadcrumb(breadcrumb: Breadcrumb): Breadcrumb | null {\n  if (\n    !isBreadcrumbWithCategory(breadcrumb) ||\n    [\n      // fetch & xhr are handled separately,in handleNetworkBreadcrumbs\n      'fetch',\n      'xhr',\n      // These two are breadcrumbs for emitted sentry events, we don't care about them\n      'sentry.event',\n      'sentry.transaction',\n    ].includes(breadcrumb.category) ||\n    // We capture UI breadcrumbs separately\n    breadcrumb.category.startsWith('ui.')\n  ) {\n    return null;\n  }\n\n  if (breadcrumb.category === 'console') {\n    return normalizeConsoleBreadcrumb(breadcrumb);\n  }\n\n  return createBreadcrumb(breadcrumb);\n}\n\n/** exported for tests only */\nexport function normalizeConsoleBreadcrumb(\n  breadcrumb: Omit<Breadcrumb, 'category'> & BreadcrumbWithCategory,\n): ReplayFrame {\n  const args = breadcrumb.data?.arguments;\n\n  if (!Array.isArray(args) || args.length === 0) {\n    return createBreadcrumb(breadcrumb);\n  }\n\n  let isTruncated = false;\n\n  // Avoid giant args captures\n  const normalizedArgs = args.map(arg => {\n    if (!arg) {\n      return arg;\n    }\n    if (typeof arg === 'string') {\n      if (arg.length > CONSOLE_ARG_MAX_SIZE) {\n        isTruncated = true;\n        return `${arg.slice(0, CONSOLE_ARG_MAX_SIZE)}…`;\n      }\n\n      return arg;\n    }\n    if (typeof arg === 'object') {\n      try {\n        const normalizedArg = normalize(arg, 7);\n        const stringified = JSON.stringify(normalizedArg);\n        if (stringified.length > CONSOLE_ARG_MAX_SIZE) {\n          isTruncated = true;\n          // We use the pretty printed JSON string here as a base\n          return `${JSON.stringify(normalizedArg, null, 2).slice(0, CONSOLE_ARG_MAX_SIZE)}…`;\n        }\n        return normalizedArg;\n      } catch {\n        // fall back to default\n      }\n    }\n\n    return arg;\n  });\n\n  return createBreadcrumb({\n    ...breadcrumb,\n    data: {\n      ...breadcrumb.data,\n      arguments: normalizedArgs,\n      ...(isTruncated ? { _meta: { warnings: ['CONSOLE_ARG_TRUNCATED'] } } : {}),\n    },\n  });\n}\n\nfunction isBreadcrumbWithCategory(breadcrumb: Breadcrumb): breadcrumb is BreadcrumbWithCategory {\n  return !!breadcrumb.category;\n}\n","import type { Event, EventHint } from '@sentry/core';\n\n/**\n * Returns true if we think the given event is an error originating inside of rrweb.\n */\nexport function isRrwebError(event: Event, hint: EventHint): boolean {\n  if (event.type || !event.exception || !event.exception.values || !event.exception.values.length) {\n    return false;\n  }\n\n  // @ts-expect-error this may be set by rrweb when it finds errors\n  if (hint.originalException?.__rrweb__) {\n    return true;\n  }\n\n  return false;\n}\n","import { getActiveSpan, getCurrentScope, getDynamicSamplingContextFromSpan } from '@sentry/core';\nimport type { DynamicSamplingContext } from '@sentry/core';\n\n/**\n * Reset the `replay_id` field on the DSC.\n */\nexport function resetReplayIdOnDynamicSamplingContext(): void {\n  // Reset DSC on the current scope, if there is one\n  const dsc = getCurrentScope().getPropagationContext().dsc;\n  if (dsc) {\n    delete dsc.replay_id;\n  }\n\n  // Clear it from frozen DSC on the active span\n  const activeSpan = getActiveSpan();\n  if (activeSpan) {\n    const dsc = getDynamicSamplingContextFromSpan(activeSpan);\n    delete (dsc as Partial<DynamicSamplingContext>).replay_id;\n  }\n}\n","import { EventType } from '@sentry-internal/rrweb';\nimport type { FeedbackEvent } from '@sentry/core';\n\nimport type { ReplayBreadcrumbFrameEvent, ReplayContainer } from '../../types';\n\n/**\n * Add a feedback breadcrumb event to replay.\n */\nexport function addFeedbackBreadcrumb(replay: ReplayContainer, event: FeedbackEvent): void {\n  replay.triggerUserActivity();\n  replay.addUpdate(() => {\n    if (!event.timestamp) {\n      // Ignore events that don't have timestamps (this shouldn't happen, more of a typing issue)\n      // Return true here so that we don't flush\n      return true;\n    }\n\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: event.timestamp * 1000,\n      data: {\n        tag: 'breadcrumb',\n        payload: {\n          timestamp: event.timestamp,\n          type: 'default',\n          category: 'sentry.feedback',\n          data: {\n            feedbackId: event.event_id,\n          },\n        },\n      },\n    } as ReplayBreadcrumbFrameEvent);\n\n    return false;\n  });\n}\n","import type { Event } from '@sentry/core';\n\nimport { UNABLE_TO_SEND_REPLAY } from '../../constants';\nimport type { ReplayContainer } from '../../types';\nimport { isSampled } from '../../util/isSampled';\n\n/**\n * Determine if event should be sampled (only applies in buffer mode).\n * When an event is captured by `handleGlobalEvent`, when in buffer mode\n * we determine if we want to sample the error or not.\n */\nexport function shouldSampleForBufferEvent(replay: ReplayContainer, event: Event): boolean {\n  if (replay.recordingMode !== 'buffer') {\n    return false;\n  }\n\n  // ignore this error because otherwise we could loop indefinitely with\n  // trying to capture replay and failing\n  if (event.message === UNABLE_TO_SEND_REPLAY) {\n    return false;\n  }\n\n  // Require the event to be an error event & to have an exception\n  if (!event.exception || event.type) {\n    return false;\n  }\n\n  return isSampled(replay.getOptions().errorSampleRate);\n}\n","import type { Event, EventHint } from '@sentry/core';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { ReplayContainer } from '../types';\nimport { isErrorEvent, isFeedbackEvent, isReplayEvent, isTransactionEvent } from '../util/eventUtils';\nimport { isRrwebError } from '../util/isRrwebError';\nimport { logger } from '../util/logger';\nimport { resetReplayIdOnDynamicSamplingContext } from '../util/resetReplayIdOnDynamicSamplingContext';\nimport { addFeedbackBreadcrumb } from './util/addFeedbackBreadcrumb';\nimport { shouldSampleForBufferEvent } from './util/shouldSampleForBufferEvent';\n\n/**\n * Returns a listener to be added to `addEventProcessor(listener)`.\n */\nexport function handleGlobalEventListener(replay: ReplayContainer): (event: Event, hint: EventHint) => Event | null {\n  return Object.assign(\n    (event: Event, hint: EventHint) => {\n      // Do nothing if replay has been disabled or paused\n      if (!replay.isEnabled() || replay.isPaused()) {\n        return event;\n      }\n\n      if (isReplayEvent(event)) {\n        // Replays have separate set of breadcrumbs, do not include breadcrumbs\n        // from core SDK\n        delete event.breadcrumbs;\n        return event;\n      }\n\n      // We only want to handle errors, transactions, and feedbacks, nothing else\n      if (!isErrorEvent(event) && !isTransactionEvent(event) && !isFeedbackEvent(event)) {\n        return event;\n      }\n\n      // Ensure we do not add replay_id if the session is expired\n      const isSessionActive = replay.checkAndHandleExpiredSession();\n      if (!isSessionActive) {\n        // prevent exceeding replay durations by removing the expired replayId from the DSC\n        resetReplayIdOnDynamicSamplingContext();\n        return event;\n      }\n\n      if (isFeedbackEvent(event)) {\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        replay.flush();\n        event.contexts.feedback.replay_id = replay.getSessionId();\n        // Add a replay breadcrumb for this piece of feedback\n        addFeedbackBreadcrumb(replay, event);\n        return event;\n      }\n\n      // Unless `captureExceptions` is enabled, we want to ignore errors coming from rrweb\n      // As there can be a bunch of stuff going wrong in internals there, that we don't want to bubble up to users\n      if (isRrwebError(event, hint) && !replay.getOptions()._experiments.captureExceptions) {\n        DEBUG_BUILD && logger.log('Ignoring error from rrweb internals', event);\n        return null;\n      }\n\n      // When in buffer mode, we decide to sample here.\n      // Later, in `handleAfterSendEvent`, if the replayId is set, we know that we sampled\n      // And convert the buffer session to a full session\n      const isErrorEventSampled = shouldSampleForBufferEvent(replay, event);\n\n      // Tag errors if it has been sampled in buffer mode, or if it is session mode\n      // Only tag transactions if in session mode\n      const shouldTagReplayId = isErrorEventSampled || replay.recordingMode === 'session';\n\n      if (shouldTagReplayId) {\n        event.tags = { ...event.tags, replayId: replay.getSessionId() };\n      }\n\n      return event;\n    },\n    { id: 'Replay' },\n  );\n}\n","import { EventType } from '@sentry-internal/rrweb';\n\nimport type { AddEventResult, AllEntryData, ReplayContainer, ReplayPerformanceEntry } from '../types';\n\n/**\n * Create a \"span\" for each performance entry.\n */\nexport function createPerformanceSpans(\n  replay: ReplayContainer,\n  entries: ReplayPerformanceEntry<AllEntryData>[],\n): Promise<AddEventResult | null>[] {\n  return entries.map(({ type, start, end, name, data }) => {\n    const response = replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: start,\n      data: {\n        tag: 'performanceSpan',\n        payload: {\n          op: type,\n          description: name,\n          startTimestamp: start,\n          endTimestamp: end,\n          data,\n        },\n      },\n    });\n\n    // If response is a string, it means its either THROTTLED or SKIPPED\n    return typeof response === 'string' ? Promise.resolve(null) : response;\n  });\n}\n","import type { HandlerDataHistory } from '@sentry/core';\n\nimport type { HistoryData, ReplayContainer, ReplayPerformanceEntry } from '../types';\nimport { createPerformanceSpans } from '../util/createPerformanceSpans';\n\nfunction handleHistory(handlerData: HandlerDataHistory): ReplayPerformanceEntry<HistoryData> {\n  const { from, to } = handlerData;\n\n  const now = Date.now() / 1000;\n\n  return {\n    type: 'navigation.push',\n    start: now,\n    end: now,\n    name: to,\n    data: {\n      previous: from,\n    },\n  };\n}\n\n/**\n * Returns a listener to be added to `addHistoryInstrumentationHandler(listener)`.\n */\nexport function handleHistorySpanListener(replay: ReplayContainer): (handlerData: HandlerDataHistory) => void {\n  return (handlerData: HandlerDataHistory) => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleHistory(handlerData);\n\n    if (result === null) {\n      return;\n    }\n\n    // Need to collect visited URLs\n    replay.getContext().urls.push(result.name);\n    replay.triggerUserActivity();\n\n    replay.addUpdate(() => {\n      createPerformanceSpans(replay, [result]);\n      // Returning false to flush\n      return false;\n    });\n  };\n}\n","import { getClient, isSentryRequestUrl } from '@sentry/core';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { ReplayContainer } from '../types';\n\n/**\n * Check whether a given request URL should be filtered out. This is so we\n * don't log Sentry ingest requests.\n */\nexport function shouldFilterRequest(replay: ReplayContainer, url: string): boolean {\n  // If we enabled the `traceInternals` experiment, we want to trace everything\n  if (DEBUG_BUILD && replay.getOptions()._experiments.traceInternals) {\n    return false;\n  }\n\n  return isSentryRequestUrl(url, getClient());\n}\n","import type { NetworkRequestData, ReplayContainer, ReplayPerformanceEntry } from '../../types';\nimport { createPerformanceSpans } from '../../util/createPerformanceSpans';\nimport { shouldFilterRequest } from '../../util/shouldFilterRequest';\n\n/** Add a performance entry breadcrumb */\nexport function addNetworkBreadcrumb(\n  replay: ReplayContainer,\n  result: ReplayPerformanceEntry<NetworkRequestData> | null,\n): void {\n  if (!replay.isEnabled()) {\n    return;\n  }\n\n  if (result === null) {\n    return;\n  }\n\n  if (shouldFilterRequest(replay, result.name)) {\n    return;\n  }\n\n  replay.addUpdate(() => {\n    createPerformanceSpans(replay, [result]);\n    // Returning true will cause `addUpdate` to not flush\n    // We do not want network requests to cause a flush. This will prevent\n    // recurring/polling requests from keeping the replay session alive.\n    return true;\n  });\n}\n","import { serializeFormData } from '@sentry-internal/browser-utils';\nimport type { NetworkMetaWarning } from '@sentry-internal/browser-utils';\nimport { stringMatchesSomePattern } from '@sentry/core';\n\nimport { NETWORK_BODY_MAX_SIZE, WINDOW } from '../../constants';\nimport type {\n  NetworkBody,\n  NetworkRequestData,\n  ReplayNetworkRequestData,\n  ReplayNetworkRequestOrResponse,\n  ReplayPerformanceEntry,\n} from '../../types';\n\n/** Get the size of a body. */\nexport function getBodySize(body: RequestInit['body']): number | undefined {\n  if (!body) {\n    return undefined;\n  }\n\n  const textEncoder = new TextEncoder();\n\n  try {\n    if (typeof body === 'string') {\n      return textEncoder.encode(body).length;\n    }\n\n    if (body instanceof URLSearchParams) {\n      return textEncoder.encode(body.toString()).length;\n    }\n\n    if (body instanceof FormData) {\n      const formDataStr = serializeFormData(body);\n      return textEncoder.encode(formDataStr).length;\n    }\n\n    if (body instanceof Blob) {\n      return body.size;\n    }\n\n    if (body instanceof ArrayBuffer) {\n      return body.byteLength;\n    }\n\n    // Currently unhandled types: ArrayBufferView, ReadableStream\n  } catch {\n    // just return undefined\n  }\n\n  return undefined;\n}\n\n/** Convert a Content-Length header to number/undefined.  */\nexport function parseContentLengthHeader(header: string | null | undefined): number | undefined {\n  if (!header) {\n    return undefined;\n  }\n\n  const size = parseInt(header, 10);\n  return isNaN(size) ? undefined : size;\n}\n\n/** Merge a warning into an existing network request/response. */\nexport function mergeWarning(\n  info: ReplayNetworkRequestOrResponse | undefined,\n  warning: NetworkMetaWarning,\n): ReplayNetworkRequestOrResponse {\n  if (!info) {\n    return {\n      headers: {},\n      size: undefined,\n      _meta: {\n        warnings: [warning],\n      },\n    };\n  }\n\n  const newMeta = { ...info._meta };\n  const existingWarnings = newMeta.warnings || [];\n  newMeta.warnings = [...existingWarnings, warning];\n\n  info._meta = newMeta;\n  return info;\n}\n\n/** Convert ReplayNetworkRequestData to a PerformanceEntry. */\nexport function makeNetworkReplayBreadcrumb(\n  type: string,\n  data: ReplayNetworkRequestData | null,\n): ReplayPerformanceEntry<NetworkRequestData> | null {\n  if (!data) {\n    return null;\n  }\n\n  const { startTimestamp, endTimestamp, url, method, statusCode, request, response } = data;\n\n  const result: ReplayPerformanceEntry<NetworkRequestData> = {\n    type,\n    start: startTimestamp / 1000,\n    end: endTimestamp / 1000,\n    name: url,\n    data: {\n      method,\n      statusCode,\n      request,\n      response,\n    },\n  };\n\n  return result;\n}\n\n/** Build the request or response part of a replay network breadcrumb that was skipped. */\nexport function buildSkippedNetworkRequestOrResponse(bodySize: number | undefined): ReplayNetworkRequestOrResponse {\n  return {\n    headers: {},\n    size: bodySize,\n    _meta: {\n      warnings: ['URL_SKIPPED'],\n    },\n  };\n}\n\n/** Build the request or response part of a replay network breadcrumb. */\nexport function buildNetworkRequestOrResponse(\n  headers: Record<string, string>,\n  bodySize: number | undefined,\n  body: string | undefined,\n): ReplayNetworkRequestOrResponse | undefined {\n  if (!bodySize && Object.keys(headers).length === 0) {\n    return undefined;\n  }\n\n  if (!bodySize) {\n    return {\n      headers,\n    };\n  }\n\n  if (!body) {\n    return {\n      headers,\n      size: bodySize,\n    };\n  }\n\n  const info: ReplayNetworkRequestOrResponse = {\n    headers,\n    size: bodySize,\n  };\n\n  const { body: normalizedBody, warnings } = normalizeNetworkBody(body);\n  info.body = normalizedBody;\n  if (warnings?.length) {\n    info._meta = {\n      warnings,\n    };\n  }\n\n  return info;\n}\n\n/** Filter a set of headers */\nexport function getAllowedHeaders(headers: Record<string, string>, allowedHeaders: string[]): Record<string, string> {\n  return Object.entries(headers).reduce((filteredHeaders: Record<string, string>, [key, value]) => {\n    const normalizedKey = key.toLowerCase();\n    // Avoid putting empty strings into the headers\n    if (allowedHeaders.includes(normalizedKey) && headers[key]) {\n      filteredHeaders[normalizedKey] = value;\n    }\n    return filteredHeaders;\n  }, {});\n}\n\nfunction normalizeNetworkBody(body: string | undefined): {\n  body: NetworkBody | undefined;\n  warnings?: NetworkMetaWarning[];\n} {\n  if (!body || typeof body !== 'string') {\n    return {\n      body,\n    };\n  }\n\n  const exceedsSizeLimit = body.length > NETWORK_BODY_MAX_SIZE;\n  const isProbablyJson = _strIsProbablyJson(body);\n\n  if (exceedsSizeLimit) {\n    const truncatedBody = body.slice(0, NETWORK_BODY_MAX_SIZE);\n\n    if (isProbablyJson) {\n      return {\n        body: truncatedBody,\n        warnings: ['MAYBE_JSON_TRUNCATED'],\n      };\n    }\n\n    return {\n      body: `${truncatedBody}…`,\n      warnings: ['TEXT_TRUNCATED'],\n    };\n  }\n\n  if (isProbablyJson) {\n    try {\n      const jsonBody = JSON.parse(body);\n      return {\n        body: jsonBody,\n      };\n    } catch {\n      // fall back to just send the body as string\n    }\n  }\n\n  return {\n    body,\n  };\n}\n\nfunction _strIsProbablyJson(str: string): boolean {\n  const first = str[0];\n  const last = str[str.length - 1];\n\n  // Simple check: If this does not start & end with {} or [], it's not JSON\n  return (first === '[' && last === ']') || (first === '{' && last === '}');\n}\n\n/** Match an URL against a list of strings/Regex. */\nexport function urlMatches(url: string, urls: (string | RegExp)[]): boolean {\n  const fullUrl = getFullUrl(url);\n\n  return stringMatchesSomePattern(fullUrl, urls);\n}\n\n/** exported for tests */\nexport function getFullUrl(url: string, baseURI = WINDOW.document.baseURI): string {\n  // Short circuit for common cases:\n  if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith(WINDOW.location.origin)) {\n    return url;\n  }\n  const fixedUrl = new URL(url, baseURI);\n\n  // If these do not match, we are not dealing with a relative URL, so just return it\n  if (fixedUrl.origin !== new URL(baseURI).origin) {\n    return url;\n  }\n\n  const fullUrl = fixedUrl.href;\n\n  // Remove trailing slashes, if they don't match the original URL\n  if (!url.endsWith('/') && fullUrl.endsWith('/')) {\n    return fullUrl.slice(0, -1);\n  }\n\n  return fullUrl;\n}\n","import { getBodyString, getFetchRequestArgBody, setTimeout } from '@sentry-internal/browser-utils';\nimport type { FetchHint, NetworkMetaWarning } from '@sentry-internal/browser-utils';\nimport type { Breadcrumb, FetchBreadcrumbData } from '@sentry/core';\n\nimport { DEBUG_BUILD } from '../../debug-build';\nimport type {\n  ReplayContainer,\n  ReplayNetworkOptions,\n  ReplayNetworkRequestData,\n  ReplayNetworkRequestOrResponse,\n} from '../../types';\nimport { logger } from '../../util/logger';\nimport { addNetworkBreadcrumb } from './addNetworkBreadcrumb';\nimport {\n  buildNetworkRequestOrResponse,\n  buildSkippedNetworkRequestOrResponse,\n  getAllowedHeaders,\n  getBodySize,\n  makeNetworkReplayBreadcrumb,\n  mergeWarning,\n  parseContentLengthHeader,\n  urlMatches,\n} from './networkUtils';\n\n/**\n * Capture a fetch breadcrumb to a replay.\n * This adds additional data (where appropriate).\n */\nexport async function captureFetchBreadcrumbToReplay(\n  breadcrumb: Breadcrumb & { data: FetchBreadcrumbData },\n  hint: Partial<FetchHint>,\n  options: ReplayNetworkOptions & {\n    replay: ReplayContainer;\n  },\n): Promise<void> {\n  try {\n    const data = await _prepareFetchData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb('resource.fetch', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to capture fetch breadcrumb');\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nexport function enrichFetchBreadcrumb(\n  breadcrumb: Breadcrumb & { data: FetchBreadcrumbData },\n  hint: Partial<FetchHint>,\n): void {\n  const { input, response } = hint;\n\n  const body = input ? getFetchRequestArgBody(input) : undefined;\n  const reqSize = getBodySize(body);\n\n  const resSize = response ? parseContentLengthHeader(response.headers.get('content-length')) : undefined;\n\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\n\nasync function _prepareFetchData(\n  breadcrumb: Breadcrumb & { data: FetchBreadcrumbData },\n  hint: Partial<FetchHint>,\n  options: ReplayNetworkOptions,\n): Promise<ReplayNetworkRequestData> {\n  const now = Date.now();\n  const { startTimestamp = now, endTimestamp = now } = hint;\n\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize,\n  } = breadcrumb.data;\n\n  const captureDetails =\n    urlMatches(url, options.networkDetailAllowUrls) && !urlMatches(url, options.networkDetailDenyUrls);\n\n  const request = captureDetails\n    ? _getRequestInfo(options, hint.input, requestBodySize)\n    : buildSkippedNetworkRequestOrResponse(requestBodySize);\n  const response = await _getResponseInfo(captureDetails, options, hint.response, responseBodySize);\n\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request,\n    response,\n  };\n}\n\nfunction _getRequestInfo(\n  { networkCaptureBodies, networkRequestHeaders }: ReplayNetworkOptions,\n  input: FetchHint['input'] | undefined,\n  requestBodySize?: number,\n): ReplayNetworkRequestOrResponse | undefined {\n  const headers = input ? getRequestHeaders(input, networkRequestHeaders) : {};\n\n  if (!networkCaptureBodies) {\n    return buildNetworkRequestOrResponse(headers, requestBodySize, undefined);\n  }\n\n  // We only want to transmit string or string-like bodies\n  const requestBody = getFetchRequestArgBody(input);\n  const [bodyStr, warning] = getBodyString(requestBody, logger);\n  const data = buildNetworkRequestOrResponse(headers, requestBodySize, bodyStr);\n\n  if (warning) {\n    return mergeWarning(data, warning);\n  }\n\n  return data;\n}\n\n/** Exported only for tests. */\nexport async function _getResponseInfo(\n  captureDetails: boolean,\n  {\n    networkCaptureBodies,\n    networkResponseHeaders,\n  }: Pick<ReplayNetworkOptions, 'networkCaptureBodies' | 'networkResponseHeaders'>,\n  response: Response | undefined,\n  responseBodySize?: number,\n): Promise<ReplayNetworkRequestOrResponse | undefined> {\n  if (!captureDetails && responseBodySize !== undefined) {\n    return buildSkippedNetworkRequestOrResponse(responseBodySize);\n  }\n\n  const headers = response ? getAllHeaders(response.headers, networkResponseHeaders) : {};\n\n  if (!response || (!networkCaptureBodies && responseBodySize !== undefined)) {\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n\n  const [bodyText, warning] = await _parseFetchResponseBody(response);\n  const result = getResponseData(bodyText, {\n    networkCaptureBodies,\n\n    responseBodySize,\n    captureDetails,\n    headers,\n  });\n\n  if (warning) {\n    return mergeWarning(result, warning);\n  }\n\n  return result;\n}\n\nfunction getResponseData(\n  bodyText: string | undefined,\n  {\n    networkCaptureBodies,\n    responseBodySize,\n    captureDetails,\n    headers,\n  }: {\n    captureDetails: boolean;\n    networkCaptureBodies: boolean;\n    responseBodySize: number | undefined;\n    headers: Record<string, string>;\n  },\n): ReplayNetworkRequestOrResponse | undefined {\n  try {\n    const size = bodyText?.length && responseBodySize === undefined ? getBodySize(bodyText) : responseBodySize;\n\n    if (!captureDetails) {\n      return buildSkippedNetworkRequestOrResponse(size);\n    }\n\n    if (networkCaptureBodies) {\n      return buildNetworkRequestOrResponse(headers, size, bodyText);\n    }\n\n    return buildNetworkRequestOrResponse(headers, size, undefined);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to serialize response body');\n    // fallback\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n}\n\nasync function _parseFetchResponseBody(response: Response): Promise<[string | undefined, NetworkMetaWarning?]> {\n  const res = _tryCloneResponse(response);\n\n  if (!res) {\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n\n  try {\n    const text = await _tryGetResponseText(res);\n    return [text];\n  } catch (error) {\n    if (error instanceof Error && error.message.indexOf('Timeout') > -1) {\n      DEBUG_BUILD && logger.warn('Parsing text body from response timed out');\n      return [undefined, 'BODY_PARSE_TIMEOUT'];\n    }\n\n    DEBUG_BUILD && logger.exception(error, 'Failed to get text body from response');\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n}\n\nfunction getAllHeaders(headers: Headers, allowedHeaders: string[]): Record<string, string> {\n  const allHeaders: Record<string, string> = {};\n\n  allowedHeaders.forEach(header => {\n    if (headers.get(header)) {\n      allHeaders[header] = headers.get(header) as string;\n    }\n  });\n\n  return allHeaders;\n}\n\nfunction getRequestHeaders(fetchArgs: unknown[], allowedHeaders: string[]): Record<string, string> {\n  if (fetchArgs.length === 1 && typeof fetchArgs[0] !== 'string') {\n    return getHeadersFromOptions(fetchArgs[0] as Request | RequestInit, allowedHeaders);\n  }\n\n  if (fetchArgs.length === 2) {\n    return getHeadersFromOptions(fetchArgs[1] as Request | RequestInit, allowedHeaders);\n  }\n\n  return {};\n}\n\nfunction getHeadersFromOptions(\n  input: Request | RequestInit | undefined,\n  allowedHeaders: string[],\n): Record<string, string> {\n  if (!input) {\n    return {};\n  }\n\n  const headers = input.headers;\n\n  if (!headers) {\n    return {};\n  }\n\n  if (headers instanceof Headers) {\n    return getAllHeaders(headers, allowedHeaders);\n  }\n\n  // We do not support this, as it is not really documented (anymore?)\n  if (Array.isArray(headers)) {\n    return {};\n  }\n\n  return getAllowedHeaders(headers, allowedHeaders);\n}\n\nfunction _tryCloneResponse(response: Response): Response | void {\n  try {\n    // We have to clone this, as the body can only be read once\n    return response.clone();\n  } catch (error) {\n    // this can throw if the response was already consumed before\n    DEBUG_BUILD && logger.exception(error, 'Failed to clone response body');\n  }\n}\n\n/**\n * Get the response body of a fetch request, or timeout after 500ms.\n * Fetch can return a streaming body, that may not resolve (or not for a long time).\n * If that happens, we rather abort after a short time than keep waiting for this.\n */\nfunction _tryGetResponseText(response: Response): Promise<string | undefined> {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => reject(new Error('Timeout while trying to read response body')), 500);\n\n    _getResponseText(response)\n      .then(\n        txt => resolve(txt),\n        reason => reject(reason),\n      )\n      .finally(() => clearTimeout(timeout));\n  });\n}\n\nasync function _getResponseText(response: Response): Promise<string> {\n  // Force this to be a promise, just to be safe\n  // eslint-disable-next-line no-return-await\n  return await response.text();\n}\n","import { SENTRY_XHR_DATA_KEY, getBodyString } from '@sentry-internal/browser-utils';\nimport type { NetworkMetaWarning, XhrHint } from '@sentry-internal/browser-utils';\nimport type { Breadcrumb, XhrBreadcrumbData } from '@sentry/core';\n\nimport { DEBUG_BUILD } from '../../debug-build';\nimport type { ReplayContainer, ReplayNetworkOptions, ReplayNetworkRequestData } from '../../types';\nimport { logger } from '../../util/logger';\nimport { addNetworkBreadcrumb } from './addNetworkBreadcrumb';\nimport {\n  buildNetworkRequestOrResponse,\n  buildSkippedNetworkRequestOrResponse,\n  getAllowedHeaders,\n  getBodySize,\n  makeNetworkReplayBreadcrumb,\n  mergeWarning,\n  parseContentLengthHeader,\n  urlMatches,\n} from './networkUtils';\n\n/**\n * Capture an XHR breadcrumb to a replay.\n * This adds additional data (where appropriate).\n */\nexport async function captureXhrBreadcrumbToReplay(\n  breadcrumb: Breadcrumb & { data: XhrBreadcrumbData },\n  hint: Partial<XhrHint>,\n  options: ReplayNetworkOptions & { replay: ReplayContainer },\n): Promise<void> {\n  try {\n    const data = _prepareXhrData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb('resource.xhr', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to capture xhr breadcrumb');\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nexport function enrichXhrBreadcrumb(\n  breadcrumb: Breadcrumb & { data: XhrBreadcrumbData },\n  hint: Partial<XhrHint>,\n): void {\n  const { xhr, input } = hint;\n\n  if (!xhr) {\n    return;\n  }\n\n  const reqSize = getBodySize(input);\n  const resSize = xhr.getResponseHeader('content-length')\n    ? parseContentLengthHeader(xhr.getResponseHeader('content-length'))\n    : _getBodySize(xhr.response, xhr.responseType);\n\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\n\nfunction _prepareXhrData(\n  breadcrumb: Breadcrumb & { data: XhrBreadcrumbData },\n  hint: Partial<XhrHint>,\n  options: ReplayNetworkOptions,\n): ReplayNetworkRequestData | null {\n  const now = Date.now();\n  const { startTimestamp = now, endTimestamp = now, input, xhr } = hint;\n\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize,\n  } = breadcrumb.data;\n\n  if (!url) {\n    return null;\n  }\n\n  if (!xhr || !urlMatches(url, options.networkDetailAllowUrls) || urlMatches(url, options.networkDetailDenyUrls)) {\n    const request = buildSkippedNetworkRequestOrResponse(requestBodySize);\n    const response = buildSkippedNetworkRequestOrResponse(responseBodySize);\n    return {\n      startTimestamp,\n      endTimestamp,\n      url,\n      method,\n      statusCode,\n      request,\n      response,\n    };\n  }\n\n  const xhrInfo = xhr[SENTRY_XHR_DATA_KEY];\n  const networkRequestHeaders = xhrInfo\n    ? getAllowedHeaders(xhrInfo.request_headers, options.networkRequestHeaders)\n    : {};\n  const networkResponseHeaders = getAllowedHeaders(getResponseHeaders(xhr), options.networkResponseHeaders);\n\n  const [requestBody, requestWarning] = options.networkCaptureBodies ? getBodyString(input, logger) : [undefined];\n  const [responseBody, responseWarning] = options.networkCaptureBodies ? _getXhrResponseBody(xhr) : [undefined];\n\n  const request = buildNetworkRequestOrResponse(networkRequestHeaders, requestBodySize, requestBody);\n  const response = buildNetworkRequestOrResponse(networkResponseHeaders, responseBodySize, responseBody);\n\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request: requestWarning ? mergeWarning(request, requestWarning) : request,\n    response: responseWarning ? mergeWarning(response, responseWarning) : response,\n  };\n}\n\nfunction getResponseHeaders(xhr: XMLHttpRequest): Record<string, string> {\n  const headers = xhr.getAllResponseHeaders();\n\n  if (!headers) {\n    return {};\n  }\n\n  return headers.split('\\r\\n').reduce((acc: Record<string, string>, line: string) => {\n    const [key, value] = line.split(': ') as [string, string | undefined];\n    if (value) {\n      acc[key.toLowerCase()] = value;\n    }\n    return acc;\n  }, {});\n}\n\nfunction _getXhrResponseBody(xhr: XMLHttpRequest): [string | undefined, NetworkMetaWarning?] {\n  // We collect errors that happen, but only log them if we can't get any response body\n  const errors: unknown[] = [];\n\n  try {\n    return [xhr.responseText];\n  } catch (e) {\n    errors.push(e);\n  }\n\n  // Try to manually parse the response body, if responseText fails\n  try {\n    return _parseXhrResponse(xhr.response, xhr.responseType);\n  } catch (e) {\n    errors.push(e);\n  }\n\n  DEBUG_BUILD && logger.warn('Failed to get xhr response body', ...errors);\n\n  return [undefined];\n}\n\n/**\n * Get the string representation of the XHR response.\n * Based on MDN, these are the possible types of the response:\n * string\n * ArrayBuffer\n * Blob\n * Document\n * POJO\n *\n * Exported only for tests.\n */\nexport function _parseXhrResponse(\n  body: XMLHttpRequest['response'],\n  responseType: XMLHttpRequest['responseType'],\n): [string | undefined, NetworkMetaWarning?] {\n  try {\n    if (typeof body === 'string') {\n      return [body];\n    }\n\n    if (body instanceof Document) {\n      return [body.body.outerHTML];\n    }\n\n    if (responseType === 'json' && body && typeof body === 'object') {\n      return [JSON.stringify(body)];\n    }\n\n    if (!body) {\n      return [undefined];\n    }\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to serialize body', body);\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n\n  DEBUG_BUILD && logger.info('Skipping network body because of body type', body);\n\n  return [undefined, 'UNPARSEABLE_BODY_TYPE'];\n}\n\nfunction _getBodySize(\n  body: XMLHttpRequest['response'],\n  responseType: XMLHttpRequest['responseType'],\n): number | undefined {\n  try {\n    const bodyStr = responseType === 'json' && body && typeof body === 'object' ? JSON.stringify(body) : body;\n    return getBodySize(bodyStr);\n  } catch {\n    return undefined;\n  }\n}\n","import type { FetchHint, XhrHint } from '@sentry-internal/browser-utils';\nimport { getClient } from '@sentry/core';\nimport type { Breadcrumb, BreadcrumbHint, FetchBreadcrumbData, XhrBreadcrumbData } from '@sentry/core';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { ReplayContainer, ReplayNetworkOptions } from '../types';\nimport { logger } from '../util/logger';\nimport { captureFetchBreadcrumbToReplay, enrichFetchBreadcrumb } from './util/fetchUtils';\nimport { captureXhrBreadcrumbToReplay, enrichXhrBreadcrumb } from './util/xhrUtils';\n\ninterface ExtendedNetworkBreadcrumbsOptions extends ReplayNetworkOptions {\n  replay: ReplayContainer;\n}\n\n/**\n * This method does two things:\n * - It enriches the regular XHR/fetch breadcrumbs with request/response size data\n * - It captures the XHR/fetch breadcrumbs to the replay\n *   (enriching it with further data that is _not_ added to the regular breadcrumbs)\n */\nexport function handleNetworkBreadcrumbs(replay: ReplayContainer): void {\n  const client = getClient();\n\n  try {\n    const {\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders,\n    } = replay.getOptions();\n\n    const options: ExtendedNetworkBreadcrumbsOptions = {\n      replay,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders,\n    };\n\n    if (client) {\n      client.on('beforeAddBreadcrumb', (breadcrumb, hint) => beforeAddNetworkBreadcrumb(options, breadcrumb, hint));\n    }\n  } catch {\n    // Do nothing\n  }\n}\n\n/** just exported for tests */\nexport function beforeAddNetworkBreadcrumb(\n  options: ExtendedNetworkBreadcrumbsOptions,\n  breadcrumb: Breadcrumb,\n  hint?: BreadcrumbHint,\n): void {\n  if (!breadcrumb.data) {\n    return;\n  }\n\n  try {\n    if (_isXhrBreadcrumb(breadcrumb) && _isXhrHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichXhrBreadcrumb(breadcrumb, hint);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureXhrBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n\n    if (_isFetchBreadcrumb(breadcrumb) && _isFetchHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichFetchBreadcrumb(breadcrumb, hint);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureFetchBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n  } catch (e) {\n    DEBUG_BUILD && logger.exception(e, 'Error when enriching network breadcrumb');\n  }\n}\n\nfunction _isXhrBreadcrumb(breadcrumb: Breadcrumb): breadcrumb is Breadcrumb & { data: XhrBreadcrumbData } {\n  return breadcrumb.category === 'xhr';\n}\n\nfunction _isFetchBreadcrumb(breadcrumb: Breadcrumb): breadcrumb is Breadcrumb & { data: FetchBreadcrumbData } {\n  return breadcrumb.category === 'fetch';\n}\n\nfunction _isXhrHint(hint?: BreadcrumbHint): hint is XhrHint {\n  return hint?.xhr;\n}\n\nfunction _isFetchHint(hint?: BreadcrumbHint): hint is FetchHint {\n  return hint?.response;\n}\n","import {\n  addClickKeypressInstrumentationHandler,\n  addHistoryInstrumentationHandler,\n} from '@sentry-internal/browser-utils';\nimport { addEventProcessor, getClient } from '@sentry/core';\nimport type { DynamicSamplingContext } from '@sentry/core';\n\nimport { handleAfterSendEvent } from '../coreHandlers/handleAfterSendEvent';\nimport { handleBeforeSendEvent } from '../coreHandlers/handleBeforeSendEvent';\nimport { handleBreadcrumbs } from '../coreHandlers/handleBreadcrumbs';\nimport { handleDomListener } from '../coreHandlers/handleDom';\nimport { handleGlobalEventListener } from '../coreHandlers/handleGlobalEvent';\nimport { handleHistorySpanListener } from '../coreHandlers/handleHistory';\nimport { handleNetworkBreadcrumbs } from '../coreHandlers/handleNetworkBreadcrumbs';\nimport type { ReplayContainer } from '../types';\n\n/**\n * Add global listeners that cannot be removed.\n */\nexport function addGlobalListeners(\n  replay: ReplayContainer,\n  { autoFlushOnFeedback }: { autoFlushOnFeedback?: boolean },\n): void {\n  // Listeners from core SDK //\n  const client = getClient();\n\n  addClickKeypressInstrumentationHandler(handleDomListener(replay));\n  addHistoryInstrumentationHandler(handleHistorySpanListener(replay));\n  handleBreadcrumbs(replay);\n  handleNetworkBreadcrumbs(replay);\n\n  // Tag all (non replay) events that get sent to Sentry with the current\n  // replay ID so that we can reference them later in the UI\n  const eventProcessor = handleGlobalEventListener(replay);\n  addEventProcessor(eventProcessor);\n\n  // If a custom client has no hooks yet, we continue to use the \"old\" implementation\n  if (client) {\n    client.on('beforeSendEvent', handleBeforeSendEvent(replay));\n    client.on('afterSendEvent', handleAfterSendEvent(replay));\n    client.on('createDsc', (dsc: DynamicSamplingContext) => {\n      const replayId = replay.getSessionId();\n      // We do not want to set the DSC when in buffer mode, as that means the replay has not been sent (yet)\n      if (replayId && replay.isEnabled() && replay.recordingMode === 'session') {\n        // Ensure to check that the session is still active - it could have expired in the meanwhile\n        const isSessionActive = replay.checkAndHandleExpiredSession();\n        if (isSessionActive) {\n          dsc.replay_id = replayId;\n        }\n      }\n    });\n\n    client.on('spanStart', span => {\n      replay.lastActiveSpan = span;\n    });\n\n    // We may be missing the initial spanStart due to timing issues,\n    // so we capture it on finish again.\n    client.on('spanEnd', span => {\n      replay.lastActiveSpan = span;\n    });\n\n    // We want to attach the replay id to the feedback event\n    client.on('beforeSendFeedback', async (feedbackEvent, options) => {\n      const replayId = replay.getSessionId();\n      if (options?.includeReplay && replay.isEnabled() && replayId && feedbackEvent.contexts?.feedback) {\n        // In case the feedback is sent via API and not through our widget, we want to flush replay\n        if (feedbackEvent.contexts.feedback.source === 'api' && autoFlushOnFeedback) {\n          await replay.flush();\n        }\n        feedbackEvent.contexts.feedback.replay_id = replayId;\n      }\n    });\n\n    if (autoFlushOnFeedback) {\n      client.on('openFeedbackWidget', async () => {\n        await replay.flush();\n      });\n    }\n  }\n}\n","import { WINDOW } from '../constants';\nimport type { AddEventResult, MemoryData, ReplayContainer, ReplayPerformanceEntry } from '../types';\nimport { createPerformanceSpans } from './createPerformanceSpans';\n\ntype ReplayMemoryEntry = ReplayPerformanceEntry<MemoryData> & { data: { memory: MemoryInfo } };\n\ninterface MemoryInfo {\n  jsHeapSizeLimit: number;\n  totalJSHeapSize: number;\n  usedJSHeapSize: number;\n}\n\n/**\n * Create a \"span\" for the total amount of memory being used by JS objects\n * (including v8 internal objects).\n */\nexport async function addMemoryEntry(replay: ReplayContainer): Promise<Array<AddEventResult | null>> {\n  // window.performance.memory is a non-standard API and doesn't work on all browsers, so we try-catch this\n  try {\n    return Promise.all(\n      createPerformanceSpans(replay, [\n        // @ts-expect-error memory doesn't exist on type Performance as the API is non-standard (we check that it exists above)\n        createMemoryEntry(WINDOW.performance.memory),\n      ]),\n    );\n  } catch (error) {\n    // Do nothing\n    return [];\n  }\n}\n\nfunction createMemoryEntry(memoryEntry: MemoryInfo): ReplayMemoryEntry {\n  const { jsHeapSizeLimit, totalJSHeapSize, usedJSHeapSize } = memoryEntry;\n  // we don't want to use `getAbsoluteTime` because it adds the event time to the\n  // time origin, so we get the current timestamp instead\n  const time = Date.now() / 1000;\n  return {\n    type: 'memory',\n    name: 'memory',\n    start: time,\n    end: time,\n    data: {\n      memory: {\n        jsHeapSizeLimit,\n        totalJSHeapSize,\n        usedJSHeapSize,\n      },\n    },\n  };\n}\n","import { setTimeout } from '@sentry-internal/browser-utils';\n\ntype DebouncedCallback = {\n  (): void | unknown;\n  flush: () => void | unknown;\n  cancel: () => void;\n};\ntype CallbackFunction = () => unknown;\ntype DebounceOptions = { maxWait?: number };\n\n/**\n * Heavily simplified debounce function based on lodash.debounce.\n *\n * This function takes a callback function (@param fun) and delays its invocation\n * by @param wait milliseconds. Optionally, a maxWait can be specified in @param options,\n * which ensures that the callback is invoked at least once after the specified max. wait time.\n *\n * @param func the function whose invocation is to be debounced\n * @param wait the minimum time until the function is invoked after it was called once\n * @param options the options object, which can contain the `maxWait` property\n *\n * @returns the debounced version of the function, which needs to be called at least once to start the\n *          debouncing process. Subsequent calls will reset the debouncing timer and, in case @paramfunc\n *          was already invoked in the meantime, return @param func's return value.\n *          The debounced function has two additional properties:\n *          - `flush`: Invokes the debounced function immediately and returns its return value\n *          - `cancel`: Cancels the debouncing process and resets the debouncing timer\n */\nexport function debounce(func: CallbackFunction, wait: number, options?: DebounceOptions): DebouncedCallback {\n  let callbackReturnValue: unknown;\n\n  let timerId: ReturnType<typeof setTimeout> | undefined;\n  let maxTimerId: ReturnType<typeof setTimeout> | undefined;\n\n  const maxWait = options?.maxWait ? Math.max(options.maxWait, wait) : 0;\n\n  function invokeFunc(): unknown {\n    cancelTimers();\n    callbackReturnValue = func();\n    return callbackReturnValue;\n  }\n\n  function cancelTimers(): void {\n    timerId !== undefined && clearTimeout(timerId);\n    maxTimerId !== undefined && clearTimeout(maxTimerId);\n    timerId = maxTimerId = undefined;\n  }\n\n  function flush(): unknown {\n    if (timerId !== undefined || maxTimerId !== undefined) {\n      return invokeFunc();\n    }\n    return callbackReturnValue;\n  }\n\n  function debounced(): unknown {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout(invokeFunc, wait);\n\n    if (maxWait && maxTimerId === undefined) {\n      maxTimerId = setTimeout(invokeFunc, maxWait);\n    }\n\n    return callbackReturnValue;\n  }\n\n  debounced.cancel = cancelTimers;\n  debounced.flush = flush;\n  return debounced;\n}\n","import { GLOBAL_OBJ } from '@sentry/core';\n\nconst NAVIGATOR = GLOBAL_OBJ.navigator;\n\n/**\n *  Disable sampling mousemove events on iOS browsers as this can cause blocking the main thread\n *  https://github.com/getsentry/sentry-javascript/issues/14534\n */\nexport function getRecordingSamplingOptions(): Partial<{ sampling: { mousemove: boolean } }> {\n  if (\n    /iPhone|iPad|iPod/i.test(NAVIGATOR?.userAgent ?? '') ||\n    (/Macintosh/i.test(NAVIGATOR?.userAgent ?? '') && NAVIGATOR?.maxTouchPoints && NAVIGATOR?.maxTouchPoints > 1)\n  ) {\n    return {\n      sampling: {\n        mousemove: false,\n      },\n    };\n  }\n\n  return {};\n}\n","import { EventType } from '@sentry-internal/rrweb';\n\nimport { updateClickDetectorForRecordingEvent } from '../coreHandlers/handleClick';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { saveSession } from '../session/saveSession';\nimport type { RecordingEvent, ReplayContainer, ReplayOptionFrameEvent } from '../types';\nimport { addEventSync } from './addEvent';\nimport { logger } from './logger';\n\ntype RecordingEmitCallback = (event: RecordingEvent, isCheckout?: boolean) => void;\n\n/**\n * Handler for recording events.\n *\n * Adds to event buffer, and has varying flushing behaviors if the event was a checkout.\n */\nexport function getHandleRecordingEmit(replay: ReplayContainer): RecordingEmitCallback {\n  let hadFirstEvent = false;\n\n  return (event: RecordingEvent, _isCheckout?: boolean) => {\n    // If this is false, it means session is expired, create and a new session and wait for checkout\n    if (!replay.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && logger.warn('Received replay event after session expired.');\n\n      return;\n    }\n\n    // `_isCheckout` is only set when the checkout is due to `checkoutEveryNms`\n    // We also want to treat the first event as a checkout, so we handle this specifically here\n    const isCheckout = _isCheckout || !hadFirstEvent;\n    hadFirstEvent = true;\n\n    if (replay.clickDetector) {\n      updateClickDetectorForRecordingEvent(replay.clickDetector, event);\n    }\n\n    // The handler returns `true` if we do not want to trigger debounced flush, `false` if we want to debounce flush.\n    replay.addUpdate(() => {\n      // The session is always started immediately on pageload/init, but for\n      // error-only replays, it should reflect the most recent checkout\n      // when an error occurs. Clear any state that happens before this current\n      // checkout. This needs to happen before `addEvent()` which updates state\n      // dependent on this reset.\n      if (replay.recordingMode === 'buffer' && isCheckout) {\n        replay.setInitialState();\n      }\n\n      // If the event is not added (e.g. due to being paused, disabled, or out of the max replay duration),\n      // Skip all further steps\n      if (!addEventSync(replay, event, isCheckout)) {\n        // Return true to skip scheduling a debounced flush\n        return true;\n      }\n\n      // Different behavior for full snapshots (type=2), ignore other event types\n      // See https://github.com/rrweb-io/rrweb/blob/d8f9290ca496712aa1e7d472549480c4e7876594/packages/rrweb/src/types.ts#L16\n      if (!isCheckout) {\n        return false;\n      }\n\n      const session = replay.session;\n\n      // Additionally, create a meta event that will capture certain SDK settings.\n      // In order to handle buffer mode, this needs to either be done when we\n      // receive checkout events or at flush time. We have an experimental mode\n      // to perform multiple checkouts a session (the idea is to improve\n      // seeking during playback), so also only include if segmentId is 0\n      // (handled in `addSettingsEvent`).\n      //\n      // `isCheckout` is always true, but want to be explicit that it should\n      // only be added for checkouts\n      addSettingsEvent(replay, isCheckout);\n\n      // When in buffer mode, make sure we adjust the session started date to the current earliest event of the buffer\n      // this should usually be the timestamp of the checkout event, but to be safe...\n      if (replay.recordingMode === 'buffer' && session && replay.eventBuffer) {\n        const earliestEvent = replay.eventBuffer.getEarliestTimestamp();\n        if (earliestEvent) {\n          DEBUG_BUILD &&\n            logger.info(`Updating session start time to earliest event in buffer to ${new Date(earliestEvent)}`);\n\n          session.started = earliestEvent;\n\n          if (replay.getOptions().stickySession) {\n            saveSession(session);\n          }\n        }\n      }\n\n      // If there is a previousSessionId after a full snapshot occurs, then\n      // the replay session was started due to session expiration. The new session\n      // is started before triggering a new checkout and contains the id\n      // of the previous session. Do not immediately flush in this case\n      // to avoid capturing only the checkout and instead the replay will\n      // be captured if they perform any follow-up actions.\n      if (session?.previousSessionId) {\n        return true;\n      }\n\n      if (replay.recordingMode === 'session') {\n        // If the full snapshot is due to an initial load, we will not have\n        // a previous session ID. In this case, we want to buffer events\n        // for a set amount of time before flushing. This can help avoid\n        // capturing replays of users that immediately close the window.\n\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        void replay.flush();\n      }\n\n      return true;\n    });\n  };\n}\n\n/**\n * Exported for tests\n */\nexport function createOptionsEvent(replay: ReplayContainer): ReplayOptionFrameEvent {\n  const options = replay.getOptions();\n  return {\n    type: EventType.Custom,\n    timestamp: Date.now(),\n    data: {\n      tag: 'options',\n      payload: {\n        shouldRecordCanvas: replay.isRecordingCanvas(),\n        sessionSampleRate: options.sessionSampleRate,\n        errorSampleRate: options.errorSampleRate,\n        useCompressionOption: options.useCompression,\n        blockAllMedia: options.blockAllMedia,\n        maskAllText: options.maskAllText,\n        maskAllInputs: options.maskAllInputs,\n        useCompression: replay.eventBuffer ? replay.eventBuffer.type === 'worker' : false,\n        networkDetailHasUrls: options.networkDetailAllowUrls.length > 0,\n        networkCaptureBodies: options.networkCaptureBodies,\n        networkRequestHasHeaders: options.networkRequestHeaders.length > 0,\n        networkResponseHasHeaders: options.networkResponseHeaders.length > 0,\n      },\n    },\n  };\n}\n\n/**\n * Add a \"meta\" event that contains a simplified view on current configuration\n * options. This should only be included on the first segment of a recording.\n */\nfunction addSettingsEvent(replay: ReplayContainer, isCheckout?: boolean): void {\n  // Only need to add this event when sending the first segment\n  if (!isCheckout || !replay.session || replay.session.segmentId !== 0) {\n    return;\n  }\n\n  addEventSync(replay, createOptionsEvent(replay), false);\n}\n","import { createEnvelope, createEventEnvelopeHeaders, getSdkMetadataForEnvelopeHeader } from '@sentry/core';\nimport type { DsnComponents, ReplayEnvelope, ReplayEvent, ReplayRecordingData } from '@sentry/core';\n\n/**\n * Create a replay envelope ready to be sent.\n * This includes both the replay event, as well as the recording data.\n */\nexport function createReplayEnvelope(\n  replayEvent: ReplayEvent,\n  recordingData: ReplayRecordingData,\n  dsn: DsnComponents,\n  tunnel?: string,\n): ReplayEnvelope {\n  return createEnvelope<ReplayEnvelope>(\n    createEventEnvelopeHeaders(replayEvent, getSdkMetadataForEnvelopeHeader(replayEvent), tunnel, dsn),\n    [\n      [{ type: 'replay_event' }, replayEvent],\n      [\n        {\n          type: 'replay_recording',\n          // If string then we need to encode to UTF8, otherwise will have\n          // wrong size. TextEncoder has similar browser support to\n          // MutationObserver, although it does not accept IE11.\n          length:\n            typeof recordingData === 'string' ? new TextEncoder().encode(recordingData).length : recordingData.length,\n        },\n        recordingData,\n      ],\n    ],\n  );\n}\n","import type { ReplayRecordingData } from '@sentry/core';\n\n/**\n * Prepare the recording data ready to be sent.\n */\nexport function prepareRecordingData({\n  recordingData,\n  headers,\n}: {\n  recordingData: ReplayRecordingData;\n  headers: Record<string, unknown>;\n}): ReplayRecordingData {\n  let payloadWithSequence;\n\n  // XXX: newline is needed to separate sequence id from events\n  const replayHeaders = `${JSON.stringify(headers)}\n`;\n\n  if (typeof recordingData === 'string') {\n    payloadWithSequence = `${replayHeaders}${recordingData}`;\n  } else {\n    const enc = new TextEncoder();\n    // XXX: newline is needed to separate sequence id from events\n    const sequence = enc.encode(replayHeaders);\n    // Merge the two Uint8Arrays\n    payloadWithSequence = new Uint8Array(sequence.length + recordingData.length);\n    payloadWithSequence.set(sequence);\n    payloadWithSequence.set(recordingData, sequence.length);\n  }\n\n  return payloadWithSequence;\n}\n","import { getIsolationScope, prepareEvent } from '@sentry/core';\nimport type { Client, EventHint, ReplayEvent, Scope } from '@sentry/core';\n\n/**\n * Prepare a replay event & enrich it with the SDK metadata.\n */\nexport async function prepareReplayEvent({\n  client,\n  scope,\n  replayId: event_id,\n  event,\n}: {\n  client: Client;\n  scope: Scope;\n  replayId: string;\n  event: ReplayEvent;\n}): Promise<ReplayEvent | null> {\n  const integrations =\n    typeof client['_integrations'] === 'object' &&\n    client['_integrations'] !== null &&\n    !Array.isArray(client['_integrations'])\n      ? Object.keys(client['_integrations'])\n      : undefined;\n\n  const eventHint: EventHint = { event_id, integrations };\n\n  client.emit('preprocessEvent', event, eventHint);\n\n  const preparedEvent = (await prepareEvent(\n    client.getOptions(),\n    event,\n    eventHint,\n    scope,\n    client,\n    getIsolationScope(),\n  )) as ReplayEvent | null;\n\n  // If e.g. a global event processor returned null\n  if (!preparedEvent) {\n    return null;\n  }\n\n  client.emit('postprocessEvent', preparedEvent, eventHint);\n\n  // This normally happens in browser client \"_prepareEvent\"\n  // but since we do not use this private method from the client, but rather the plain import\n  // we need to do this manually.\n  preparedEvent.platform = preparedEvent.platform || 'javascript';\n\n  // extract the SDK name because `client._prepareEvent` doesn't add it to the event\n  const metadata = client.getSdkMetadata();\n  const { name, version } = metadata?.sdk || {};\n\n  preparedEvent.sdk = {\n    ...preparedEvent.sdk,\n    name: name || 'sentry.javascript.unknown',\n    version: version || '0.0.0',\n  };\n\n  return preparedEvent;\n}\n","import type { RateLimits, ReplayEvent, TransportMakeRequestResponse } from '@sentry/core';\nimport { getClient, getCurrentScope, isRateLimited, resolvedSyncPromise, updateRateLimits } from '@sentry/core';\nimport { REPLAY_EVENT_NAME, UNABLE_TO_SEND_REPLAY } from '../constants';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { SendReplayData } from '../types';\nimport { createReplayEnvelope } from './createReplayEnvelope';\nimport { logger } from './logger';\nimport { prepareRecordingData } from './prepareRecordingData';\nimport { prepareReplayEvent } from './prepareReplayEvent';\n\n/**\n * Send replay attachment using `fetch()`\n */\nexport async function sendReplayRequest({\n  recordingData,\n  replayId,\n  segmentId: segment_id,\n  eventContext,\n  timestamp,\n  session,\n}: SendReplayData): Promise<TransportMakeRequestResponse> {\n  const preparedRecordingData = prepareRecordingData({\n    recordingData,\n    headers: {\n      segment_id,\n    },\n  });\n\n  const { urls, errorIds, traceIds, initialTimestamp } = eventContext;\n\n  const client = getClient();\n  const scope = getCurrentScope();\n  const transport = client?.getTransport();\n  const dsn = client?.getDsn();\n\n  if (!client || !transport || !dsn || !session.sampled) {\n    return resolvedSyncPromise({});\n  }\n\n  const baseEvent: ReplayEvent = {\n    type: REPLAY_EVENT_NAME,\n    replay_start_timestamp: initialTimestamp / 1000,\n    timestamp: timestamp / 1000,\n    error_ids: errorIds,\n    trace_ids: traceIds,\n    urls,\n    replay_id: replayId,\n    segment_id,\n    replay_type: session.sampled,\n  };\n\n  const replayEvent = await prepareReplayEvent({ scope, client, replayId, event: baseEvent });\n\n  if (!replayEvent) {\n    // Taken from baseclient's `_processEvent` method, where this is handled for errors/transactions\n    client.recordDroppedEvent('event_processor', 'replay');\n    DEBUG_BUILD && logger.info('An event processor returned `null`, will not send event.');\n    return resolvedSyncPromise({});\n  }\n\n  /*\n  For reference, the fully built event looks something like this:\n  {\n      \"type\": \"replay_event\",\n      \"timestamp\": 1670837008.634,\n      \"error_ids\": [\n          \"errorId\"\n      ],\n      \"trace_ids\": [\n          \"traceId\"\n      ],\n      \"urls\": [\n          \"https://example.com\"\n      ],\n      \"replay_id\": \"eventId\",\n      \"segment_id\": 3,\n      \"replay_type\": \"error\",\n      \"platform\": \"javascript\",\n      \"event_id\": \"eventId\",\n      \"environment\": \"production\",\n      \"sdk\": {\n          \"integrations\": [\n              \"BrowserTracing\",\n              \"Replay\"\n          ],\n          \"name\": \"sentry.javascript.browser\",\n          \"version\": \"7.25.0\"\n      },\n      \"sdkProcessingMetadata\": {},\n      \"contexts\": {\n      },\n  }\n  */\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete replayEvent.sdkProcessingMetadata;\n\n  const envelope = createReplayEnvelope(replayEvent, preparedRecordingData, dsn, client.getOptions().tunnel);\n\n  let response: TransportMakeRequestResponse;\n\n  try {\n    response = await transport.send(envelope);\n  } catch (err) {\n    const error = new Error(UNABLE_TO_SEND_REPLAY);\n\n    try {\n      // In case browsers don't allow this property to be writable\n      // @ts-expect-error This needs lib es2022 and newer\n      error.cause = err;\n    } catch {\n      // nothing to do\n    }\n    throw error;\n  }\n\n  // If the status code is invalid, we want to immediately stop & not retry\n  if (typeof response.statusCode === 'number' && (response.statusCode < 200 || response.statusCode >= 300)) {\n    throw new TransportStatusCodeError(response.statusCode);\n  }\n\n  const rateLimits = updateRateLimits({}, response);\n  if (isRateLimited(rateLimits, 'replay')) {\n    throw new RateLimitError(rateLimits);\n  }\n\n  return response;\n}\n\n/**\n * This error indicates that the transport returned an invalid status code.\n */\nexport class TransportStatusCodeError extends Error {\n  public constructor(statusCode: number) {\n    super(`Transport returned status code ${statusCode}`);\n  }\n}\n\n/**\n * This error indicates that we hit a rate limit API error.\n */\nexport class RateLimitError extends Error {\n  public rateLimits: RateLimits;\n\n  public constructor(rateLimits: RateLimits) {\n    super('Rate limit hit');\n    this.rateLimits = rateLimits;\n  }\n}\n","import { setTimeout } from '@sentry-internal/browser-utils';\nimport { setContext } from '@sentry/core';\n\nimport { RETRY_BASE_INTERVAL, RETRY_MAX_COUNT, UNABLE_TO_SEND_REPLAY } from '../constants';\nimport type { SendReplayData } from '../types';\nimport { RateLimitError, TransportStatusCodeError, sendReplayRequest } from './sendReplayRequest';\n\n/**\n * Finalize and send the current replay event to Sentry\n */\nexport async function sendReplay(\n  replayData: SendReplayData,\n  retryConfig = {\n    count: 0,\n    interval: RETRY_BASE_INTERVAL,\n  },\n): Promise<unknown> {\n  const { recordingData, onError } = replayData;\n\n  // short circuit if there's no events to upload (this shouldn't happen as _runFlush makes this check)\n  if (!recordingData.length) {\n    return;\n  }\n\n  try {\n    await sendReplayRequest(replayData);\n    return true;\n  } catch (err) {\n    if (err instanceof TransportStatusCodeError || err instanceof RateLimitError) {\n      throw err;\n    }\n\n    // Capture error for every failed replay\n    setContext('Replays', {\n      _retryCount: retryConfig.count,\n    });\n\n    if (onError) {\n      onError(err);\n    }\n\n    // If an error happened here, it's likely that uploading the attachment\n    // failed, we'll can retry with the same events payload\n    if (retryConfig.count >= RETRY_MAX_COUNT) {\n      const error = new Error(`${UNABLE_TO_SEND_REPLAY} - max retries exceeded`);\n\n      try {\n        // In case browsers don't allow this property to be writable\n        // @ts-expect-error This needs lib es2022 and newer\n        error.cause = err;\n      } catch {\n        // nothing to do\n      }\n\n      throw error;\n    }\n\n    // will retry in intervals of 5, 10, 30\n    retryConfig.interval *= ++retryConfig.count;\n\n    return new Promise((resolve, reject) => {\n      setTimeout(async () => {\n        try {\n          await sendReplay(replayData, retryConfig);\n          resolve(true);\n        } catch (err) {\n          reject(err);\n        }\n      }, retryConfig.interval);\n    });\n  }\n}\n","export const THROTTLED = '__THROTTLED';\nexport const SKIPPED = '__SKIPPED';\n\n/**\n * Create a throttled function off a given function.\n * When calling the throttled function, it will call the original function only\n * if it hasn't been called more than `maxCount` times in the last `durationSeconds`.\n *\n * Returns `THROTTLED` if throttled for the first time, after that `SKIPPED`,\n * or else the return value of the original function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function throttle<T extends (...rest: any[]) => any>(\n  fn: T,\n  maxCount: number,\n  durationSeconds: number,\n): (...rest: Parameters<T>) => ReturnType<T> | typeof THROTTLED | typeof SKIPPED {\n  const counter = new Map<number, number>();\n\n  const _cleanup = (now: number): void => {\n    const threshold = now - durationSeconds;\n    counter.forEach((_value, key) => {\n      if (key < threshold) {\n        counter.delete(key);\n      }\n    });\n  };\n\n  const _getTotalCount = (): number => {\n    return [...counter.values()].reduce((a, b) => a + b, 0);\n  };\n\n  let isThrottled = false;\n\n  return (...rest: Parameters<T>): ReturnType<T> | typeof THROTTLED | typeof SKIPPED => {\n    // Date in second-precision, which we use as basis for the throttling\n    const now = Math.floor(Date.now() / 1000);\n\n    // First, make sure to delete any old entries\n    _cleanup(now);\n\n    // If already over limit, do nothing\n    if (_getTotalCount() >= maxCount) {\n      const wasThrottled = isThrottled;\n      isThrottled = true;\n      return wasThrottled ? SKIPPED : THROTTLED;\n    }\n\n    isThrottled = false;\n    const count = counter.get(now) || 0;\n    counter.set(now, count + 1);\n\n    return fn(...rest);\n  };\n}\n","/* eslint-disable max-lines */ // TODO: We might want to split this file up\nimport { EventType, record } from '@sentry-internal/rrweb';\nimport type { ReplayRecordingMode, Span } from '@sentry/core';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, getActiveSpan, getClient, getRootSpan, spanToJSON } from '@sentry/core';\nimport {\n  BUFFER_CHECKOUT_TIME,\n  SESSION_IDLE_EXPIRE_DURATION,\n  SESSION_IDLE_PAUSE_DURATION,\n  SLOW_CLICK_SCROLL_TIMEOUT,\n  SLOW_CLICK_THRESHOLD,\n  WINDOW,\n} from './constants';\nimport { ClickDetector } from './coreHandlers/handleClick';\nimport { handleKeyboardEvent } from './coreHandlers/handleKeyboardEvent';\nimport { setupPerformanceObserver } from './coreHandlers/performanceObserver';\nimport { DEBUG_BUILD } from './debug-build';\nimport { createEventBuffer } from './eventBuffer';\nimport { clearSession } from './session/clearSession';\nimport { loadOrCreateSession } from './session/loadOrCreateSession';\nimport { saveSession } from './session/saveSession';\nimport { shouldRefreshSession } from './session/shouldRefreshSession';\nimport type {\n  AddEventResult,\n  AddUpdateCallback,\n  AllPerformanceEntry,\n  AllPerformanceEntryData,\n  EventBuffer,\n  InternalEventContext,\n  PopEventContext,\n  RecordingEvent,\n  RecordingOptions,\n  ReplayBreadcrumbFrame,\n  ReplayCanvasIntegrationOptions,\n  ReplayContainer as ReplayContainerInterface,\n  ReplayPerformanceEntry,\n  ReplayPluginOptions,\n  SendBufferedReplayOptions,\n  Session,\n  SlowClickConfig,\n  Timeouts,\n} from './types';\nimport { ReplayEventTypeCustom } from './types';\nimport { addEvent, addEventSync } from './util/addEvent';\nimport { addGlobalListeners } from './util/addGlobalListeners';\nimport { addMemoryEntry } from './util/addMemoryEntry';\nimport { createBreadcrumb } from './util/createBreadcrumb';\nimport { createPerformanceEntries } from './util/createPerformanceEntries';\nimport { createPerformanceSpans } from './util/createPerformanceSpans';\nimport { debounce } from './util/debounce';\nimport { getRecordingSamplingOptions } from './util/getRecordingSamplingOptions';\nimport { getHandleRecordingEmit } from './util/handleRecordingEmit';\nimport { isExpired } from './util/isExpired';\nimport { isSessionExpired } from './util/isSessionExpired';\nimport { logger } from './util/logger';\nimport { resetReplayIdOnDynamicSamplingContext } from './util/resetReplayIdOnDynamicSamplingContext';\nimport { sendReplay } from './util/sendReplay';\nimport { RateLimitError } from './util/sendReplayRequest';\nimport type { SKIPPED } from './util/throttle';\nimport { THROTTLED, throttle } from './util/throttle';\n\n/**\n * The main replay container class, which holds all the state and methods for recording and sending replays.\n */\nexport class ReplayContainer implements ReplayContainerInterface {\n  public eventBuffer: EventBuffer | null;\n\n  public performanceEntries: AllPerformanceEntry[];\n\n  public replayPerformanceEntries: ReplayPerformanceEntry<AllPerformanceEntryData>[];\n\n  public session: Session | undefined;\n\n  public clickDetector: ClickDetector | undefined;\n\n  /**\n   * Recording can happen in one of two modes:\n   *   - session: Record the whole session, sending it continuously\n   *   - buffer: Always keep the last 60s of recording, requires:\n   *     - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n   *     - or calling `flush()` to send the replay\n   */\n  public recordingMode: ReplayRecordingMode;\n\n  /**\n   * The current or last active span.\n   * This is only available when performance is enabled.\n   */\n  public lastActiveSpan?: Span;\n\n  /**\n   * These are here so we can overwrite them in tests etc.\n   * @hidden\n   */\n  public readonly timeouts: Timeouts;\n\n  /** The replay has to be manually started, because no sample rate (neither session or error) was provided. */\n  private _requiresManualStart: boolean;\n\n  private _throttledAddEvent: (\n    event: RecordingEvent,\n    isCheckout?: boolean,\n  ) => typeof THROTTLED | typeof SKIPPED | Promise<AddEventResult | null>;\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n  private readonly _recordingOptions: RecordingOptions;\n\n  private readonly _options: ReplayPluginOptions;\n\n  private _performanceCleanupCallback?: () => void;\n\n  private _debouncedFlush: ReturnType<typeof debounce>;\n  private _flushLock: Promise<unknown> | undefined;\n\n  /**\n   * Timestamp of the last user activity. This lives across sessions.\n   */\n  private _lastActivity: number;\n\n  /**\n   * Is the integration currently active?\n   */\n  private _isEnabled: boolean;\n\n  /**\n   * Paused is a state where:\n   * - DOM Recording is not listening at all\n   * - Nothing will be added to event buffer (e.g. core SDK events)\n   */\n  private _isPaused: boolean;\n\n  /**\n   * Have we attached listeners to the core SDK?\n   * Note we have to track this as there is no way to remove instrumentation handlers.\n   */\n  private _hasInitializedCoreListeners: boolean;\n\n  /**\n   * Function to stop recording\n   */\n  private _stopRecording: ReturnType<typeof record> | undefined;\n\n  private _context: InternalEventContext;\n\n  /**\n   * Internal use for canvas recording options\n   */\n  private _canvas: ReplayCanvasIntegrationOptions | undefined;\n\n  /**\n   * Handle when visibility of the page content changes. Opening a new tab will\n   * cause the state to change to hidden because of content of current page will\n   * be hidden. Likewise, moving a different window to cover the contents of the\n   * page will also trigger a change to a hidden state.\n   */\n  private _handleVisibilityChange: () => void;\n\n  /**\n   * Handle when page is blurred\n   */\n  private _handleWindowBlur: () => void;\n\n  /**\n   * Handle when page is focused\n   */\n  private _handleWindowFocus: () => void;\n\n  /** Ensure page remains active when a key is pressed. */\n  private _handleKeyboardEvent: (event: KeyboardEvent) => void;\n\n  public constructor({\n    options,\n    recordingOptions,\n  }: {\n    options: ReplayPluginOptions;\n    recordingOptions: RecordingOptions;\n  }) {\n    this.eventBuffer = null;\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n    this.recordingMode = 'session';\n    this.timeouts = {\n      sessionIdlePause: SESSION_IDLE_PAUSE_DURATION,\n      sessionIdleExpire: SESSION_IDLE_EXPIRE_DURATION,\n    } as const;\n    this._lastActivity = Date.now();\n    this._isEnabled = false;\n    this._isPaused = false;\n    this._requiresManualStart = false;\n    this._hasInitializedCoreListeners = false;\n    this._context = {\n      errorIds: new Set(),\n      traceIds: new Set(),\n      urls: [],\n      initialTimestamp: Date.now(),\n      initialUrl: '',\n    };\n\n    this._recordingOptions = recordingOptions;\n    this._options = options;\n\n    this._debouncedFlush = debounce(() => this._flush(), this._options.flushMinDelay, {\n      maxWait: this._options.flushMaxDelay,\n    });\n\n    this._throttledAddEvent = throttle(\n      (event: RecordingEvent, isCheckout?: boolean) => addEvent(this, event, isCheckout),\n      // Max 300 events...\n      300,\n      // ... per 5s\n      5,\n    );\n\n    const { slowClickTimeout, slowClickIgnoreSelectors } = this.getOptions();\n\n    const slowClickConfig: SlowClickConfig | undefined = slowClickTimeout\n      ? {\n          threshold: Math.min(SLOW_CLICK_THRESHOLD, slowClickTimeout),\n          timeout: slowClickTimeout,\n          scrollTimeout: SLOW_CLICK_SCROLL_TIMEOUT,\n          ignoreSelector: slowClickIgnoreSelectors ? slowClickIgnoreSelectors.join(',') : '',\n        }\n      : undefined;\n\n    if (slowClickConfig) {\n      this.clickDetector = new ClickDetector(this, slowClickConfig);\n    }\n\n    // Configure replay logger w/ experimental options\n    if (DEBUG_BUILD) {\n      const experiments = options._experiments;\n      logger.setConfig({\n        captureExceptions: !!experiments.captureExceptions,\n        traceInternals: !!experiments.traceInternals,\n      });\n    }\n\n    // We set these handler properties as class properties, to make binding/unbinding them easier\n    this._handleVisibilityChange = () => {\n      if (WINDOW.document.visibilityState === 'visible') {\n        this._doChangeToForegroundTasks();\n      } else {\n        this._doChangeToBackgroundTasks();\n      }\n    };\n\n    /**\n     * Handle when page is blurred\n     */\n    this._handleWindowBlur = () => {\n      const breadcrumb = createBreadcrumb({\n        category: 'ui.blur',\n      });\n\n      // Do not count blur as a user action -- it's part of the process of them\n      // leaving the page\n      this._doChangeToBackgroundTasks(breadcrumb);\n    };\n\n    this._handleWindowFocus = () => {\n      const breadcrumb = createBreadcrumb({\n        category: 'ui.focus',\n      });\n\n      // Do not count focus as a user action -- instead wait until they focus and\n      // interactive with page\n      this._doChangeToForegroundTasks(breadcrumb);\n    };\n\n    /** Ensure page remains active when a key is pressed. */\n    this._handleKeyboardEvent = (event: KeyboardEvent) => {\n      handleKeyboardEvent(this, event);\n    };\n  }\n\n  /** Get the event context. */\n  public getContext(): InternalEventContext {\n    return this._context;\n  }\n\n  /** If recording is currently enabled. */\n  public isEnabled(): boolean {\n    return this._isEnabled;\n  }\n\n  /** If recording is currently paused. */\n  public isPaused(): boolean {\n    return this._isPaused;\n  }\n\n  /**\n   * Determine if canvas recording is enabled\n   */\n  public isRecordingCanvas(): boolean {\n    return Boolean(this._canvas);\n  }\n\n  /** Get the replay integration options. */\n  public getOptions(): ReplayPluginOptions {\n    return this._options;\n  }\n\n  /** A wrapper to conditionally capture exceptions. */\n  public handleException(error: unknown): void {\n    DEBUG_BUILD && logger.exception(error);\n    if (this._options.onError) {\n      this._options.onError(error);\n    }\n  }\n\n  /**\n   * Initializes the plugin based on sampling configuration. Should not be\n   * called outside of constructor.\n   */\n  public initializeSampling(previousSessionId?: string): void {\n    const { errorSampleRate, sessionSampleRate } = this._options;\n\n    // If neither sample rate is > 0, then do nothing - user will need to call one of\n    // `start()` or `startBuffering` themselves.\n    const requiresManualStart = errorSampleRate <= 0 && sessionSampleRate <= 0;\n\n    this._requiresManualStart = requiresManualStart;\n\n    if (requiresManualStart) {\n      return;\n    }\n\n    // Otherwise if there is _any_ sample rate set, try to load an existing\n    // session, or create a new one.\n    this._initializeSessionForSampling(previousSessionId);\n\n    if (!this.session) {\n      // This should not happen, something wrong has occurred\n      DEBUG_BUILD && logger.exception(new Error('Unable to initialize and create session'));\n      return;\n    }\n\n    if (this.session.sampled === false) {\n      // This should only occur if `errorSampleRate` is 0 and was unsampled for\n      // session-based replay. In this case there is nothing to do.\n      return;\n    }\n\n    // If segmentId > 0, it means we've previously already captured this session\n    // In this case, we still want to continue in `session` recording mode\n    this.recordingMode = this.session.sampled === 'buffer' && this.session.segmentId === 0 ? 'buffer' : 'session';\n\n    DEBUG_BUILD && logger.infoTick(`Starting replay in ${this.recordingMode} mode`);\n\n    this._initializeRecording();\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will log a message if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * _performanceObserver, Recording, Sentry SDK, etc)\n   */\n  public start(): void {\n    if (this._isEnabled && this.recordingMode === 'session') {\n      DEBUG_BUILD && logger.info('Recording is already in progress');\n      return;\n    }\n\n    if (this._isEnabled && this.recordingMode === 'buffer') {\n      DEBUG_BUILD && logger.info('Buffering is in progress, call `flush()` to save the replay');\n      return;\n    }\n\n    DEBUG_BUILD && logger.infoTick('Starting replay in session mode');\n\n    // Required as user activity is initially set in\n    // constructor, so if `start()` is called after\n    // session idle expiration, a replay will not be\n    // created due to an idle timeout.\n    this._updateUserActivity();\n\n    const session = loadOrCreateSession(\n      {\n        maxReplayDuration: this._options.maxReplayDuration,\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n      },\n      {\n        stickySession: this._options.stickySession,\n        // This is intentional: create a new session-based replay when calling `start()`\n        sessionSampleRate: 1,\n        allowBuffering: false,\n      },\n    );\n\n    this.session = session;\n\n    this._initializeRecording();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, an error occurs.\n   */\n  public startBuffering(): void {\n    if (this._isEnabled) {\n      DEBUG_BUILD && logger.info('Buffering is in progress, call `flush()` to save the replay');\n      return;\n    }\n\n    DEBUG_BUILD && logger.infoTick('Starting replay in buffer mode');\n\n    const session = loadOrCreateSession(\n      {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n      },\n      {\n        stickySession: this._options.stickySession,\n        sessionSampleRate: 0,\n        allowBuffering: true,\n      },\n    );\n\n    this.session = session;\n\n    this.recordingMode = 'buffer';\n    this._initializeRecording();\n  }\n\n  /**\n   * Start recording.\n   *\n   * Note that this will cause a new DOM checkout\n   */\n  public startRecording(): void {\n    try {\n      const canvasOptions = this._canvas;\n\n      this._stopRecording = record({\n        ...this._recordingOptions,\n        // When running in error sampling mode, we need to overwrite `checkoutEveryNms`\n        // Without this, it would record forever, until an error happens, which we don't want\n        // instead, we'll always keep the last 60 seconds of replay before an error happened\n        ...(this.recordingMode === 'buffer'\n          ? { checkoutEveryNms: BUFFER_CHECKOUT_TIME }\n          : // Otherwise, use experimental option w/ min checkout time of 6 minutes\n            // This is to improve playback seeking as there could potentially be\n            // less mutations to process in the worse cases.\n            //\n            // checkout by \"N\" events is probably ideal, but means we have less\n            // control about the number of checkouts we make (which generally\n            // increases replay size)\n            this._options._experiments.continuousCheckout && {\n              // Minimum checkout time is 6 minutes\n              checkoutEveryNms: Math.max(360_000, this._options._experiments.continuousCheckout),\n            }),\n        emit: getHandleRecordingEmit(this),\n        ...getRecordingSamplingOptions(),\n        onMutation: this._onMutationHandler.bind(this),\n        ...(canvasOptions\n          ? {\n              recordCanvas: canvasOptions.recordCanvas,\n              getCanvasManager: canvasOptions.getCanvasManager,\n              sampling: canvasOptions.sampling,\n              dataURLOptions: canvasOptions.dataURLOptions,\n            }\n          : {}),\n      });\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Stops the recording, if it was running.\n   *\n   * Returns true if it was previously stopped, or is now stopped,\n   * otherwise false.\n   */\n  public stopRecording(): boolean {\n    try {\n      if (this._stopRecording) {\n        this._stopRecording();\n        this._stopRecording = undefined;\n      }\n\n      return true;\n    } catch (err) {\n      this.handleException(err);\n      return false;\n    }\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n  public async stop({ forceFlush = false, reason }: { forceFlush?: boolean; reason?: string } = {}): Promise<void> {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    // We can't move `_isEnabled` after awaiting a flush, otherwise we can\n    // enter into an infinite loop when `stop()` is called while flushing.\n    this._isEnabled = false;\n\n    try {\n      DEBUG_BUILD && logger.info(`Stopping Replay${reason ? ` triggered by ${reason}` : ''}`);\n\n      resetReplayIdOnDynamicSamplingContext();\n\n      this._removeListeners();\n      this.stopRecording();\n\n      this._debouncedFlush.cancel();\n      // See comment above re: `_isEnabled`, we \"force\" a flush, ignoring the\n      // `_isEnabled` state of the plugin since it was disabled above.\n      if (forceFlush) {\n        await this._flush({ force: true });\n      }\n\n      // After flush, destroy event buffer\n      this.eventBuffer?.destroy();\n      this.eventBuffer = null;\n\n      // Clear session from session storage, note this means if a new session\n      // is started after, it will not have `previousSessionId`\n      clearSession(this);\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Pause some replay functionality. See comments for `_isPaused`.\n   * This differs from stop as this only stops DOM recording, it is\n   * not as thorough of a shutdown as `stop()`.\n   */\n  public pause(): void {\n    if (this._isPaused) {\n      return;\n    }\n\n    this._isPaused = true;\n    this.stopRecording();\n\n    DEBUG_BUILD && logger.info('Pausing replay');\n  }\n\n  /**\n   * Resumes recording, see notes for `pause().\n   *\n   * Note that calling `startRecording()` here will cause a\n   * new DOM checkout.`\n   */\n  public resume(): void {\n    if (!this._isPaused || !this._checkSession()) {\n      return;\n    }\n\n    this._isPaused = false;\n    this.startRecording();\n\n    DEBUG_BUILD && logger.info('Resuming replay');\n  }\n\n  /**\n   * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a \"session\"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n  public async sendBufferedReplayOrFlush({ continueRecording = true }: SendBufferedReplayOptions = {}): Promise<void> {\n    if (this.recordingMode === 'session') {\n      return this.flushImmediate();\n    }\n\n    const activityTime = Date.now();\n\n    DEBUG_BUILD && logger.info('Converting buffer to session');\n\n    // Allow flush to complete before resuming as a session recording, otherwise\n    // the checkout from `startRecording` may be included in the payload.\n    // Prefer to keep the error replay as a separate (and smaller) segment\n    // than the session replay.\n    await this.flushImmediate();\n\n    const hasStoppedRecording = this.stopRecording();\n\n    if (!continueRecording || !hasStoppedRecording) {\n      return;\n    }\n\n    // To avoid race conditions where this is called multiple times, we check here again that we are still buffering\n    if ((this.recordingMode as ReplayRecordingMode) === 'session') {\n      return;\n    }\n\n    // Re-start recording in session-mode\n    this.recordingMode = 'session';\n\n    // Once this session ends, we do not want to refresh it\n    if (this.session) {\n      this._updateUserActivity(activityTime);\n      this._updateSessionActivity(activityTime);\n      this._maybeSaveSession();\n    }\n\n    this.startRecording();\n  }\n\n  /**\n   * We want to batch uploads of replay events. Save events only if\n   * `<flushMinDelay>` milliseconds have elapsed since the last event\n   * *OR* if `<flushMaxDelay>` milliseconds have elapsed.\n   *\n   * Accepts a callback to perform side-effects and returns true to stop batch\n   * processing and hand back control to caller.\n   */\n  public addUpdate(cb: AddUpdateCallback): void {\n    // We need to always run `cb` (e.g. in the case of `this.recordingMode == 'buffer'`)\n    const cbResult = cb();\n\n    // If this option is turned on then we will only want to call `flush`\n    // explicitly\n    if (this.recordingMode === 'buffer') {\n      return;\n    }\n\n    // If callback is true, we do not want to continue with flushing -- the\n    // caller will need to handle it.\n    if (cbResult === true) {\n      return;\n    }\n\n    // addUpdate is called quite frequently - use _debouncedFlush so that it\n    // respects the flush delays and does not flush immediately\n    this._debouncedFlush();\n  }\n\n  /**\n   * Updates the user activity timestamp and resumes recording. This should be\n   * called in an event handler for a user action that we consider as the user\n   * being \"active\" (e.g. a mouse click).\n   */\n  public triggerUserActivity(): void {\n    this._updateUserActivity();\n\n    // This case means that recording was once stopped due to inactivity.\n    // Ensure that recording is resumed.\n    if (!this._stopRecording) {\n      // Create a new session, otherwise when the user action is flushed, it\n      // will get rejected due to an expired session.\n      if (!this._checkSession()) {\n        return;\n      }\n\n      // Note: This will cause a new DOM checkout\n      this.resume();\n      return;\n    }\n\n    // Otherwise... recording was never suspended, continue as normalish\n    this.checkAndHandleExpiredSession();\n\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Updates the user activity timestamp *without* resuming\n   * recording. Some user events (e.g. keydown) can be create\n   * low-value replays that only contain the keypress as a\n   * breadcrumb. Instead this would require other events to\n   * create a new replay after a session has expired.\n   */\n  public updateUserActivity(): void {\n    this._updateUserActivity();\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Only flush if `this.recordingMode === 'session'`\n   */\n  public conditionalFlush(): Promise<void> {\n    if (this.recordingMode === 'buffer') {\n      return Promise.resolve();\n    }\n\n    return this.flushImmediate();\n  }\n\n  /**\n   * Flush using debounce flush\n   */\n  public flush(): Promise<void> {\n    return this._debouncedFlush() as Promise<void>;\n  }\n\n  /**\n   * Always flush via `_debouncedFlush` so that we do not have flushes triggered\n   * from calling both `flush` and `_debouncedFlush`. Otherwise, there could be\n   * cases of multiple flushes happening closely together.\n   */\n  public flushImmediate(): Promise<void> {\n    this._debouncedFlush();\n    // `.flush` is provided by the debounced function, analogously to lodash.debounce\n    return this._debouncedFlush.flush() as Promise<void>;\n  }\n\n  /**\n   * Cancels queued up flushes.\n   */\n  public cancelFlush(): void {\n    this._debouncedFlush.cancel();\n  }\n\n  /** Get the current session (=replay) ID */\n  public getSessionId(): string | undefined {\n    return this.session?.id;\n  }\n\n  /**\n   * Checks if recording should be stopped due to user inactivity. Otherwise\n   * check if session is expired and create a new session if so. Triggers a new\n   * full snapshot on new session.\n   *\n   * Returns true if session is not expired, false otherwise.\n   * @hidden\n   */\n  public checkAndHandleExpiredSession(): boolean | void {\n    // Prevent starting a new session if the last user activity is older than\n    // SESSION_IDLE_PAUSE_DURATION. Otherwise non-user activity can trigger a new\n    // session+recording. This creates noisy replays that do not have much\n    // content in them.\n    if (\n      this._lastActivity &&\n      isExpired(this._lastActivity, this.timeouts.sessionIdlePause) &&\n      this.session &&\n      this.session.sampled === 'session'\n    ) {\n      // Pause recording only for session-based replays. Otherwise, resuming\n      // will create a new replay and will conflict with users who only choose\n      // to record error-based replays only. (e.g. the resumed replay will not\n      // contain a reference to an error)\n      this.pause();\n      return;\n    }\n\n    // --- There is recent user activity --- //\n    // This will create a new session if expired, based on expiry length\n    if (!this._checkSession()) {\n      // Check session handles the refreshing itself\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Capture some initial state that can change throughout the lifespan of the\n   * replay. This is required because otherwise they would be captured at the\n   * first flush.\n   */\n  public setInitialState(): void {\n    const urlPath = `${WINDOW.location.pathname}${WINDOW.location.hash}${WINDOW.location.search}`;\n    const url = `${WINDOW.location.origin}${urlPath}`;\n\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    // Reset _context as well\n    this._clearContext();\n\n    this._context.initialUrl = url;\n    this._context.initialTimestamp = Date.now();\n    this._context.urls.push(url);\n  }\n\n  /**\n   * Add a breadcrumb event, that may be throttled.\n   * If it was throttled, we add a custom breadcrumb to indicate that.\n   */\n  public throttledAddEvent(\n    event: RecordingEvent,\n    isCheckout?: boolean,\n  ): typeof THROTTLED | typeof SKIPPED | Promise<AddEventResult | null> {\n    const res = this._throttledAddEvent(event, isCheckout);\n\n    // If this is THROTTLED, it means we have throttled the event for the first time\n    // In this case, we want to add a breadcrumb indicating that something was skipped\n    if (res === THROTTLED) {\n      const breadcrumb = createBreadcrumb({\n        category: 'replay.throttled',\n      });\n\n      this.addUpdate(() => {\n        // Return `false` if the event _was_ added, as that means we schedule a flush\n        return !addEventSync(this, {\n          type: ReplayEventTypeCustom,\n          timestamp: breadcrumb.timestamp || 0,\n          data: {\n            tag: 'breadcrumb',\n            payload: breadcrumb,\n            metric: true,\n          },\n        });\n      });\n    }\n\n    return res;\n  }\n\n  /**\n   * This will get the parametrized route name of the current page.\n   * This is only available if performance is enabled, and if an instrumented router is used.\n   */\n  public getCurrentRoute(): string | undefined {\n    const lastActiveSpan = this.lastActiveSpan || getActiveSpan();\n    const lastRootSpan = lastActiveSpan && getRootSpan(lastActiveSpan);\n\n    const attributes = (lastRootSpan && spanToJSON(lastRootSpan).data) || {};\n    const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n    if (!lastRootSpan || !source || !['route', 'custom'].includes(source)) {\n      return undefined;\n    }\n\n    return spanToJSON(lastRootSpan).description;\n  }\n\n  /**\n   * Initialize and start all listeners to varying events (DOM,\n   * Performance Observer, Recording, Sentry SDK, etc)\n   */\n  private _initializeRecording(): void {\n    this.setInitialState();\n\n    // this method is generally called on page load or manually - in both cases\n    // we should treat it as an activity\n    this._updateSessionActivity();\n\n    this.eventBuffer = createEventBuffer({\n      useCompression: this._options.useCompression,\n      workerUrl: this._options.workerUrl,\n    });\n\n    this._removeListeners();\n    this._addListeners();\n\n    // Need to set as enabled before we start recording, as `record()` can trigger a flush with a new checkout\n    this._isEnabled = true;\n    this._isPaused = false;\n\n    this.startRecording();\n  }\n\n  /**\n   * Loads (or refreshes) the current session.\n   */\n  private _initializeSessionForSampling(previousSessionId?: string): void {\n    // Whenever there is _any_ error sample rate, we always allow buffering\n    // Because we decide on sampling when an error occurs, we need to buffer at all times if sampling for errors\n    const allowBuffering = this._options.errorSampleRate > 0;\n\n    const session = loadOrCreateSession(\n      {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n        previousSessionId,\n      },\n      {\n        stickySession: this._options.stickySession,\n        sessionSampleRate: this._options.sessionSampleRate,\n        allowBuffering,\n      },\n    );\n\n    this.session = session;\n  }\n\n  /**\n   * Checks and potentially refreshes the current session.\n   * Returns false if session is not recorded.\n   */\n  private _checkSession(): boolean {\n    // If there is no session yet, we do not want to refresh anything\n    // This should generally not happen, but to be safe....\n    if (!this.session) {\n      return false;\n    }\n\n    const currentSession = this.session;\n\n    if (\n      shouldRefreshSession(currentSession, {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n      })\n    ) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._refreshSession(currentSession);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Refresh a session with a new one.\n   * This stops the current session (without forcing a flush, as that would never work since we are expired),\n   * and then does a new sampling based on the refreshed session.\n   */\n  private async _refreshSession(session: Session): Promise<void> {\n    if (!this._isEnabled) {\n      return;\n    }\n    await this.stop({ reason: 'refresh session' });\n    this.initializeSampling(session.id);\n  }\n\n  /**\n   * Adds listeners to record events for the replay\n   */\n  private _addListeners(): void {\n    try {\n      WINDOW.document.addEventListener('visibilitychange', this._handleVisibilityChange);\n      WINDOW.addEventListener('blur', this._handleWindowBlur);\n      WINDOW.addEventListener('focus', this._handleWindowFocus);\n      WINDOW.addEventListener('keydown', this._handleKeyboardEvent);\n\n      if (this.clickDetector) {\n        this.clickDetector.addListeners();\n      }\n\n      // There is no way to remove these listeners, so ensure they are only added once\n      if (!this._hasInitializedCoreListeners) {\n        addGlobalListeners(this, { autoFlushOnFeedback: this._options._experiments.autoFlushOnFeedback });\n\n        this._hasInitializedCoreListeners = true;\n      }\n    } catch (err) {\n      this.handleException(err);\n    }\n\n    this._performanceCleanupCallback = setupPerformanceObserver(this);\n  }\n\n  /**\n   * Cleans up listeners that were created in `_addListeners`\n   */\n  private _removeListeners(): void {\n    try {\n      WINDOW.document.removeEventListener('visibilitychange', this._handleVisibilityChange);\n\n      WINDOW.removeEventListener('blur', this._handleWindowBlur);\n      WINDOW.removeEventListener('focus', this._handleWindowFocus);\n      WINDOW.removeEventListener('keydown', this._handleKeyboardEvent);\n\n      if (this.clickDetector) {\n        this.clickDetector.removeListeners();\n      }\n\n      if (this._performanceCleanupCallback) {\n        this._performanceCleanupCallback();\n      }\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Tasks to run when we consider a page to be hidden (via blurring and/or visibility)\n   */\n  private _doChangeToBackgroundTasks(breadcrumb?: ReplayBreadcrumbFrame): void {\n    if (!this.session) {\n      return;\n    }\n\n    const expired = isSessionExpired(this.session, {\n      maxReplayDuration: this._options.maxReplayDuration,\n      sessionIdleExpire: this.timeouts.sessionIdleExpire,\n    });\n\n    if (expired) {\n      return;\n    }\n\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Send replay when the page/tab becomes hidden. There is no reason to send\n    // replay if it becomes visible, since no actions we care about were done\n    // while it was hidden\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    void this.conditionalFlush();\n  }\n\n  /**\n   * Tasks to run when we consider a page to be visible (via focus and/or visibility)\n   */\n  private _doChangeToForegroundTasks(breadcrumb?: ReplayBreadcrumbFrame): void {\n    if (!this.session) {\n      return;\n    }\n\n    const isSessionActive = this.checkAndHandleExpiredSession();\n\n    if (!isSessionActive) {\n      // If the user has come back to the page within SESSION_IDLE_PAUSE_DURATION\n      // ms, we will re-use the existing session, otherwise create a new\n      // session\n      DEBUG_BUILD && logger.info('Document has become active, but session has expired');\n      return;\n    }\n\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n  }\n\n  /**\n   * Update user activity (across session lifespans)\n   */\n  private _updateUserActivity(_lastActivity: number = Date.now()): void {\n    this._lastActivity = _lastActivity;\n  }\n\n  /**\n   * Updates the session's last activity timestamp\n   */\n  private _updateSessionActivity(_lastActivity: number = Date.now()): void {\n    if (this.session) {\n      this.session.lastActivity = _lastActivity;\n      this._maybeSaveSession();\n    }\n  }\n\n  /**\n   * Helper to create (and buffer) a replay breadcrumb from a core SDK breadcrumb\n   */\n  private _createCustomBreadcrumb(breadcrumb: ReplayBreadcrumbFrame): void {\n    this.addUpdate(() => {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.throttledAddEvent({\n        type: EventType.Custom,\n        timestamp: breadcrumb.timestamp || 0,\n        data: {\n          tag: 'breadcrumb',\n          payload: breadcrumb,\n        },\n      });\n    });\n  }\n\n  /**\n   * Observed performance events are added to `this.performanceEntries`. These\n   * are included in the replay event before it is finished and sent to Sentry.\n   */\n  private _addPerformanceEntries(): Promise<Array<AddEventResult | null>> {\n    let performanceEntries = createPerformanceEntries(this.performanceEntries).concat(this.replayPerformanceEntries);\n\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    // If we are manually starting, we want to ensure we only include performance entries\n    // that are after the initial timestamp\n    // The reason for this is that we may have performance entries from the page load, but may decide to start\n    // the replay later on, in which case we do not want to include these entries.\n    // without this, manually started replays can have events long before the actual replay recording starts,\n    // which messes with the timeline etc.\n    if (this._requiresManualStart) {\n      const initialTimestampInSeconds = this._context.initialTimestamp / 1000;\n      performanceEntries = performanceEntries.filter(entry => entry.start >= initialTimestampInSeconds);\n    }\n\n    return Promise.all(createPerformanceSpans(this, performanceEntries));\n  }\n\n  /**\n   * Clear _context\n   */\n  private _clearContext(): void {\n    // XXX: `initialTimestamp` and `initialUrl` do not get cleared\n    this._context.errorIds.clear();\n    this._context.traceIds.clear();\n    this._context.urls = [];\n  }\n\n  /** Update the initial timestamp based on the buffer content. */\n  private _updateInitialTimestampFromEventBuffer(): void {\n    const { session, eventBuffer } = this;\n    // If replay was started manually (=no sample rate was given),\n    // We do not want to back-port the initial timestamp\n    if (!session || !eventBuffer || this._requiresManualStart) {\n      return;\n    }\n\n    // we only ever update this on the initial segment\n    if (session.segmentId) {\n      return;\n    }\n\n    const earliestEvent = eventBuffer.getEarliestTimestamp();\n    if (earliestEvent && earliestEvent < this._context.initialTimestamp) {\n      this._context.initialTimestamp = earliestEvent;\n    }\n  }\n\n  /**\n   * Return and clear _context\n   */\n  private _popEventContext(): PopEventContext {\n    const _context = {\n      initialTimestamp: this._context.initialTimestamp,\n      initialUrl: this._context.initialUrl,\n      errorIds: Array.from(this._context.errorIds),\n      traceIds: Array.from(this._context.traceIds),\n      urls: this._context.urls,\n    };\n\n    this._clearContext();\n\n    return _context;\n  }\n\n  /**\n   * Flushes replay event buffer to Sentry.\n   *\n   * Performance events are only added right before flushing - this is\n   * due to the buffered performance observer events.\n   *\n   * Should never be called directly, only by `flush`\n   */\n  private async _runFlush(): Promise<void> {\n    const replayId = this.getSessionId();\n\n    if (!this.session || !this.eventBuffer || !replayId) {\n      DEBUG_BUILD && logger.error('No session or eventBuffer found to flush.');\n      return;\n    }\n\n    await this._addPerformanceEntries();\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer?.hasEvents) {\n      return;\n    }\n\n    // Only attach memory event if eventBuffer is not empty\n    await addMemoryEntry(this);\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer) {\n      return;\n    }\n\n    // if this changed in the meanwhile, e.g. because the session was refreshed or similar, we abort here\n    if (replayId !== this.getSessionId()) {\n      return;\n    }\n\n    try {\n      // This uses the data from the eventBuffer, so we need to call this before `finish()\n      this._updateInitialTimestampFromEventBuffer();\n\n      const timestamp = Date.now();\n\n      // Check total duration again, to avoid sending outdated stuff\n      // We leave 30s wiggle room to accommodate late flushing etc.\n      // This _could_ happen when the browser is suspended during flushing, in which case we just want to stop\n      if (timestamp - this._context.initialTimestamp > this._options.maxReplayDuration + 30_000) {\n        throw new Error('Session is too long, not sending replay');\n      }\n\n      const eventContext = this._popEventContext();\n      // Always increment segmentId regardless of outcome of sending replay\n      const segmentId = this.session.segmentId++;\n      this._maybeSaveSession();\n\n      // Note this empties the event buffer regardless of outcome of sending replay\n      const recordingData = await this.eventBuffer.finish();\n\n      await sendReplay({\n        replayId,\n        recordingData,\n        segmentId,\n        eventContext,\n        session: this.session,\n        timestamp,\n        onError: err => this.handleException(err),\n      });\n    } catch (err) {\n      this.handleException(err);\n\n      // This means we retried 3 times and all of them failed,\n      // or we ran into a problem we don't want to retry, like rate limiting.\n      // In this case, we want to completely stop the replay - otherwise, we may get inconsistent segments\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({ reason: 'sendReplay' });\n\n      const client = getClient();\n\n      if (client) {\n        const dropReason = err instanceof RateLimitError ? 'ratelimit_backoff' : 'send_error';\n        client.recordDroppedEvent(dropReason, 'replay');\n      }\n    }\n  }\n\n  /**\n   * Flush recording data to Sentry. Creates a lock so that only a single flush\n   * can be active at a time. Do not call this directly.\n   */\n  private async _flush({\n    force = false,\n  }: {\n    /**\n     * If true, flush while ignoring the `_isEnabled` state of\n     * Replay integration. (By default, flush is noop if integration\n     * is stopped).\n     */\n    force?: boolean;\n  } = {}): Promise<void> {\n    if (!this._isEnabled && !force) {\n      // This can happen if e.g. the replay was stopped because of exceeding the retry limit\n      return;\n    }\n\n    if (!this.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && logger.error('Attempting to finish replay event after session expired.');\n      return;\n    }\n\n    if (!this.session) {\n      // should never happen, as we would have bailed out before\n      return;\n    }\n\n    const start = this.session.started;\n    const now = Date.now();\n    const duration = now - start;\n\n    // A flush is about to happen, cancel any queued flushes\n    this._debouncedFlush.cancel();\n\n    // If session is too short, or too long (allow some wiggle room over maxReplayDuration), do not send it\n    // This _should_ not happen, but it may happen if flush is triggered due to a page activity change or similar\n    const tooShort = duration < this._options.minReplayDuration;\n    const tooLong = duration > this._options.maxReplayDuration + 5_000;\n    if (tooShort || tooLong) {\n      DEBUG_BUILD &&\n        logger.info(\n          `Session duration (${Math.floor(duration / 1000)}s) is too ${\n            tooShort ? 'short' : 'long'\n          }, not sending replay.`,\n        );\n\n      if (tooShort) {\n        this._debouncedFlush();\n      }\n      return;\n    }\n\n    const eventBuffer = this.eventBuffer;\n    if (eventBuffer && this.session.segmentId === 0 && !eventBuffer.hasCheckout) {\n      DEBUG_BUILD && logger.info('Flushing initial segment without checkout.');\n      // TODO FN: Evaluate if we want to stop here, or remove this again?\n    }\n\n    const _flushInProgress = !!this._flushLock;\n\n    // this._flushLock acts as a lock so that future calls to `_flush()` will\n    // be blocked until current flush is finished (i.e. this promise resolves)\n    if (!this._flushLock) {\n      this._flushLock = this._runFlush();\n    }\n\n    try {\n      await this._flushLock;\n    } catch (err) {\n      this.handleException(err);\n    } finally {\n      this._flushLock = undefined;\n\n      if (_flushInProgress) {\n        // Wait for previous flush to finish, then call the debounced\n        // `_flush()`. It's possible there are other flush requests queued and\n        // waiting for it to resolve. We want to reduce all outstanding\n        // requests (as well as any new flush requests that occur within a\n        // second of the locked flush completing) into a single flush.\n        this._debouncedFlush();\n      }\n    }\n  }\n\n  /** Save the session, if it is sticky */\n  private _maybeSaveSession(): void {\n    if (this.session && this._options.stickySession) {\n      saveSession(this.session);\n    }\n  }\n\n  /** Handler for rrweb.record.onMutation */\n  private _onMutationHandler(mutations: unknown[]): boolean {\n    const count = mutations.length;\n\n    const mutationLimit = this._options.mutationLimit;\n    const mutationBreadcrumbLimit = this._options.mutationBreadcrumbLimit;\n    const overMutationLimit = mutationLimit && count > mutationLimit;\n\n    // Create a breadcrumb if a lot of mutations happen at the same time\n    // We can show this in the UI as an information with potential performance improvements\n    if (count > mutationBreadcrumbLimit || overMutationLimit) {\n      const breadcrumb = createBreadcrumb({\n        category: 'replay.mutations',\n        data: {\n          count,\n          limit: overMutationLimit,\n        },\n      });\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Stop replay if over the mutation limit\n    if (overMutationLimit) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({ reason: 'mutationLimit', forceFlush: this.recordingMode === 'session' });\n      return false;\n    }\n\n    // `true` means we use the regular mutation handling by rrweb\n    return true;\n  }\n}\n","import type { ReplayIntegrationPrivacyOptions } from '../types';\n\ntype GetPrivacyOptions = Required<Omit<ReplayIntegrationPrivacyOptions, 'maskFn'>>;\n\ninterface GetPrivacyReturn {\n  maskTextSelector: string;\n  unmaskTextSelector: string;\n  blockSelector: string;\n  unblockSelector: string;\n  ignoreSelector: string;\n\n  blockClass?: RegExp;\n  maskTextClass?: RegExp;\n}\n\nfunction getOption(selectors: string[], defaultSelectors: string[]): string {\n  return [\n    ...selectors,\n    // sentry defaults\n    ...defaultSelectors,\n  ].join(',');\n}\n\n/**\n * Returns privacy related configuration for use in rrweb\n */\nexport function getPrivacyOptions({ mask, unmask, block, unblock, ignore }: GetPrivacyOptions): GetPrivacyReturn {\n  const defaultBlockedElements = ['base', 'iframe[srcdoc]:not([src])'];\n\n  const maskSelector = getOption(mask, ['.sentry-mask', '[data-sentry-mask]']);\n  const unmaskSelector = getOption(unmask, []);\n\n  const options: GetPrivacyReturn = {\n    // We are making the decision to make text and input selectors the same\n    maskTextSelector: maskSelector,\n    unmaskTextSelector: unmaskSelector,\n\n    blockSelector: getOption(block, ['.sentry-block', '[data-sentry-block]', ...defaultBlockedElements]),\n    unblockSelector: getOption(unblock, []),\n    ignoreSelector: getOption(ignore, ['.sentry-ignore', '[data-sentry-ignore]', 'input[type=\"file\"]']),\n  };\n\n  return options;\n}\n","import type { getPrivacyOptions } from './getPrivacyOptions';\n\ninterface MaskAttributeParams {\n  maskAttributes: string[];\n  maskAllText: boolean;\n  privacyOptions: ReturnType<typeof getPrivacyOptions>;\n  key: string;\n  value: string;\n  el: HTMLElement;\n}\n\n/**\n * Masks an attribute if necessary, otherwise return attribute value as-is.\n */\nexport function maskAttribute({\n  el,\n  key,\n  maskAttributes,\n  maskAllText,\n  privacyOptions,\n  value,\n}: MaskAttributeParams): string {\n  // We only mask attributes if `maskAllText` is true\n  if (!maskAllText) {\n    return value;\n  }\n\n  // unmaskTextSelector takes precedence\n  if (privacyOptions.unmaskTextSelector && el.matches(privacyOptions.unmaskTextSelector)) {\n    return value;\n  }\n\n  if (\n    maskAttributes.includes(key) ||\n    // Need to mask `value` attribute for `<input>` if it's a button-like\n    // type\n    (key === 'value' && el.tagName === 'INPUT' && ['submit', 'button'].includes(el.getAttribute('type') || ''))\n  ) {\n    return value.replace(/[\\S]/g, '*');\n  }\n\n  return value;\n}\n","import type { BrowserClientReplayOptions, Client, Integration, IntegrationFn, ReplayRecordingMode } from '@sentry/core';\nimport { consoleSandbox, isBrowser, parseSampleRate } from '@sentry/core';\nimport {\n  DEFAULT_FLUSH_MAX_DELAY,\n  DEFAULT_FLUSH_MIN_DELAY,\n  MAX_REPLAY_DURATION,\n  MIN_REPLAY_DURATION,\n  MIN_REPLAY_DURATION_LIMIT,\n} from './constants';\nimport { ReplayContainer } from './replay';\nimport type {\n  InitialReplayPluginOptions,\n  RecordingOptions,\n  ReplayCanvasIntegrationOptions,\n  ReplayConfiguration,\n  ReplayPluginOptions,\n  SendBufferedReplayOptions,\n} from './types';\nimport { getPrivacyOptions } from './util/getPrivacyOptions';\nimport { maskAttribute } from './util/maskAttribute';\n\nconst MEDIA_SELECTORS =\n  'img,image,svg,video,object,picture,embed,map,audio,link[rel=\"icon\"],link[rel=\"apple-touch-icon\"]';\n\nconst DEFAULT_NETWORK_HEADERS = ['content-length', 'content-type', 'accept'];\n\nlet _initialized = false;\n\n/**\n * Sentry integration for [Session Replay](https://sentry.io/for/session-replay/).\n *\n * See the [Replay documentation](https://docs.sentry.io/platforms/javascript/guides/session-replay/) for more information.\n *\n * @example\n *\n * ```\n * Sentry.init({\n *   dsn: '__DSN__',\n *   integrations: [Sentry.replayIntegration()],\n * });\n * ```\n */\nexport const replayIntegration = ((options?: ReplayConfiguration) => {\n  return new Replay(options);\n}) satisfies IntegrationFn;\n\n/**\n * Replay integration\n */\nexport class Replay implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public name: string;\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n  private readonly _recordingOptions: RecordingOptions;\n\n  /**\n   * Initial options passed to the replay integration, merged with default values.\n   * Note: `sessionSampleRate` and `errorSampleRate` are not required here, as they\n   * can only be finally set when setupOnce() is called.\n   *\n   * @private\n   */\n  private readonly _initialOptions: InitialReplayPluginOptions;\n\n  private _replay?: ReplayContainer;\n\n  public constructor({\n    flushMinDelay = DEFAULT_FLUSH_MIN_DELAY,\n    flushMaxDelay = DEFAULT_FLUSH_MAX_DELAY,\n    minReplayDuration = MIN_REPLAY_DURATION,\n    maxReplayDuration = MAX_REPLAY_DURATION,\n    stickySession = true,\n    useCompression = true,\n    workerUrl,\n    _experiments = {},\n    maskAllText = true,\n    maskAllInputs = true,\n    blockAllMedia = true,\n\n    mutationBreadcrumbLimit = 750,\n    mutationLimit = 10_000,\n\n    slowClickTimeout = 7_000,\n    slowClickIgnoreSelectors = [],\n\n    networkDetailAllowUrls = [],\n    networkDetailDenyUrls = [],\n    networkCaptureBodies = true,\n    networkRequestHeaders = [],\n    networkResponseHeaders = [],\n\n    mask = [],\n    maskAttributes = ['title', 'placeholder'],\n    unmask = [],\n    block = [],\n    unblock = [],\n    ignore = [],\n    maskFn,\n\n    beforeAddRecordingEvent,\n    beforeErrorSampling,\n    onError,\n  }: ReplayConfiguration = {}) {\n    this.name = 'Replay';\n\n    const privacyOptions = getPrivacyOptions({\n      mask,\n      unmask,\n      block,\n      unblock,\n      ignore,\n    });\n\n    this._recordingOptions = {\n      maskAllInputs,\n      maskAllText,\n      maskInputOptions: { password: true },\n      maskTextFn: maskFn,\n      maskInputFn: maskFn,\n      maskAttributeFn: (key: string, value: string, el: HTMLElement): string =>\n        maskAttribute({\n          maskAttributes,\n          maskAllText,\n          privacyOptions,\n          key,\n          value,\n          el,\n        }),\n\n      ...privacyOptions,\n\n      // Our defaults\n      slimDOMOptions: 'all',\n      inlineStylesheet: true,\n      // Disable inline images as it will increase segment/replay size\n      inlineImages: false,\n      // collect fonts, but be aware that `sentry.io` needs to be an allowed\n      // origin for playback\n      collectFonts: true,\n      errorHandler: (err: Error & { __rrweb__?: boolean }) => {\n        try {\n          err.__rrweb__ = true;\n        } catch (error) {\n          // ignore errors here\n          // this can happen if the error is frozen or does not allow mutation for other reasons\n        }\n      },\n      // experimental support for recording iframes from different origins\n      recordCrossOriginIframes: Boolean(_experiments.recordCrossOriginIframes),\n    };\n\n    this._initialOptions = {\n      flushMinDelay,\n      flushMaxDelay,\n      minReplayDuration: Math.min(minReplayDuration, MIN_REPLAY_DURATION_LIMIT),\n      maxReplayDuration: Math.min(maxReplayDuration, MAX_REPLAY_DURATION),\n      stickySession,\n      useCompression,\n      workerUrl,\n      blockAllMedia,\n      maskAllInputs,\n      maskAllText,\n      mutationBreadcrumbLimit,\n      mutationLimit,\n      slowClickTimeout,\n      slowClickIgnoreSelectors,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders: _getMergedNetworkHeaders(networkRequestHeaders),\n      networkResponseHeaders: _getMergedNetworkHeaders(networkResponseHeaders),\n      beforeAddRecordingEvent,\n      beforeErrorSampling,\n      onError,\n\n      _experiments,\n    };\n\n    if (this._initialOptions.blockAllMedia) {\n      // `blockAllMedia` is a more user friendly option to configure blocking\n      // embedded media elements\n      this._recordingOptions.blockSelector = !this._recordingOptions.blockSelector\n        ? MEDIA_SELECTORS\n        : `${this._recordingOptions.blockSelector},${MEDIA_SELECTORS}`;\n    }\n\n    if (this._isInitialized && isBrowser()) {\n      throw new Error('Multiple Sentry Session Replay instances are not supported');\n    }\n\n    this._isInitialized = true;\n  }\n\n  /** If replay has already been initialized */\n  protected get _isInitialized(): boolean {\n    return _initialized;\n  }\n\n  /** Update _isInitialized */\n  protected set _isInitialized(value: boolean) {\n    _initialized = value;\n  }\n\n  /**\n   * Setup and initialize replay container\n   */\n  public afterAllSetup(client: Client): void {\n    if (!isBrowser() || this._replay) {\n      return;\n    }\n\n    this._setup(client);\n    this._initialize(client);\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will log a message if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * PerformanceObserver, Recording, Sentry SDK, etc)\n   */\n  public start(): void {\n    if (!this._replay) {\n      return;\n    }\n    this._replay.start();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, until an error occurs.\n   */\n  public startBuffering(): void {\n    if (!this._replay) {\n      return;\n    }\n\n    this._replay.startBuffering();\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n  public stop(): Promise<void> {\n    if (!this._replay) {\n      return Promise.resolve();\n    }\n\n    return this._replay.stop({ forceFlush: this._replay.recordingMode === 'session' });\n  }\n\n  /**\n   * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n   * If replay is not enabled, a new session replay is started.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a \"session\"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n  public flush(options?: SendBufferedReplayOptions): Promise<void> {\n    if (!this._replay) {\n      return Promise.resolve();\n    }\n\n    // assuming a session should be recorded in this case\n    if (!this._replay.isEnabled()) {\n      this._replay.start();\n      return Promise.resolve();\n    }\n\n    return this._replay.sendBufferedReplayOrFlush(options);\n  }\n\n  /**\n   * Get the current session ID.\n   */\n  public getReplayId(): string | undefined {\n    if (!this._replay?.isEnabled()) {\n      return;\n    }\n\n    return this._replay.getSessionId();\n  }\n\n  /**\n   * Get the current recording mode. This can be either `session` or `buffer`.\n   *\n   * `session`: Recording the whole session, sending it continuously\n   * `buffer`: Always keeping the last 60s of recording, requires:\n   *   - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n   *   - or calling `flush()` to send the replay\n   */\n  public getRecordingMode(): ReplayRecordingMode | undefined {\n    if (!this._replay?.isEnabled()) {\n      return;\n    }\n\n    return this._replay.recordingMode;\n  }\n\n  /**\n   * Initializes replay.\n   */\n  protected _initialize(client: Client): void {\n    if (!this._replay) {\n      return;\n    }\n\n    this._maybeLoadFromReplayCanvasIntegration(client);\n    this._replay.initializeSampling();\n  }\n\n  /** Setup the integration. */\n  private _setup(client: Client): void {\n    // Client is not available in constructor, so we need to wait until setupOnce\n    const finalOptions = loadReplayOptionsFromClient(this._initialOptions, client);\n\n    this._replay = new ReplayContainer({\n      options: finalOptions,\n      recordingOptions: this._recordingOptions,\n    });\n  }\n\n  /** Get canvas options from ReplayCanvas integration, if it is also added. */\n  private _maybeLoadFromReplayCanvasIntegration(client: Client): void {\n    // To save bundle size, we skip checking for stuff here\n    // and instead just try-catch everything - as generally this should all be defined\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    try {\n      const canvasIntegration = client.getIntegrationByName('ReplayCanvas') as Integration & {\n        getOptions(): ReplayCanvasIntegrationOptions;\n      };\n      if (!canvasIntegration) {\n        return;\n      }\n\n      this._replay!['_canvas'] = canvasIntegration.getOptions();\n    } catch {\n      // ignore errors here\n    }\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n  }\n}\n\n/** Parse Replay-related options from SDK options */\nfunction loadReplayOptionsFromClient(initialOptions: InitialReplayPluginOptions, client: Client): ReplayPluginOptions {\n  const opt = client.getOptions() as BrowserClientReplayOptions;\n\n  const finalOptions: ReplayPluginOptions = {\n    sessionSampleRate: 0,\n    errorSampleRate: 0,\n    ...initialOptions,\n  };\n\n  const replaysSessionSampleRate = parseSampleRate(opt.replaysSessionSampleRate);\n  const replaysOnErrorSampleRate = parseSampleRate(opt.replaysOnErrorSampleRate);\n\n  if (replaysSessionSampleRate == null && replaysOnErrorSampleRate == null) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.',\n      );\n    });\n  }\n\n  if (replaysSessionSampleRate != null) {\n    finalOptions.sessionSampleRate = replaysSessionSampleRate;\n  }\n\n  if (replaysOnErrorSampleRate != null) {\n    finalOptions.errorSampleRate = replaysOnErrorSampleRate;\n  }\n\n  return finalOptions;\n}\n\nfunction _getMergedNetworkHeaders(headers: string[]): string[] {\n  return [...DEFAULT_NETWORK_HEADERS, ...headers.map(header => header.toLowerCase())];\n}\n","import { getClient } from '@sentry/core';\nimport type { replayIntegration } from '../integration';\n\n/**\n * This is a small utility to get a type-safe instance of the Replay integration.\n */\nexport function getReplay(): ReturnType<typeof replayIntegration> | undefined {\n  const client = getClient();\n  return client?.getIntegrationByName<ReturnType<typeof replayIntegration>>('Replay');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}