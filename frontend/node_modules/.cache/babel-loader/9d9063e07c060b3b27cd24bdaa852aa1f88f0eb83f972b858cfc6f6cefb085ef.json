{"ast":null,"code":"import { browserPerformanceTimeOrigin, spanToJSON, setMeasurement, getActiveSpan, parseUrl, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, htmlTreeAsString, getComponentName } from '@sentry/core';\nimport { WINDOW } from '../types.js';\nimport { trackClsAsStandaloneSpan } from './cls.js';\nimport { addPerformanceInstrumentationHandler, addFidInstrumentationHandler, addLcpInstrumentationHandler, addTtfbInstrumentationHandler, addClsInstrumentationHandler } from './instrument.js';\nimport { getBrowserPerformanceAPI, msToSec, startAndEndSpan, extractNetworkProtocol, isMeasurementValue } from './utils.js';\nimport { getActivationStart } from './web-vitals/lib/getActivationStart.js';\nimport { getNavigationEntry } from './web-vitals/lib/getNavigationEntry.js';\nimport { getVisibilityWatcher } from './web-vitals/lib/getVisibilityWatcher.js';\nconst MAX_INT_AS_BYTES = 2147483647;\nlet _performanceCursor = 0;\nlet _measurements = {};\nlet _lcpEntry;\nlet _clsEntry;\n\n/**\n * Start tracking web vitals.\n * The callback returned by this function can be used to stop tracking & ensure all measurements are final & captured.\n *\n * @returns A function that forces web vitals collection\n */\nfunction startTrackingWebVitals({\n  recordClsStandaloneSpans\n}) {\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin()) {\n    // @ts-expect-error we want to make sure all of these are available, even if TS is sure they are\n    if (performance.mark) {\n      WINDOW.performance.mark('sentry-tracing-init');\n    }\n    const fidCleanupCallback = _trackFID();\n    const lcpCleanupCallback = _trackLCP();\n    const ttfbCleanupCallback = _trackTtfb();\n    const clsCleanupCallback = recordClsStandaloneSpans ? trackClsAsStandaloneSpan() : _trackCLS();\n    return () => {\n      fidCleanupCallback();\n      lcpCleanupCallback();\n      ttfbCleanupCallback();\n      clsCleanupCallback?.();\n    };\n  }\n  return () => undefined;\n}\n\n/**\n * Start tracking long tasks.\n */\nfunction startTrackingLongTasks() {\n  addPerformanceInstrumentationHandler('longtask', ({\n    entries\n  }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    const {\n      op: parentOp,\n      start_timestamp: parentStartTimestamp\n    } = spanToJSON(parent);\n    for (const entry of entries) {\n      const startTime = msToSec(browserPerformanceTimeOrigin() + entry.startTime);\n      const duration = msToSec(entry.duration);\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding a span if the long task started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-task',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n        }\n      });\n    }\n  });\n}\n\n/**\n * Start tracking long animation frames.\n */\nfunction startTrackingLongAnimationFrames() {\n  // NOTE: the current web-vitals version (3.5.2) does not support long-animation-frame, so\n  // we directly observe `long-animation-frame` events instead of through the web-vitals\n  // `observe` helper function.\n  const observer = new PerformanceObserver(list => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of list.getEntries()) {\n      if (!entry.scripts[0]) {\n        continue;\n      }\n      const startTime = msToSec(browserPerformanceTimeOrigin() + entry.startTime);\n      const {\n        start_timestamp: parentStartTimestamp,\n        op: parentOp\n      } = spanToJSON(parent);\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding the span if the long animation frame started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n      const duration = msToSec(entry.duration);\n      const attributes = {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n      };\n      const initialScript = entry.scripts[0];\n      const {\n        invoker,\n        invokerType,\n        sourceURL,\n        sourceFunctionName,\n        sourceCharPosition\n      } = initialScript;\n      attributes['browser.script.invoker'] = invoker;\n      attributes['browser.script.invoker_type'] = invokerType;\n      if (sourceURL) {\n        attributes['code.filepath'] = sourceURL;\n      }\n      if (sourceFunctionName) {\n        attributes['code.function'] = sourceFunctionName;\n      }\n      if (sourceCharPosition !== -1) {\n        attributes['browser.script.source_char_position'] = sourceCharPosition;\n      }\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-animation-frame',\n        attributes\n      });\n    }\n  });\n  observer.observe({\n    type: 'long-animation-frame',\n    buffered: true\n  });\n}\n\n/**\n * Start tracking interaction events.\n */\nfunction startTrackingInteractions() {\n  addPerformanceInstrumentationHandler('event', ({\n    entries\n  }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of entries) {\n      if (entry.name === 'click') {\n        const startTime = msToSec(browserPerformanceTimeOrigin() + entry.startTime);\n        const duration = msToSec(entry.duration);\n        const spanOptions = {\n          name: htmlTreeAsString(entry.target),\n          op: `ui.interaction.${entry.name}`,\n          startTime: startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n          }\n        };\n        const componentName = getComponentName(entry.target);\n        if (componentName) {\n          spanOptions.attributes['ui.component_name'] = componentName;\n        }\n        startAndEndSpan(parent, startTime, startTime + duration, spanOptions);\n      }\n    }\n  });\n}\n\n/**\n * Starts tracking the Cumulative Layout Shift on the current page and collects the value and last entry\n * to the `_measurements` object which ultimately is applied to the pageload span's measurements.\n */\nfunction _trackCLS() {\n  return addClsInstrumentationHandler(({\n    metric\n  }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    _measurements['cls'] = {\n      value: metric.value,\n      unit: ''\n    };\n    _clsEntry = entry;\n  }, true);\n}\n\n/** Starts tracking the Largest Contentful Paint on the current page. */\nfunction _trackLCP() {\n  return addLcpInstrumentationHandler(({\n    metric\n  }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    _measurements['lcp'] = {\n      value: metric.value,\n      unit: 'millisecond'\n    };\n    _lcpEntry = entry;\n  }, true);\n}\n\n/** Starts tracking the First Input Delay on the current page. */\nfunction _trackFID() {\n  return addFidInstrumentationHandler(({\n    metric\n  }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin());\n    const startTime = msToSec(entry.startTime);\n    _measurements['fid'] = {\n      value: metric.value,\n      unit: 'millisecond'\n    };\n    _measurements['mark.fid'] = {\n      value: timeOrigin + startTime,\n      unit: 'second'\n    };\n  });\n}\nfunction _trackTtfb() {\n  return addTtfbInstrumentationHandler(({\n    metric\n  }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    _measurements['ttfb'] = {\n      value: metric.value,\n      unit: 'millisecond'\n    };\n  });\n}\n\n/** Add performance related spans to a transaction */\nfunction addPerformanceEntries(span, options) {\n  const performance = getBrowserPerformanceAPI();\n  const origin = browserPerformanceTimeOrigin();\n  if (!performance?.getEntries || !origin) {\n    // Gatekeeper if performance API not available\n    return;\n  }\n  const timeOrigin = msToSec(origin);\n  const performanceEntries = performance.getEntries();\n  const {\n    op,\n    start_timestamp: transactionStartTime\n  } = spanToJSON(span);\n  performanceEntries.slice(_performanceCursor).forEach(entry => {\n    const startTime = msToSec(entry.startTime);\n    const duration = msToSec(\n    // Inexplicably, Chrome sometimes emits a negative duration. We need to work around this.\n    // There is a SO post attempting to explain this, but it leaves one with open questions: https://stackoverflow.com/questions/23191918/peformance-getentries-and-negative-duration-display\n    // The way we clamp the value is probably not accurate, since we have observed this happen for things that may take a while to load, like for example the replay worker.\n    // TODO: Investigate why this happens and how to properly mitigate. For now, this is a workaround to prevent transactions being dropped due to negative duration spans.\n    Math.max(0, entry.duration));\n    if (op === 'navigation' && transactionStartTime && timeOrigin + startTime < transactionStartTime) {\n      return;\n    }\n    switch (entry.entryType) {\n      case 'navigation':\n        {\n          _addNavigationSpans(span, entry, timeOrigin);\n          break;\n        }\n      case 'mark':\n      case 'paint':\n      case 'measure':\n        {\n          _addMeasureSpans(span, entry, startTime, duration, timeOrigin);\n\n          // capture web vitals\n          const firstHidden = getVisibilityWatcher();\n          // Only report if the page wasn't hidden prior to the web vital.\n          const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n          if (entry.name === 'first-paint' && shouldRecord) {\n            _measurements['fp'] = {\n              value: entry.startTime,\n              unit: 'millisecond'\n            };\n          }\n          if (entry.name === 'first-contentful-paint' && shouldRecord) {\n            _measurements['fcp'] = {\n              value: entry.startTime,\n              unit: 'millisecond'\n            };\n          }\n          break;\n        }\n      case 'resource':\n        {\n          _addResourceSpans(span, entry, entry.name, startTime, duration, timeOrigin);\n          break;\n        }\n      // Ignore other entry types.\n    }\n  });\n  _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n  _trackNavigator(span);\n\n  // Measurements are only available for pageload transactions\n  if (op === 'pageload') {\n    _addTtfbRequestTimeToMeasurements(_measurements);\n    const fidMark = _measurements['mark.fid'];\n    if (fidMark && _measurements['fid']) {\n      // create span for FID\n      startAndEndSpan(span, fidMark.value, fidMark.value + msToSec(_measurements['fid'].value), {\n        name: 'first input delay',\n        op: 'ui.action',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n        }\n      });\n\n      // Delete mark.fid as we don't want it to be part of final payload\n      delete _measurements['mark.fid'];\n    }\n\n    // If FCP is not recorded we should not record the cls value\n    // according to the new definition of CLS.\n    // TODO: Check if the first condition is still necessary: `onCLS` already only fires once `onFCP` was called.\n    if (!('fcp' in _measurements) || !options.recordClsOnPageloadSpan) {\n      delete _measurements.cls;\n    }\n    Object.entries(_measurements).forEach(([measurementName, measurement]) => {\n      setMeasurement(measurementName, measurement.value, measurement.unit);\n    });\n\n    // Set timeOrigin which denotes the timestamp which to base the LCP/FCP/FP/TTFB measurements on\n    span.setAttribute('performance.timeOrigin', timeOrigin);\n\n    // In prerendering scenarios, where a page might be prefetched and pre-rendered before the user clicks the link,\n    // the navigation starts earlier than when the user clicks it. Web Vitals should always be based on the\n    // user-perceived time, so they are not reported from the actual start of the navigation, but rather from the\n    // time where the user actively started the navigation, for example by clicking a link.\n    // This is user action is called \"activation\" and the time between navigation and activation is stored in\n    // the `activationStart` attribute of the \"navigation\" PerformanceEntry.\n    span.setAttribute('performance.activationStart', getActivationStart());\n    _setWebVitalAttributes(span);\n  }\n  _lcpEntry = undefined;\n  _clsEntry = undefined;\n  _measurements = {};\n}\n\n/**\n * Create measure related spans.\n * Exported only for tests.\n */\nfunction _addMeasureSpans(span, entry, startTime, duration, timeOrigin) {\n  const navEntry = getNavigationEntry(false);\n  const requestTime = msToSec(navEntry ? navEntry.requestStart : 0);\n  // Because performance.measure accepts arbitrary timestamps it can produce\n  // spans that happen before the browser even makes a request for the page.\n  //\n  // An example of this is the automatically generated Next.js-before-hydration\n  // spans created by the Next.js framework.\n  //\n  // To prevent this we will pin the start timestamp to the request start time\n  // This does make duration inaccurate, so if this does happen, we will add\n  // an attribute to the span\n  const measureStartTimestamp = timeOrigin + Math.max(startTime, requestTime);\n  const startTimeStamp = timeOrigin + startTime;\n  const measureEndTimestamp = startTimeStamp + duration;\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics'\n  };\n  if (measureStartTimestamp !== startTimeStamp) {\n    attributes['sentry.browser.measure_happened_before_request'] = true;\n    attributes['sentry.browser.measure_start_time'] = measureStartTimestamp;\n  }\n\n  // Measurements from third parties can be off, which would create invalid spans, dropping transactions in the process.\n  if (measureStartTimestamp <= measureEndTimestamp) {\n    startAndEndSpan(span, measureStartTimestamp, measureEndTimestamp, {\n      name: entry.name,\n      op: entry.entryType,\n      attributes\n    });\n  }\n}\n\n/**\n * Instrument navigation entries\n * exported only for tests\n */\nfunction _addNavigationSpans(span, entry, timeOrigin) {\n  ['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'].forEach(event => {\n    _addPerformanceNavigationTiming(span, entry, event, timeOrigin);\n  });\n  _addPerformanceNavigationTiming(span, entry, 'secureConnection', timeOrigin, 'TLS/SSL');\n  _addPerformanceNavigationTiming(span, entry, 'fetch', timeOrigin, 'cache');\n  _addPerformanceNavigationTiming(span, entry, 'domainLookup', timeOrigin, 'DNS');\n  _addRequest(span, entry, timeOrigin);\n}\n\n/** Create performance navigation related spans */\nfunction _addPerformanceNavigationTiming(span, entry, event, timeOrigin, name = event) {\n  const eventEnd = _getEndPropertyNameForNavigationTiming(event);\n  const end = entry[eventEnd];\n  const start = entry[`${event}Start`];\n  if (!start || !end) {\n    return;\n  }\n  startAndEndSpan(span, timeOrigin + msToSec(start), timeOrigin + msToSec(end), {\n    op: `browser.${name}`,\n    name: entry.name,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      ...(event === 'redirect' && entry.redirectCount != null ? {\n        'http.redirect_count': entry.redirectCount\n      } : {})\n    }\n  });\n}\nfunction _getEndPropertyNameForNavigationTiming(event) {\n  if (event === 'secureConnection') {\n    return 'connectEnd';\n  }\n  if (event === 'fetch') {\n    return 'domainLookupStart';\n  }\n  return `${event}End`;\n}\n\n/** Create request and response related spans */\nfunction _addRequest(span, entry, timeOrigin) {\n  const requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);\n  const responseEndTimestamp = timeOrigin + msToSec(entry.responseEnd);\n  const responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);\n  if (entry.responseEnd) {\n    // It is possible that we are collecting these metrics when the page hasn't finished loading yet, for example when the HTML slowly streams in.\n    // In this case, ie. when the document request hasn't finished yet, `entry.responseEnd` will be 0.\n    // In order not to produce faulty spans, where the end timestamp is before the start timestamp, we will only collect\n    // these spans when the responseEnd value is available. The backend (Relay) would drop the entire span if it contained faulty spans.\n    startAndEndSpan(span, requestStartTimestamp, responseEndTimestamp, {\n      op: 'browser.request',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n      }\n    });\n    startAndEndSpan(span, responseStartTimestamp, responseEndTimestamp, {\n      op: 'browser.response',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n      }\n    });\n  }\n}\n\n/**\n * Create resource-related spans.\n * Exported only for tests.\n */\nfunction _addResourceSpans(span, entry, resourceUrl, startTime, duration, timeOrigin) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n  const parsedUrl = parseUrl(resourceUrl);\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics'\n  };\n  setResourceEntrySizeData(attributes, entry, 'transferSize', 'http.response_transfer_size');\n  setResourceEntrySizeData(attributes, entry, 'encodedBodySize', 'http.response_content_length');\n  setResourceEntrySizeData(attributes, entry, 'decodedBodySize', 'http.decoded_response_content_length');\n\n  // `deliveryType` is experimental and does not exist everywhere\n  const deliveryType = entry.deliveryType;\n  if (deliveryType != null) {\n    attributes['http.response_delivery_type'] = deliveryType;\n  }\n\n  // Types do not reflect this property yet\n  const renderBlockingStatus = entry.renderBlockingStatus;\n  if (renderBlockingStatus) {\n    attributes['resource.render_blocking_status'] = renderBlockingStatus;\n  }\n  if (parsedUrl.protocol) {\n    attributes['url.scheme'] = parsedUrl.protocol.split(':').pop(); // the protocol returned by parseUrl includes a :, but OTEL spec does not, so we remove it.\n  }\n  if (parsedUrl.host) {\n    attributes['server.address'] = parsedUrl.host;\n  }\n  attributes['url.same_origin'] = resourceUrl.includes(WINDOW.location.origin);\n  const {\n    name,\n    version\n  } = extractNetworkProtocol(entry.nextHopProtocol);\n  attributes['network.protocol.name'] = name;\n  attributes['network.protocol.version'] = version;\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n  startAndEndSpan(span, startTimestamp, endTimestamp, {\n    name: resourceUrl.replace(WINDOW.location.origin, ''),\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource.other',\n    attributes\n  });\n}\n\n/**\n * Capture the information of the user agent.\n */\nfunction _trackNavigator(span) {\n  const navigator = WINDOW.navigator;\n  if (!navigator) {\n    return;\n  }\n\n  // track network connectivity\n  const connection = navigator.connection;\n  if (connection) {\n    if (connection.effectiveType) {\n      span.setAttribute('effectiveConnectionType', connection.effectiveType);\n    }\n    if (connection.type) {\n      span.setAttribute('connectionType', connection.type);\n    }\n    if (isMeasurementValue(connection.rtt)) {\n      _measurements['connection.rtt'] = {\n        value: connection.rtt,\n        unit: 'millisecond'\n      };\n    }\n  }\n  if (isMeasurementValue(navigator.deviceMemory)) {\n    span.setAttribute('deviceMemory', `${navigator.deviceMemory} GB`);\n  }\n  if (isMeasurementValue(navigator.hardwareConcurrency)) {\n    span.setAttribute('hardwareConcurrency', String(navigator.hardwareConcurrency));\n  }\n}\n\n/** Add LCP / CLS data to span to allow debugging */\nfunction _setWebVitalAttributes(span) {\n  if (_lcpEntry) {\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (_lcpEntry.element) {\n      span.setAttribute('lcp.element', htmlTreeAsString(_lcpEntry.element));\n    }\n    if (_lcpEntry.id) {\n      span.setAttribute('lcp.id', _lcpEntry.id);\n    }\n    if (_lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      span.setAttribute('lcp.url', _lcpEntry.url.trim().slice(0, 200));\n    }\n    if (_lcpEntry.loadTime != null) {\n      // loadTime is the time of LCP that's related to receiving the LCP element response..\n      span.setAttribute('lcp.loadTime', _lcpEntry.loadTime);\n    }\n    if (_lcpEntry.renderTime != null) {\n      // renderTime is loadTime + rendering time\n      // it's 0 if the LCP element is loaded from a 3rd party origin that doesn't send the\n      // `Timing-Allow-Origin` header.\n      span.setAttribute('lcp.renderTime', _lcpEntry.renderTime);\n    }\n    span.setAttribute('lcp.size', _lcpEntry.size);\n  }\n\n  // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift\n  if (_clsEntry?.sources) {\n    _clsEntry.sources.forEach((source, index) => span.setAttribute(`cls.source.${index + 1}`, htmlTreeAsString(source.node)));\n  }\n}\nfunction setResourceEntrySizeData(attributes, entry, key, dataKey) {\n  const entryVal = entry[key];\n  if (entryVal != null && entryVal < MAX_INT_AS_BYTES) {\n    attributes[dataKey] = entryVal;\n  }\n}\n\n/**\n * Add ttfb request time information to measurements.\n *\n * ttfb information is added via vendored web vitals library.\n */\nfunction _addTtfbRequestTimeToMeasurements(_measurements) {\n  const navEntry = getNavigationEntry(false);\n  if (!navEntry) {\n    return;\n  }\n  const {\n    responseStart,\n    requestStart\n  } = navEntry;\n  if (requestStart <= responseStart) {\n    _measurements['ttfb.requestTime'] = {\n      value: responseStart - requestStart,\n      unit: 'millisecond'\n    };\n  }\n}\nexport { _addMeasureSpans, _addNavigationSpans, _addResourceSpans, addPerformanceEntries, startTrackingInteractions, startTrackingLongAnimationFrames, startTrackingLongTasks, startTrackingWebVitals };","map":{"version":3,"names":["MAX_INT_AS_BYTES","_performanceCursor","_measurements","_lcpEntry","_clsEntry","startTrackingWebVitals","recordClsStandaloneSpans","performance","getBrowserPerformanceAPI","browserPerformanceTimeOrigin","mark","WINDOW","fidCleanupCallback","_trackFID","lcpCleanupCallback","_trackLCP","ttfbCleanupCallback","_trackTtfb","clsCleanupCallback","trackClsAsStandaloneSpan","_trackCLS","undefined","startTrackingLongTasks","addPerformanceInstrumentationHandler","entries","parent","getActiveSpan","op","parentOp","start_timestamp","parentStartTimestamp","spanToJSON","entry","startTime","msToSec","duration","startAndEndSpan","name","attributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","startTrackingLongAnimationFrames","observer","PerformanceObserver","list","getEntries","scripts","initialScript","invoker","invokerType","sourceURL","sourceFunctionName","sourceCharPosition","observe","type","buffered","startTrackingInteractions","spanOptions","htmlTreeAsString","target","componentName","getComponentName","addClsInstrumentationHandler","metric","length","value","unit","addLcpInstrumentationHandler","addFidInstrumentationHandler","timeOrigin","addTtfbInstrumentationHandler","addPerformanceEntries","span","options","origin","performanceEntries","transactionStartTime","slice","forEach","Math","max","entryType","_addNavigationSpans","_addMeasureSpans","firstHidden","getVisibilityWatcher","shouldRecord","firstHiddenTime","_addResourceSpans","_trackNavigator","_addTtfbRequestTimeToMeasurements","fidMark","recordClsOnPageloadSpan","cls","Object","measurementName","measurement","setMeasurement","setAttribute","getActivationStart","_setWebVitalAttributes","navEntry","getNavigationEntry","requestTime","requestStart","measureStartTimestamp","startTimeStamp","measureEndTimestamp","event","_addPerformanceNavigationTiming","_addRequest","eventEnd","_getEndPropertyNameForNavigationTiming","end","start","redirectCount","requestStartTimestamp","responseEndTimestamp","responseEnd","responseStartTimestamp","responseStart","resourceUrl","initiatorType","parsedUrl","parseUrl","setResourceEntrySizeData","deliveryType","renderBlockingStatus","protocol","split","pop","host","includes","location","version","extractNetworkProtocol","nextHopProtocol","startTimestamp","endTimestamp","replace","navigator","connection","effectiveType","isMeasurementValue","rtt","deviceMemory","hardwareConcurrency","String","element","id","url","trim","loadTime","renderTime","size","sources","source","index","node","key","dataKey","entryVal"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\browser-utils\\src\\metrics\\browserMetrics.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { Measurements, Span, SpanAttributes, StartSpanOptions } from '@sentry/core';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  browserPerformanceTimeOrigin,\n  getActiveSpan,\n  getComponentName,\n  htmlTreeAsString,\n  parseUrl,\n  setMeasurement,\n  spanToJSON,\n} from '@sentry/core';\nimport { WINDOW } from '../types';\nimport { trackClsAsStandaloneSpan } from './cls';\nimport {\n  type PerformanceLongAnimationFrameTiming,\n  addClsInstrumentationHandler,\n  addFidInstrumentationHandler,\n  addLcpInstrumentationHandler,\n  addPerformanceInstrumentationHandler,\n  addTtfbInstrumentationHandler,\n} from './instrument';\nimport {\n  extractNetworkProtocol,\n  getBrowserPerformanceAPI,\n  isMeasurementValue,\n  msToSec,\n  startAndEndSpan,\n} from './utils';\nimport { getActivationStart } from './web-vitals/lib/getActivationStart';\nimport { getNavigationEntry } from './web-vitals/lib/getNavigationEntry';\nimport { getVisibilityWatcher } from './web-vitals/lib/getVisibilityWatcher';\n\ninterface NavigatorNetworkInformation {\n  readonly connection?: NetworkInformation;\n}\n\n// http://wicg.github.io/netinfo/#connection-types\ntype ConnectionType = 'bluetooth' | 'cellular' | 'ethernet' | 'mixed' | 'none' | 'other' | 'unknown' | 'wifi' | 'wimax';\n\n// http://wicg.github.io/netinfo/#effectiveconnectiontype-enum\ntype EffectiveConnectionType = '2g' | '3g' | '4g' | 'slow-2g';\n\n// http://wicg.github.io/netinfo/#dom-megabit\ntype Megabit = number;\n// http://wicg.github.io/netinfo/#dom-millisecond\ntype Millisecond = number;\n\n// http://wicg.github.io/netinfo/#networkinformation-interface\ninterface NetworkInformation extends EventTarget {\n  // http://wicg.github.io/netinfo/#type-attribute\n  readonly type?: ConnectionType;\n  // http://wicg.github.io/netinfo/#effectivetype-attribute\n  readonly effectiveType?: EffectiveConnectionType;\n  // http://wicg.github.io/netinfo/#downlinkmax-attribute\n  readonly downlinkMax?: Megabit;\n  // http://wicg.github.io/netinfo/#downlink-attribute\n  readonly downlink?: Megabit;\n  // http://wicg.github.io/netinfo/#rtt-attribute\n  readonly rtt?: Millisecond;\n  // http://wicg.github.io/netinfo/#savedata-attribute\n  readonly saveData?: boolean;\n  // http://wicg.github.io/netinfo/#handling-changes-to-the-underlying-connection\n  onchange?: EventListener;\n}\n\n// https://w3c.github.io/device-memory/#sec-device-memory-js-api\ninterface NavigatorDeviceMemory {\n  readonly deviceMemory?: number;\n}\n\nconst MAX_INT_AS_BYTES = 2147483647;\n\nlet _performanceCursor: number = 0;\n\nlet _measurements: Measurements = {};\nlet _lcpEntry: LargestContentfulPaint | undefined;\nlet _clsEntry: LayoutShift | undefined;\n\ninterface StartTrackingWebVitalsOptions {\n  recordClsStandaloneSpans: boolean;\n}\n\n/**\n * Start tracking web vitals.\n * The callback returned by this function can be used to stop tracking & ensure all measurements are final & captured.\n *\n * @returns A function that forces web vitals collection\n */\nexport function startTrackingWebVitals({ recordClsStandaloneSpans }: StartTrackingWebVitalsOptions): () => void {\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin()) {\n    // @ts-expect-error we want to make sure all of these are available, even if TS is sure they are\n    if (performance.mark) {\n      WINDOW.performance.mark('sentry-tracing-init');\n    }\n    const fidCleanupCallback = _trackFID();\n    const lcpCleanupCallback = _trackLCP();\n    const ttfbCleanupCallback = _trackTtfb();\n    const clsCleanupCallback = recordClsStandaloneSpans ? trackClsAsStandaloneSpan() : _trackCLS();\n\n    return (): void => {\n      fidCleanupCallback();\n      lcpCleanupCallback();\n      ttfbCleanupCallback();\n      clsCleanupCallback?.();\n    };\n  }\n\n  return () => undefined;\n}\n\n/**\n * Start tracking long tasks.\n */\nexport function startTrackingLongTasks(): void {\n  addPerformanceInstrumentationHandler('longtask', ({ entries }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n\n    const { op: parentOp, start_timestamp: parentStartTimestamp } = spanToJSON(parent);\n\n    for (const entry of entries) {\n      const startTime = msToSec((browserPerformanceTimeOrigin() as number) + entry.startTime);\n      const duration = msToSec(entry.duration);\n\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding a span if the long task started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-task',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n        },\n      });\n    }\n  });\n}\n\n/**\n * Start tracking long animation frames.\n */\nexport function startTrackingLongAnimationFrames(): void {\n  // NOTE: the current web-vitals version (3.5.2) does not support long-animation-frame, so\n  // we directly observe `long-animation-frame` events instead of through the web-vitals\n  // `observe` helper function.\n  const observer = new PerformanceObserver(list => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of list.getEntries() as PerformanceLongAnimationFrameTiming[]) {\n      if (!entry.scripts[0]) {\n        continue;\n      }\n\n      const startTime = msToSec((browserPerformanceTimeOrigin() as number) + entry.startTime);\n\n      const { start_timestamp: parentStartTimestamp, op: parentOp } = spanToJSON(parent);\n\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding the span if the long animation frame started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n      const duration = msToSec(entry.duration);\n\n      const attributes: SpanAttributes = {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      };\n\n      const initialScript = entry.scripts[0];\n      const { invoker, invokerType, sourceURL, sourceFunctionName, sourceCharPosition } = initialScript;\n      attributes['browser.script.invoker'] = invoker;\n      attributes['browser.script.invoker_type'] = invokerType;\n      if (sourceURL) {\n        attributes['code.filepath'] = sourceURL;\n      }\n      if (sourceFunctionName) {\n        attributes['code.function'] = sourceFunctionName;\n      }\n      if (sourceCharPosition !== -1) {\n        attributes['browser.script.source_char_position'] = sourceCharPosition;\n      }\n\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-animation-frame',\n        attributes,\n      });\n    }\n  });\n\n  observer.observe({ type: 'long-animation-frame', buffered: true });\n}\n\n/**\n * Start tracking interaction events.\n */\nexport function startTrackingInteractions(): void {\n  addPerformanceInstrumentationHandler('event', ({ entries }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of entries) {\n      if (entry.name === 'click') {\n        const startTime = msToSec((browserPerformanceTimeOrigin() as number) + entry.startTime);\n        const duration = msToSec(entry.duration);\n\n        const spanOptions: StartSpanOptions & Required<Pick<StartSpanOptions, 'attributes'>> = {\n          name: htmlTreeAsString(entry.target),\n          op: `ui.interaction.${entry.name}`,\n          startTime: startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n          },\n        };\n\n        const componentName = getComponentName(entry.target);\n        if (componentName) {\n          spanOptions.attributes['ui.component_name'] = componentName;\n        }\n\n        startAndEndSpan(parent, startTime, startTime + duration, spanOptions);\n      }\n    }\n  });\n}\n\nexport { registerInpInteractionListener, startTrackingINP } from './inp';\n\n/**\n * Starts tracking the Cumulative Layout Shift on the current page and collects the value and last entry\n * to the `_measurements` object which ultimately is applied to the pageload span's measurements.\n */\nfunction _trackCLS(): () => void {\n  return addClsInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1] as LayoutShift | undefined;\n    if (!entry) {\n      return;\n    }\n    _measurements['cls'] = { value: metric.value, unit: '' };\n    _clsEntry = entry;\n  }, true);\n}\n\n/** Starts tracking the Largest Contentful Paint on the current page. */\nfunction _trackLCP(): () => void {\n  return addLcpInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    _measurements['lcp'] = { value: metric.value, unit: 'millisecond' };\n    _lcpEntry = entry as LargestContentfulPaint;\n  }, true);\n}\n\n/** Starts tracking the First Input Delay on the current page. */\nfunction _trackFID(): () => void {\n  return addFidInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin() as number);\n    const startTime = msToSec(entry.startTime);\n    _measurements['fid'] = { value: metric.value, unit: 'millisecond' };\n    _measurements['mark.fid'] = { value: timeOrigin + startTime, unit: 'second' };\n  });\n}\n\nfunction _trackTtfb(): () => void {\n  return addTtfbInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    _measurements['ttfb'] = { value: metric.value, unit: 'millisecond' };\n  });\n}\n\ninterface AddPerformanceEntriesOptions {\n  /**\n   * Flag to determine if CLS should be recorded as a measurement on the span or\n   * sent as a standalone span instead.\n   */\n  recordClsOnPageloadSpan: boolean;\n}\n\n/** Add performance related spans to a transaction */\nexport function addPerformanceEntries(span: Span, options: AddPerformanceEntriesOptions): void {\n  const performance = getBrowserPerformanceAPI();\n  const origin = browserPerformanceTimeOrigin();\n  if (!performance?.getEntries || !origin) {\n    // Gatekeeper if performance API not available\n    return;\n  }\n\n  const timeOrigin = msToSec(origin);\n\n  const performanceEntries = performance.getEntries();\n\n  const { op, start_timestamp: transactionStartTime } = spanToJSON(span);\n\n  performanceEntries.slice(_performanceCursor).forEach(entry => {\n    const startTime = msToSec(entry.startTime);\n    const duration = msToSec(\n      // Inexplicably, Chrome sometimes emits a negative duration. We need to work around this.\n      // There is a SO post attempting to explain this, but it leaves one with open questions: https://stackoverflow.com/questions/23191918/peformance-getentries-and-negative-duration-display\n      // The way we clamp the value is probably not accurate, since we have observed this happen for things that may take a while to load, like for example the replay worker.\n      // TODO: Investigate why this happens and how to properly mitigate. For now, this is a workaround to prevent transactions being dropped due to negative duration spans.\n      Math.max(0, entry.duration),\n    );\n\n    if (op === 'navigation' && transactionStartTime && timeOrigin + startTime < transactionStartTime) {\n      return;\n    }\n\n    switch (entry.entryType) {\n      case 'navigation': {\n        _addNavigationSpans(span, entry as PerformanceNavigationTiming, timeOrigin);\n        break;\n      }\n      case 'mark':\n      case 'paint':\n      case 'measure': {\n        _addMeasureSpans(span, entry, startTime, duration, timeOrigin);\n\n        // capture web vitals\n        const firstHidden = getVisibilityWatcher();\n        // Only report if the page wasn't hidden prior to the web vital.\n        const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n\n        if (entry.name === 'first-paint' && shouldRecord) {\n          _measurements['fp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        if (entry.name === 'first-contentful-paint' && shouldRecord) {\n          _measurements['fcp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        break;\n      }\n      case 'resource': {\n        _addResourceSpans(span, entry as PerformanceResourceTiming, entry.name, startTime, duration, timeOrigin);\n        break;\n      }\n      // Ignore other entry types.\n    }\n  });\n\n  _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n\n  _trackNavigator(span);\n\n  // Measurements are only available for pageload transactions\n  if (op === 'pageload') {\n    _addTtfbRequestTimeToMeasurements(_measurements);\n\n    const fidMark = _measurements['mark.fid'];\n    if (fidMark && _measurements['fid']) {\n      // create span for FID\n      startAndEndSpan(span, fidMark.value, fidMark.value + msToSec(_measurements['fid'].value), {\n        name: 'first input delay',\n        op: 'ui.action',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n        },\n      });\n\n      // Delete mark.fid as we don't want it to be part of final payload\n      delete _measurements['mark.fid'];\n    }\n\n    // If FCP is not recorded we should not record the cls value\n    // according to the new definition of CLS.\n    // TODO: Check if the first condition is still necessary: `onCLS` already only fires once `onFCP` was called.\n    if (!('fcp' in _measurements) || !options.recordClsOnPageloadSpan) {\n      delete _measurements.cls;\n    }\n\n    Object.entries(_measurements).forEach(([measurementName, measurement]) => {\n      setMeasurement(measurementName, measurement.value, measurement.unit);\n    });\n\n    // Set timeOrigin which denotes the timestamp which to base the LCP/FCP/FP/TTFB measurements on\n    span.setAttribute('performance.timeOrigin', timeOrigin);\n\n    // In prerendering scenarios, where a page might be prefetched and pre-rendered before the user clicks the link,\n    // the navigation starts earlier than when the user clicks it. Web Vitals should always be based on the\n    // user-perceived time, so they are not reported from the actual start of the navigation, but rather from the\n    // time where the user actively started the navigation, for example by clicking a link.\n    // This is user action is called \"activation\" and the time between navigation and activation is stored in\n    // the `activationStart` attribute of the \"navigation\" PerformanceEntry.\n    span.setAttribute('performance.activationStart', getActivationStart());\n\n    _setWebVitalAttributes(span);\n  }\n\n  _lcpEntry = undefined;\n  _clsEntry = undefined;\n  _measurements = {};\n}\n\n/**\n * Create measure related spans.\n * Exported only for tests.\n */\nexport function _addMeasureSpans(\n  span: Span,\n  entry: PerformanceEntry,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): void {\n  const navEntry = getNavigationEntry(false);\n  const requestTime = msToSec(navEntry ? navEntry.requestStart : 0);\n  // Because performance.measure accepts arbitrary timestamps it can produce\n  // spans that happen before the browser even makes a request for the page.\n  //\n  // An example of this is the automatically generated Next.js-before-hydration\n  // spans created by the Next.js framework.\n  //\n  // To prevent this we will pin the start timestamp to the request start time\n  // This does make duration inaccurate, so if this does happen, we will add\n  // an attribute to the span\n  const measureStartTimestamp = timeOrigin + Math.max(startTime, requestTime);\n  const startTimeStamp = timeOrigin + startTime;\n  const measureEndTimestamp = startTimeStamp + duration;\n\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics',\n  };\n\n  if (measureStartTimestamp !== startTimeStamp) {\n    attributes['sentry.browser.measure_happened_before_request'] = true;\n    attributes['sentry.browser.measure_start_time'] = measureStartTimestamp;\n  }\n\n  // Measurements from third parties can be off, which would create invalid spans, dropping transactions in the process.\n  if (measureStartTimestamp <= measureEndTimestamp) {\n    startAndEndSpan(span, measureStartTimestamp, measureEndTimestamp, {\n      name: entry.name as string,\n      op: entry.entryType as string,\n      attributes,\n    });\n  }\n}\n\n/**\n * Instrument navigation entries\n * exported only for tests\n */\nexport function _addNavigationSpans(span: Span, entry: PerformanceNavigationTiming, timeOrigin: number): void {\n  (['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'] as const).forEach(event => {\n    _addPerformanceNavigationTiming(span, entry, event, timeOrigin);\n  });\n  _addPerformanceNavigationTiming(span, entry, 'secureConnection', timeOrigin, 'TLS/SSL');\n  _addPerformanceNavigationTiming(span, entry, 'fetch', timeOrigin, 'cache');\n  _addPerformanceNavigationTiming(span, entry, 'domainLookup', timeOrigin, 'DNS');\n\n  _addRequest(span, entry, timeOrigin);\n}\n\ntype StartEventName =\n  | 'secureConnection'\n  | 'fetch'\n  | 'domainLookup'\n  | 'unloadEvent'\n  | 'redirect'\n  | 'connect'\n  | 'domContentLoadedEvent'\n  | 'loadEvent';\n\ntype EndEventName =\n  | 'connectEnd'\n  | 'domainLookupStart'\n  | 'domainLookupEnd'\n  | 'unloadEventEnd'\n  | 'redirectEnd'\n  | 'connectEnd'\n  | 'domContentLoadedEventEnd'\n  | 'loadEventEnd';\n\n/** Create performance navigation related spans */\nfunction _addPerformanceNavigationTiming(\n  span: Span,\n  entry: PerformanceNavigationTiming,\n  event: StartEventName,\n  timeOrigin: number,\n  name: string = event,\n): void {\n  const eventEnd = _getEndPropertyNameForNavigationTiming(event) satisfies keyof PerformanceNavigationTiming;\n  const end = entry[eventEnd];\n  const start = entry[`${event}Start`];\n  if (!start || !end) {\n    return;\n  }\n  startAndEndSpan(span, timeOrigin + msToSec(start), timeOrigin + msToSec(end), {\n    op: `browser.${name}`,\n    name: entry.name,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      ...(event === 'redirect' && entry.redirectCount != null ? { 'http.redirect_count': entry.redirectCount } : {}),\n    },\n  });\n}\n\nfunction _getEndPropertyNameForNavigationTiming(event: StartEventName): EndEventName {\n  if (event === 'secureConnection') {\n    return 'connectEnd';\n  }\n  if (event === 'fetch') {\n    return 'domainLookupStart';\n  }\n  return `${event}End`;\n}\n\n/** Create request and response related spans */\nfunction _addRequest(span: Span, entry: PerformanceNavigationTiming, timeOrigin: number): void {\n  const requestStartTimestamp = timeOrigin + msToSec(entry.requestStart as number);\n  const responseEndTimestamp = timeOrigin + msToSec(entry.responseEnd as number);\n  const responseStartTimestamp = timeOrigin + msToSec(entry.responseStart as number);\n  if (entry.responseEnd) {\n    // It is possible that we are collecting these metrics when the page hasn't finished loading yet, for example when the HTML slowly streams in.\n    // In this case, ie. when the document request hasn't finished yet, `entry.responseEnd` will be 0.\n    // In order not to produce faulty spans, where the end timestamp is before the start timestamp, we will only collect\n    // these spans when the responseEnd value is available. The backend (Relay) would drop the entire span if it contained faulty spans.\n    startAndEndSpan(span, requestStartTimestamp, responseEndTimestamp, {\n      op: 'browser.request',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      },\n    });\n\n    startAndEndSpan(span, responseStartTimestamp, responseEndTimestamp, {\n      op: 'browser.response',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      },\n    });\n  }\n}\n\n/**\n * Create resource-related spans.\n * Exported only for tests.\n */\nexport function _addResourceSpans(\n  span: Span,\n  entry: PerformanceResourceTiming,\n  resourceUrl: string,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): void {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n\n  const parsedUrl = parseUrl(resourceUrl);\n\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics',\n  };\n  setResourceEntrySizeData(attributes, entry, 'transferSize', 'http.response_transfer_size');\n  setResourceEntrySizeData(attributes, entry, 'encodedBodySize', 'http.response_content_length');\n  setResourceEntrySizeData(attributes, entry, 'decodedBodySize', 'http.decoded_response_content_length');\n\n  // `deliveryType` is experimental and does not exist everywhere\n  const deliveryType = (entry as { deliveryType?: 'cache' | 'navigational-prefetch' | '' }).deliveryType;\n  if (deliveryType != null) {\n    attributes['http.response_delivery_type'] = deliveryType;\n  }\n\n  // Types do not reflect this property yet\n  const renderBlockingStatus = (entry as { renderBlockingStatus?: 'render-blocking' | 'non-render-blocking' })\n    .renderBlockingStatus;\n  if (renderBlockingStatus) {\n    attributes['resource.render_blocking_status'] = renderBlockingStatus;\n  }\n\n  if (parsedUrl.protocol) {\n    attributes['url.scheme'] = parsedUrl.protocol.split(':').pop(); // the protocol returned by parseUrl includes a :, but OTEL spec does not, so we remove it.\n  }\n\n  if (parsedUrl.host) {\n    attributes['server.address'] = parsedUrl.host;\n  }\n\n  attributes['url.same_origin'] = resourceUrl.includes(WINDOW.location.origin);\n\n  const { name, version } = extractNetworkProtocol(entry.nextHopProtocol);\n  attributes['network.protocol.name'] = name;\n  attributes['network.protocol.version'] = version;\n\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n\n  startAndEndSpan(span, startTimestamp, endTimestamp, {\n    name: resourceUrl.replace(WINDOW.location.origin, ''),\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource.other',\n    attributes,\n  });\n}\n\n/**\n * Capture the information of the user agent.\n */\nfunction _trackNavigator(span: Span): void {\n  const navigator = WINDOW.navigator as null | (Navigator & NavigatorNetworkInformation & NavigatorDeviceMemory);\n  if (!navigator) {\n    return;\n  }\n\n  // track network connectivity\n  const connection = navigator.connection;\n  if (connection) {\n    if (connection.effectiveType) {\n      span.setAttribute('effectiveConnectionType', connection.effectiveType);\n    }\n\n    if (connection.type) {\n      span.setAttribute('connectionType', connection.type);\n    }\n\n    if (isMeasurementValue(connection.rtt)) {\n      _measurements['connection.rtt'] = { value: connection.rtt, unit: 'millisecond' };\n    }\n  }\n\n  if (isMeasurementValue(navigator.deviceMemory)) {\n    span.setAttribute('deviceMemory', `${navigator.deviceMemory} GB`);\n  }\n\n  if (isMeasurementValue(navigator.hardwareConcurrency)) {\n    span.setAttribute('hardwareConcurrency', String(navigator.hardwareConcurrency));\n  }\n}\n\n/** Add LCP / CLS data to span to allow debugging */\nfunction _setWebVitalAttributes(span: Span): void {\n  if (_lcpEntry) {\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (_lcpEntry.element) {\n      span.setAttribute('lcp.element', htmlTreeAsString(_lcpEntry.element));\n    }\n\n    if (_lcpEntry.id) {\n      span.setAttribute('lcp.id', _lcpEntry.id);\n    }\n\n    if (_lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      span.setAttribute('lcp.url', _lcpEntry.url.trim().slice(0, 200));\n    }\n\n    if (_lcpEntry.loadTime != null) {\n      // loadTime is the time of LCP that's related to receiving the LCP element response..\n      span.setAttribute('lcp.loadTime', _lcpEntry.loadTime);\n    }\n\n    if (_lcpEntry.renderTime != null) {\n      // renderTime is loadTime + rendering time\n      // it's 0 if the LCP element is loaded from a 3rd party origin that doesn't send the\n      // `Timing-Allow-Origin` header.\n      span.setAttribute('lcp.renderTime', _lcpEntry.renderTime);\n    }\n\n    span.setAttribute('lcp.size', _lcpEntry.size);\n  }\n\n  // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift\n  if (_clsEntry?.sources) {\n    _clsEntry.sources.forEach((source, index) =>\n      span.setAttribute(`cls.source.${index + 1}`, htmlTreeAsString(source.node)),\n    );\n  }\n}\n\nfunction setResourceEntrySizeData(\n  attributes: SpanAttributes,\n  entry: PerformanceResourceTiming,\n  key: keyof Pick<PerformanceResourceTiming, 'transferSize' | 'encodedBodySize' | 'decodedBodySize'>,\n  dataKey: 'http.response_transfer_size' | 'http.response_content_length' | 'http.decoded_response_content_length',\n): void {\n  const entryVal = entry[key];\n  if (entryVal != null && entryVal < MAX_INT_AS_BYTES) {\n    attributes[dataKey] = entryVal;\n  }\n}\n\n/**\n * Add ttfb request time information to measurements.\n *\n * ttfb information is added via vendored web vitals library.\n */\nfunction _addTtfbRequestTimeToMeasurements(_measurements: Measurements): void {\n  const navEntry = getNavigationEntry(false);\n  if (!navEntry) {\n    return;\n  }\n\n  const { responseStart, requestStart } = navEntry;\n\n  if (requestStart <= responseStart) {\n    _measurements['ttfb.requestTime'] = {\n      value: responseStart - requestStart,\n      unit: 'millisecond',\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}