{"ast":null,"code":"import { getClient, getActiveSpan, getRootSpan, spanToJSON, logger, browserPerformanceTimeOrigin, getCurrentScope, htmlTreeAsString, SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME, SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE, SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { addClsInstrumentationHandler } from './instrument.js';\nimport { msToSec, startStandaloneWebVitalSpan } from './utils.js';\nimport { onHidden } from './web-vitals/lib/onHidden.js';\n\n/**\n * Starts tracking the Cumulative Layout Shift on the current page and collects the value once\n *\n * - the page visibility is hidden\n * - a navigation span is started (to stop CLS measurement for SPA soft navigations)\n *\n * Once either of these events triggers, the CLS value is sent as a standalone span and we stop\n * measuring CLS.\n */\nfunction trackClsAsStandaloneSpan() {\n  let standaloneCLsValue = 0;\n  let standaloneClsEntry;\n  let pageloadSpanId;\n  if (!supportsLayoutShift()) {\n    return;\n  }\n  let sentSpan = false;\n  function _collectClsOnce() {\n    if (sentSpan) {\n      return;\n    }\n    sentSpan = true;\n    if (pageloadSpanId) {\n      sendStandaloneClsSpan(standaloneCLsValue, standaloneClsEntry, pageloadSpanId);\n    }\n    cleanupClsHandler();\n  }\n  const cleanupClsHandler = addClsInstrumentationHandler(({\n    metric\n  }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    standaloneCLsValue = metric.value;\n    standaloneClsEntry = entry;\n  }, true);\n\n  // use pagehide event from web-vitals\n  onHidden(() => {\n    _collectClsOnce();\n  });\n\n  // Since the call chain of this function is synchronous and evaluates before the SDK client is created,\n  // we need to wait with subscribing to a client hook until the client is created. Therefore, we defer\n  // to the next tick after the SDK setup.\n  setTimeout(() => {\n    const client = getClient();\n    if (!client) {\n      return;\n    }\n    const unsubscribeStartNavigation = client.on('startNavigationSpan', () => {\n      _collectClsOnce();\n      unsubscribeStartNavigation?.();\n    });\n    const activeSpan = getActiveSpan();\n    if (activeSpan) {\n      const rootSpan = getRootSpan(activeSpan);\n      const spanJSON = spanToJSON(rootSpan);\n      if (spanJSON.op === 'pageload') {\n        pageloadSpanId = rootSpan.spanContext().spanId;\n      }\n    }\n  }, 0);\n}\nfunction sendStandaloneClsSpan(clsValue, entry, pageloadSpanId) {\n  DEBUG_BUILD && logger.log(`Sending CLS span (${clsValue})`);\n  const startTime = msToSec((browserPerformanceTimeOrigin() || 0) + (entry?.startTime || 0));\n  const routeName = getCurrentScope().getScopeData().transactionName;\n  const name = entry ? htmlTreeAsString(entry.sources[0]?.node) : 'Layout shift';\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser.cls',\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'ui.webvital.cls',\n    [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: entry?.duration || 0,\n    // attach the pageload span id to the CLS span so that we can link them in the UI\n    'sentry.pageload.span_id': pageloadSpanId\n  };\n  const span = startStandaloneWebVitalSpan({\n    name,\n    transaction: routeName,\n    attributes,\n    startTime\n  });\n  if (span) {\n    span.addEvent('cls', {\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: '',\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: clsValue\n    });\n\n    // LayoutShift performance entries always have a duration of 0, so we don't need to add `entry.duration` here\n    // see: https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/duration\n    span.end(startTime);\n  }\n}\nfunction supportsLayoutShift() {\n  try {\n    return PerformanceObserver.supportedEntryTypes.includes('layout-shift');\n  } catch {\n    return false;\n  }\n}\nexport { trackClsAsStandaloneSpan };","map":{"version":3,"names":["trackClsAsStandaloneSpan","standaloneCLsValue","standaloneClsEntry","pageloadSpanId","supportsLayoutShift","sentSpan","_collectClsOnce","sendStandaloneClsSpan","cleanupClsHandler","addClsInstrumentationHandler","metric","entry","entries","length","value","onHidden","setTimeout","client","getClient","unsubscribeStartNavigation","on","activeSpan","getActiveSpan","rootSpan","getRootSpan","spanJSON","spanToJSON","op","spanContext","spanId","clsValue","DEBUG_BUILD","logger","log","startTime","msToSec","browserPerformanceTimeOrigin","routeName","getCurrentScope","getScopeData","transactionName","name","htmlTreeAsString","sources","node","attributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME","duration","span","startStandaloneWebVitalSpan","transaction","addEvent","SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT","SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE","end","PerformanceObserver","supportedEntryTypes","includes"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\browser-utils\\src\\metrics\\cls.ts"],"sourcesContent":["import {\n  SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME,\n  SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT,\n  SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  getActiveSpan,\n  getClient,\n  getCurrentScope,\n  getRootSpan,\n  spanToJSON,\n} from '@sentry/core';\nimport { browserPerformanceTimeOrigin, htmlTreeAsString, logger } from '@sentry/core';\nimport type { SpanAttributes } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { addClsInstrumentationHandler } from './instrument';\nimport { msToSec, startStandaloneWebVitalSpan } from './utils';\nimport { onHidden } from './web-vitals/lib/onHidden';\n\n/**\n * Starts tracking the Cumulative Layout Shift on the current page and collects the value once\n *\n * - the page visibility is hidden\n * - a navigation span is started (to stop CLS measurement for SPA soft navigations)\n *\n * Once either of these events triggers, the CLS value is sent as a standalone span and we stop\n * measuring CLS.\n */\nexport function trackClsAsStandaloneSpan(): void {\n  let standaloneCLsValue = 0;\n  let standaloneClsEntry: LayoutShift | undefined;\n  let pageloadSpanId: string | undefined;\n\n  if (!supportsLayoutShift()) {\n    return;\n  }\n\n  let sentSpan = false;\n  function _collectClsOnce() {\n    if (sentSpan) {\n      return;\n    }\n    sentSpan = true;\n    if (pageloadSpanId) {\n      sendStandaloneClsSpan(standaloneCLsValue, standaloneClsEntry, pageloadSpanId);\n    }\n    cleanupClsHandler();\n  }\n\n  const cleanupClsHandler = addClsInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1] as LayoutShift | undefined;\n    if (!entry) {\n      return;\n    }\n    standaloneCLsValue = metric.value;\n    standaloneClsEntry = entry;\n  }, true);\n\n  // use pagehide event from web-vitals\n  onHidden(() => {\n    _collectClsOnce();\n  });\n\n  // Since the call chain of this function is synchronous and evaluates before the SDK client is created,\n  // we need to wait with subscribing to a client hook until the client is created. Therefore, we defer\n  // to the next tick after the SDK setup.\n  setTimeout(() => {\n    const client = getClient();\n\n    if (!client) {\n      return;\n    }\n\n    const unsubscribeStartNavigation = client.on('startNavigationSpan', () => {\n      _collectClsOnce();\n      unsubscribeStartNavigation?.();\n    });\n\n    const activeSpan = getActiveSpan();\n    if (activeSpan) {\n      const rootSpan = getRootSpan(activeSpan);\n      const spanJSON = spanToJSON(rootSpan);\n      if (spanJSON.op === 'pageload') {\n        pageloadSpanId = rootSpan.spanContext().spanId;\n      }\n    }\n  }, 0);\n}\n\nfunction sendStandaloneClsSpan(clsValue: number, entry: LayoutShift | undefined, pageloadSpanId: string) {\n  DEBUG_BUILD && logger.log(`Sending CLS span (${clsValue})`);\n\n  const startTime = msToSec((browserPerformanceTimeOrigin() || 0) + (entry?.startTime || 0));\n  const routeName = getCurrentScope().getScopeData().transactionName;\n\n  const name = entry ? htmlTreeAsString(entry.sources[0]?.node) : 'Layout shift';\n\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser.cls',\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'ui.webvital.cls',\n    [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: entry?.duration || 0,\n    // attach the pageload span id to the CLS span so that we can link them in the UI\n    'sentry.pageload.span_id': pageloadSpanId,\n  };\n\n  const span = startStandaloneWebVitalSpan({\n    name,\n    transaction: routeName,\n    attributes,\n    startTime,\n  });\n\n  if (span) {\n    span.addEvent('cls', {\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: '',\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: clsValue,\n    });\n\n    // LayoutShift performance entries always have a duration of 0, so we don't need to add `entry.duration` here\n    // see: https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/duration\n    span.end(startTime);\n  }\n}\n\nfunction supportsLayoutShift(): boolean {\n  try {\n    return PerformanceObserver.supportedEntryTypes.includes('layout-shift');\n  } catch {\n    return false;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}