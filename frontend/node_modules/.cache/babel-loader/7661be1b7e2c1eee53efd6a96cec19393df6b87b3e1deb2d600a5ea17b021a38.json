{"ast":null,"code":"import { addHandler, maybeInstrument, triggerHandlers, supportsHistory, fill } from '@sentry/core';\nimport { WINDOW } from '../types.js';\nlet lastHref;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addHistoryInstrumentationHandler(handler) {\n  const type = 'history';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentHistory);\n}\n\n/**\n * Exported just for testing\n */\nfunction instrumentHistory() {\n  // The `popstate` event may also be triggered on `pushState`, but it may not always reliably be emitted by the browser\n  // Which is why we also monkey-patch methods below, in addition to this\n  WINDOW.addEventListener('popstate', () => {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    if (from === to) {\n      return;\n    }\n    const handlerData = {\n      from,\n      to\n    };\n    triggerHandlers('history', handlerData);\n  });\n\n  // Just guard against this not being available, in weird environments\n  if (!supportsHistory()) {\n    return;\n  }\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function (...args) {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        if (from === to) {\n          return originalHistoryFunction.apply(this, args);\n        }\n        const handlerData = {\n          from,\n          to\n        };\n        triggerHandlers('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\nexport { addHistoryInstrumentationHandler, instrumentHistory };","map":{"version":3,"names":["lastHref","addHistoryInstrumentationHandler","handler","type","addHandler","maybeInstrument","instrumentHistory","WINDOW","addEventListener","to","location","href","from","handlerData","triggerHandlers","supportsHistory","historyReplacementFunction","originalHistoryFunction","args","url","length","undefined","String","apply","fill","history"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry-internal\\browser-utils\\src\\instrument\\history.ts"],"sourcesContent":["import type { HandlerDataHistory } from '@sentry/core';\nimport { addHandler, fill, maybeInstrument, supportsHistory, triggerHandlers } from '@sentry/core';\nimport { WINDOW } from '../types';\n\nlet lastHref: string | undefined;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addHistoryInstrumentationHandler(handler: (data: HandlerDataHistory) => void): void {\n  const type = 'history';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentHistory);\n}\n\n/**\n * Exported just for testing\n */\nexport function instrumentHistory(): void {\n  // The `popstate` event may also be triggered on `pushState`, but it may not always reliably be emitted by the browser\n  // Which is why we also monkey-patch methods below, in addition to this\n  WINDOW.addEventListener('popstate', () => {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n\n    if (from === to) {\n      return;\n    }\n\n    const handlerData = { from, to } satisfies HandlerDataHistory;\n    triggerHandlers('history', handlerData);\n  });\n\n  // Just guard against this not being available, in weird environments\n  if (!supportsHistory()) {\n    return;\n  }\n\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function (this: History, ...args: unknown[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n\n        if (from === to) {\n          return originalHistoryFunction.apply(this, args);\n        }\n\n        const handlerData = { from, to } satisfies HandlerDataHistory;\n        triggerHandlers('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n"],"mappings":";;AAIA,IAAIA,QAAQ;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,gCAAgCA,CAACC,OAAO,EAA4C;EAClG,MAAMC,IAAK,GAAE,SAAS;EACtBC,UAAU,CAACD,IAAI,EAAED,OAAO,CAAC;EACzBG,eAAe,CAACF,IAAI,EAAEG,iBAAiB,CAAC;AAC1C;;AAEA;AACA;AACA;AACO,SAASA,iBAAiBA,CAAA,EAAS;EAC1C;EACA;EACEC,MAAM,CAACC,gBAAgB,CAAC,UAAU,EAAE,MAAM;IACxC,MAAMC,EAAG,GAAEF,MAAM,CAACG,QAAQ,CAACC,IAAI;IACnC;IACI,MAAMC,IAAK,GAAEZ,QAAQ;IACrBA,QAAA,GAAWS,EAAE;IAEb,IAAIG,IAAK,KAAIH,EAAE,EAAE;MACf;IACN;IAEI,MAAMI,WAAY,GAAE;MAAED,IAAI;MAAEH;IAAA,CAAK;IACjCK,eAAe,CAAC,SAAS,EAAED,WAAW,CAAC;EAC3C,CAAG,CAAC;;EAEJ;EACE,IAAI,CAACE,eAAe,EAAE,EAAE;IACtB;EACJ;EAEE,SAASC,0BAA0BA,CAACC,uBAAuB,EAA0B;IACnF,OAAO,UAAyB,GAAGC,IAAI,EAAmB;MACxD,MAAMC,GAAA,GAAMD,IAAI,CAACE,MAAO,GAAE,CAAE,GAAEF,IAAI,CAAC,CAAC,IAAIG,SAAS;MACjD,IAAIF,GAAG,EAAE;QACf;QACQ,MAAMP,IAAK,GAAEZ,QAAQ;QACrB,MAAMS,EAAG,GAAEa,MAAM,CAACH,GAAG,CAAC;QAC9B;QACQnB,QAAA,GAAWS,EAAE;QAEb,IAAIG,IAAK,KAAIH,EAAE,EAAE;UACf,OAAOQ,uBAAuB,CAACM,KAAK,CAAC,IAAI,EAAEL,IAAI,CAAC;QAC1D;QAEQ,MAAML,WAAY,GAAE;UAAED,IAAI;UAAEH;QAAA,CAAK;QACjCK,eAAe,CAAC,SAAS,EAAED,WAAW,CAAC;MAC/C;MACM,OAAOI,uBAAuB,CAACM,KAAK,CAAC,IAAI,EAAEL,IAAI,CAAC;IACtD,CAAK;EACL;EAEEM,IAAI,CAACjB,MAAM,CAACkB,OAAO,EAAE,WAAW,EAAET,0BAA0B,CAAC;EAC7DQ,IAAI,CAACjB,MAAM,CAACkB,OAAO,EAAE,cAAc,EAAET,0BAA0B,CAAC;AAClE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}