{"ast":null,"code":"import { isErrorEvent, isDOMError, isDOMException, addExceptionTypeValue, isError, isPlainObject, isEvent, addExceptionMechanism, isParameterizedString, getClient, normalizeToSize, extractExceptionKeysForMessage, resolvedSyncPromise } from '@sentry/core';\n\n/**\n * This function creates an exception from a JavaScript Error\n */\nfunction exceptionFromError(stackParser, ex) {\n  // Get the frames first since Opera can lose the stack if we touch anything else first\n  const frames = parseStackFrames(stackParser, ex);\n  const exception = {\n    type: extractType(ex),\n    value: extractMessage(ex)\n  };\n  if (frames.length) {\n    exception.stacktrace = {\n      frames\n    };\n  }\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n  return exception;\n}\nfunction eventFromPlainObject(stackParser, exception, syntheticException, isUnhandledRejection) {\n  const client = getClient();\n  const normalizeDepth = client?.getOptions().normalizeDepth;\n\n  // If we can, we extract an exception from the object properties\n  const errorFromProp = getErrorPropertyFromObject(exception);\n  const extra = {\n    __serialized__: normalizeToSize(exception, normalizeDepth)\n  };\n  if (errorFromProp) {\n    return {\n      exception: {\n        values: [exceptionFromError(stackParser, errorFromProp)]\n      },\n      extra\n    };\n  }\n  const event = {\n    exception: {\n      values: [{\n        type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',\n        value: getNonErrorObjectExceptionValue(exception, {\n          isUnhandledRejection\n        })\n      }]\n    },\n    extra\n  };\n  if (syntheticException) {\n    const frames = parseStackFrames(stackParser, syntheticException);\n    if (frames.length) {\n      // event.exception.values[0] has been set above\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      event.exception.values[0].stacktrace = {\n        frames\n      };\n    }\n  }\n  return event;\n}\nfunction eventFromError(stackParser, ex) {\n  return {\n    exception: {\n      values: [exceptionFromError(stackParser, ex)]\n    }\n  };\n}\n\n/** Parses stack frames from an error */\nfunction parseStackFrames(stackParser, ex) {\n  // Access and store the stacktrace property before doing ANYTHING\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  const stacktrace = ex.stacktrace || ex.stack || '';\n  const skipLines = getSkipFirstStackStringLines(ex);\n  const framesToPop = getPopFirstTopFrames(ex);\n  try {\n    return stackParser(stacktrace, skipLines, framesToPop);\n  } catch (e) {\n    // no-empty\n  }\n  return [];\n}\n\n// Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108\nconst reactMinifiedRegexp = /Minified React error #\\d+;/i;\n\n/**\n * Certain known React errors contain links that would be falsely\n * parsed as frames. This function check for these errors and\n * returns number of the stack string lines to skip.\n */\nfunction getSkipFirstStackStringLines(ex) {\n  if (ex && reactMinifiedRegexp.test(ex.message)) {\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * If error has `framesToPop` property, it means that the\n * creator tells us the first x frames will be useless\n * and should be discarded. Typically error from wrapper function\n * which don't point to the actual location in the developer's code.\n *\n * Example: https://github.com/zertosh/invariant/blob/master/invariant.js#L46\n */\nfunction getPopFirstTopFrames(ex) {\n  if (typeof ex.framesToPop === 'number') {\n    return ex.framesToPop;\n  }\n  return 0;\n}\n\n// https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Exception\n// @ts-expect-error - WebAssembly.Exception is a valid class\nfunction isWebAssemblyException(exception) {\n  // Check for support\n  // @ts-expect-error - WebAssembly.Exception is a valid class\n  if (typeof WebAssembly !== 'undefined' && typeof WebAssembly.Exception !== 'undefined') {\n    // @ts-expect-error - WebAssembly.Exception is a valid class\n    return exception instanceof WebAssembly.Exception;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Extracts from errors what we use as the exception `type` in error events.\n *\n * Usually, this is the `name` property on Error objects but WASM errors need to be treated differently.\n */\nfunction extractType(ex) {\n  const name = ex?.name;\n\n  // The name for WebAssembly.Exception Errors needs to be extracted differently.\n  // Context: https://github.com/getsentry/sentry-javascript/issues/13787\n  if (!name && isWebAssemblyException(ex)) {\n    // Emscripten sets array[type, message] to the \"message\" property on the WebAssembly.Exception object\n    const hasTypeInMessage = ex.message && Array.isArray(ex.message) && ex.message.length == 2;\n    return hasTypeInMessage ? ex.message[0] : 'WebAssembly.Exception';\n  }\n  return name;\n}\n\n/**\n * There are cases where stacktrace.message is an Event object\n * https://github.com/getsentry/sentry-javascript/issues/1949\n * In this specific case we try to extract stacktrace.message.error.message\n */\nfunction extractMessage(ex) {\n  const message = ex?.message;\n  if (isWebAssemblyException(ex)) {\n    // For Node 18, Emscripten sets array[type, message] to the \"message\" property on the WebAssembly.Exception object\n    if (Array.isArray(ex.message) && ex.message.length == 2) {\n      return ex.message[1];\n    }\n    return 'wasm exception';\n  }\n  if (!message) {\n    return 'No error message';\n  }\n  if (message.error && typeof message.error.message === 'string') {\n    return message.error.message;\n  }\n  return message;\n}\n\n/**\n * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n * @hidden\n */\nfunction eventFromException(stackParser, exception, hint, attachStacktrace) {\n  const syntheticException = hint?.syntheticException || undefined;\n  const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);\n  addExceptionMechanism(event); // defaults to { type: 'generic', handled: true }\n  event.level = 'error';\n  if (hint?.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nfunction eventFromMessage(stackParser, message, level = 'info', hint, attachStacktrace) {\n  const syntheticException = hint?.syntheticException || undefined;\n  const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n  event.level = level;\n  if (hint?.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n\n/**\n * @hidden\n */\nfunction eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace, isUnhandledRejection) {\n  let event;\n  if (isErrorEvent(exception) && exception.error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    const errorEvent = exception;\n    return eventFromError(stackParser, errorEvent.error);\n  }\n\n  // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name\n  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be\n  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.\n  //\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n  // https://webidl.spec.whatwg.org/#es-DOMException-specialness\n  if (isDOMError(exception) || isDOMException(exception)) {\n    const domException = exception;\n    if ('stack' in exception) {\n      event = eventFromError(stackParser, exception);\n    } else {\n      const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n      const message = domException.message ? `${name}: ${domException.message}` : name;\n      event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n      addExceptionTypeValue(event, message);\n    }\n    if ('code' in domException) {\n      // eslint-disable-next-line deprecation/deprecation\n      event.tags = {\n        ...event.tags,\n        'DOMException.code': `${domException.code}`\n      };\n    }\n    return event;\n  }\n  if (isError(exception)) {\n    // we have a real Error object, do nothing\n    return eventFromError(stackParser, exception);\n  }\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize\n    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new\n    // group on any key/value change.\n    const objectException = exception;\n    event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);\n    addExceptionMechanism(event, {\n      synthetic: true\n    });\n    return event;\n  }\n\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(stackParser, exception, syntheticException, attachStacktrace);\n  addExceptionTypeValue(event, `${exception}`, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true\n  });\n  return event;\n}\nfunction eventFromString(stackParser, message, syntheticException, attachStacktrace) {\n  const event = {};\n  if (attachStacktrace && syntheticException) {\n    const frames = parseStackFrames(stackParser, syntheticException);\n    if (frames.length) {\n      event.exception = {\n        values: [{\n          value: message,\n          stacktrace: {\n            frames\n          }\n        }]\n      };\n    }\n    addExceptionMechanism(event, {\n      synthetic: true\n    });\n  }\n  if (isParameterizedString(message)) {\n    const {\n      __sentry_template_string__,\n      __sentry_template_values__\n    } = message;\n    event.logentry = {\n      message: __sentry_template_string__,\n      params: __sentry_template_values__\n    };\n    return event;\n  }\n  event.message = message;\n  return event;\n}\nfunction getNonErrorObjectExceptionValue(exception, {\n  isUnhandledRejection\n}) {\n  const keys = extractExceptionKeysForMessage(exception);\n  const captureType = isUnhandledRejection ? 'promise rejection' : 'exception';\n\n  // Some ErrorEvent instances do not have an `error` property, which is why they are not handled before\n  // We still want to try to get a decent message for these cases\n  if (isErrorEvent(exception)) {\n    return `Event \\`ErrorEvent\\` captured as ${captureType} with message \\`${exception.message}\\``;\n  }\n  if (isEvent(exception)) {\n    const className = getObjectClassName(exception);\n    return `Event \\`${className}\\` (type=${exception.type}) captured as ${captureType}`;\n  }\n  return `Object captured as ${captureType} with keys: ${keys}`;\n}\nfunction getObjectClassName(obj) {\n  try {\n    const prototype = Object.getPrototypeOf(obj);\n    return prototype ? prototype.constructor.name : undefined;\n  } catch (e) {\n    // ignore errors here\n  }\n}\n\n/** If a plain object has a property that is an `Error`, return this error. */\nfunction getErrorPropertyFromObject(obj) {\n  for (const prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      const value = obj[prop];\n      if (value instanceof Error) {\n        return value;\n      }\n    }\n  }\n  return undefined;\n}\nexport { eventFromException, eventFromMessage, eventFromUnknownInput, exceptionFromError, extractMessage, extractType };","map":{"version":3,"names":["exceptionFromError","stackParser","ex","frames","parseStackFrames","exception","type","extractType","value","extractMessage","length","stacktrace","undefined","eventFromPlainObject","syntheticException","isUnhandledRejection","client","getClient","normalizeDepth","getOptions","errorFromProp","getErrorPropertyFromObject","extra","__serialized__","normalizeToSize","values","event","isEvent","constructor","name","getNonErrorObjectExceptionValue","eventFromError","stack","skipLines","getSkipFirstStackStringLines","framesToPop","getPopFirstTopFrames","e","reactMinifiedRegexp","test","message","isWebAssemblyException","WebAssembly","Exception","hasTypeInMessage","Array","isArray","error","eventFromException","hint","attachStacktrace","eventFromUnknownInput","addExceptionMechanism","level","event_id","resolvedSyncPromise","eventFromMessage","eventFromString","isErrorEvent","errorEvent","isDOMError","isDOMException","domException","addExceptionTypeValue","tags","code","isError","isPlainObject","objectException","synthetic","isParameterizedString","__sentry_template_string__","__sentry_template_values__","logentry","params","keys","extractExceptionKeysForMessage","captureType","className","getObjectClassName","obj","prototype","Object","getPrototypeOf","prop","hasOwnProperty","call","Error"],"sources":["C:\\Users\\chitt\\OneDrive\\Documents\\Projects\\fresh-bulk\\frontend\\node_modules\\@sentry\\browser\\src\\eventbuilder.ts"],"sourcesContent":["import type {\n  Event,\n  EventHint,\n  Exception,\n  ParameterizedString,\n  SeverityLevel,\n  StackFrame,\n  StackParser,\n} from '@sentry/core';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  extractExceptionKeysForMessage,\n  getClient,\n  isDOMError,\n  isDOMException,\n  isError,\n  isErrorEvent,\n  isEvent,\n  isParameterizedString,\n  isPlainObject,\n  normalizeToSize,\n  resolvedSyncPromise,\n} from '@sentry/core';\n\ntype Prototype = { constructor: (...args: unknown[]) => unknown };\n\n/**\n * This function creates an exception from a JavaScript Error\n */\nexport function exceptionFromError(stackParser: StackParser, ex: Error): Exception {\n  // Get the frames first since Opera can lose the stack if we touch anything else first\n  const frames = parseStackFrames(stackParser, ex);\n\n  const exception: Exception = {\n    type: extractType(ex),\n    value: extractMessage(ex),\n  };\n\n  if (frames.length) {\n    exception.stacktrace = { frames };\n  }\n\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n\n  return exception;\n}\n\nfunction eventFromPlainObject(\n  stackParser: StackParser,\n  exception: Record<string, unknown>,\n  syntheticException?: Error,\n  isUnhandledRejection?: boolean,\n): Event {\n  const client = getClient();\n  const normalizeDepth = client?.getOptions().normalizeDepth;\n\n  // If we can, we extract an exception from the object properties\n  const errorFromProp = getErrorPropertyFromObject(exception);\n\n  const extra = {\n    __serialized__: normalizeToSize(exception, normalizeDepth),\n  };\n\n  if (errorFromProp) {\n    return {\n      exception: {\n        values: [exceptionFromError(stackParser, errorFromProp)],\n      },\n      extra,\n    };\n  }\n\n  const event = {\n    exception: {\n      values: [\n        {\n          type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',\n          value: getNonErrorObjectExceptionValue(exception, { isUnhandledRejection }),\n        } as Exception,\n      ],\n    },\n    extra,\n  } satisfies Event;\n\n  if (syntheticException) {\n    const frames = parseStackFrames(stackParser, syntheticException);\n    if (frames.length) {\n      // event.exception.values[0] has been set above\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      event.exception.values[0]!.stacktrace = { frames };\n    }\n  }\n\n  return event;\n}\n\nfunction eventFromError(stackParser: StackParser, ex: Error): Event {\n  return {\n    exception: {\n      values: [exceptionFromError(stackParser, ex)],\n    },\n  };\n}\n\n/** Parses stack frames from an error */\nfunction parseStackFrames(\n  stackParser: StackParser,\n  ex: Error & { framesToPop?: number; stacktrace?: string },\n): StackFrame[] {\n  // Access and store the stacktrace property before doing ANYTHING\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  const stacktrace = ex.stacktrace || ex.stack || '';\n\n  const skipLines = getSkipFirstStackStringLines(ex);\n  const framesToPop = getPopFirstTopFrames(ex);\n\n  try {\n    return stackParser(stacktrace, skipLines, framesToPop);\n  } catch (e) {\n    // no-empty\n  }\n\n  return [];\n}\n\n// Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108\nconst reactMinifiedRegexp = /Minified React error #\\d+;/i;\n\n/**\n * Certain known React errors contain links that would be falsely\n * parsed as frames. This function check for these errors and\n * returns number of the stack string lines to skip.\n */\nfunction getSkipFirstStackStringLines(ex: Error): number {\n  if (ex && reactMinifiedRegexp.test(ex.message)) {\n    return 1;\n  }\n\n  return 0;\n}\n\n/**\n * If error has `framesToPop` property, it means that the\n * creator tells us the first x frames will be useless\n * and should be discarded. Typically error from wrapper function\n * which don't point to the actual location in the developer's code.\n *\n * Example: https://github.com/zertosh/invariant/blob/master/invariant.js#L46\n */\nfunction getPopFirstTopFrames(ex: Error & { framesToPop?: unknown }): number {\n  if (typeof ex.framesToPop === 'number') {\n    return ex.framesToPop;\n  }\n\n  return 0;\n}\n\n// https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Exception\n// @ts-expect-error - WebAssembly.Exception is a valid class\nfunction isWebAssemblyException(exception: unknown): exception is WebAssembly.Exception {\n  // Check for support\n  // @ts-expect-error - WebAssembly.Exception is a valid class\n  if (typeof WebAssembly !== 'undefined' && typeof WebAssembly.Exception !== 'undefined') {\n    // @ts-expect-error - WebAssembly.Exception is a valid class\n    return exception instanceof WebAssembly.Exception;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Extracts from errors what we use as the exception `type` in error events.\n *\n * Usually, this is the `name` property on Error objects but WASM errors need to be treated differently.\n */\nexport function extractType(ex: Error & { message: { error?: Error } }): string | undefined {\n  const name = ex?.name;\n\n  // The name for WebAssembly.Exception Errors needs to be extracted differently.\n  // Context: https://github.com/getsentry/sentry-javascript/issues/13787\n  if (!name && isWebAssemblyException(ex)) {\n    // Emscripten sets array[type, message] to the \"message\" property on the WebAssembly.Exception object\n    const hasTypeInMessage = ex.message && Array.isArray(ex.message) && ex.message.length == 2;\n    return hasTypeInMessage ? ex.message[0] : 'WebAssembly.Exception';\n  }\n\n  return name;\n}\n\n/**\n * There are cases where stacktrace.message is an Event object\n * https://github.com/getsentry/sentry-javascript/issues/1949\n * In this specific case we try to extract stacktrace.message.error.message\n */\nexport function extractMessage(ex: Error & { message: { error?: Error } }): string {\n  const message = ex?.message;\n\n  if (isWebAssemblyException(ex)) {\n    // For Node 18, Emscripten sets array[type, message] to the \"message\" property on the WebAssembly.Exception object\n    if (Array.isArray(ex.message) && ex.message.length == 2) {\n      return ex.message[1];\n    }\n    return 'wasm exception';\n  }\n\n  if (!message) {\n    return 'No error message';\n  }\n\n  if (message.error && typeof message.error.message === 'string') {\n    return message.error.message;\n  }\n\n  return message;\n}\n\n/**\n * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n * @hidden\n */\nexport function eventFromException(\n  stackParser: StackParser,\n  exception: unknown,\n  hint?: EventHint,\n  attachStacktrace?: boolean,\n): PromiseLike<Event> {\n  const syntheticException = hint?.syntheticException || undefined;\n  const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);\n  addExceptionMechanism(event); // defaults to { type: 'generic', handled: true }\n  event.level = 'error';\n  if (hint?.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(\n  stackParser: StackParser,\n  message: ParameterizedString,\n  level: SeverityLevel = 'info',\n  hint?: EventHint,\n  attachStacktrace?: boolean,\n): PromiseLike<Event> {\n  const syntheticException = hint?.syntheticException || undefined;\n  const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n  event.level = level;\n  if (hint?.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n\n/**\n * @hidden\n */\nexport function eventFromUnknownInput(\n  stackParser: StackParser,\n  exception: unknown,\n  syntheticException?: Error,\n  attachStacktrace?: boolean,\n  isUnhandledRejection?: boolean,\n): Event {\n  let event: Event;\n\n  if (isErrorEvent(exception as ErrorEvent) && (exception as ErrorEvent).error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    const errorEvent = exception as ErrorEvent;\n    return eventFromError(stackParser, errorEvent.error as Error);\n  }\n\n  // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name\n  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be\n  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.\n  //\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n  // https://webidl.spec.whatwg.org/#es-DOMException-specialness\n  if (isDOMError(exception) || isDOMException(exception as DOMException)) {\n    const domException = exception as DOMException;\n\n    if ('stack' in (exception as Error)) {\n      event = eventFromError(stackParser, exception as Error);\n    } else {\n      const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n      const message = domException.message ? `${name}: ${domException.message}` : name;\n      event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n      addExceptionTypeValue(event, message);\n    }\n    if ('code' in domException) {\n      // eslint-disable-next-line deprecation/deprecation\n      event.tags = { ...event.tags, 'DOMException.code': `${domException.code}` };\n    }\n\n    return event;\n  }\n  if (isError(exception)) {\n    // we have a real Error object, do nothing\n    return eventFromError(stackParser, exception);\n  }\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize\n    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new\n    // group on any key/value change.\n    const objectException = exception as Record<string, unknown>;\n    event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);\n    addExceptionMechanism(event, {\n      synthetic: true,\n    });\n    return event;\n  }\n\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(stackParser, exception as string, syntheticException, attachStacktrace);\n  addExceptionTypeValue(event, `${exception}`, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true,\n  });\n\n  return event;\n}\n\nfunction eventFromString(\n  stackParser: StackParser,\n  message: ParameterizedString,\n  syntheticException?: Error,\n  attachStacktrace?: boolean,\n): Event {\n  const event: Event = {};\n\n  if (attachStacktrace && syntheticException) {\n    const frames = parseStackFrames(stackParser, syntheticException);\n    if (frames.length) {\n      event.exception = {\n        values: [{ value: message, stacktrace: { frames } }],\n      };\n    }\n    addExceptionMechanism(event, { synthetic: true });\n  }\n\n  if (isParameterizedString(message)) {\n    const { __sentry_template_string__, __sentry_template_values__ } = message;\n\n    event.logentry = {\n      message: __sentry_template_string__,\n      params: __sentry_template_values__,\n    };\n    return event;\n  }\n\n  event.message = message;\n  return event;\n}\n\nfunction getNonErrorObjectExceptionValue(\n  exception: Record<string, unknown>,\n  { isUnhandledRejection }: { isUnhandledRejection?: boolean },\n): string {\n  const keys = extractExceptionKeysForMessage(exception);\n  const captureType = isUnhandledRejection ? 'promise rejection' : 'exception';\n\n  // Some ErrorEvent instances do not have an `error` property, which is why they are not handled before\n  // We still want to try to get a decent message for these cases\n  if (isErrorEvent(exception)) {\n    return `Event \\`ErrorEvent\\` captured as ${captureType} with message \\`${exception.message}\\``;\n  }\n\n  if (isEvent(exception)) {\n    const className = getObjectClassName(exception);\n    return `Event \\`${className}\\` (type=${exception.type}) captured as ${captureType}`;\n  }\n\n  return `Object captured as ${captureType} with keys: ${keys}`;\n}\n\nfunction getObjectClassName(obj: unknown): string | undefined | void {\n  try {\n    const prototype: Prototype | null = Object.getPrototypeOf(obj);\n    return prototype ? prototype.constructor.name : undefined;\n  } catch (e) {\n    // ignore errors here\n  }\n}\n\n/** If a plain object has a property that is an `Error`, return this error. */\nfunction getErrorPropertyFromObject(obj: Record<string, unknown>): Error | undefined {\n  for (const prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      const value = obj[prop];\n      if (value instanceof Error) {\n        return value;\n      }\n    }\n  }\n\n  return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}